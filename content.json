{"pages":[{"title":"About - the legend","text":"About Me嗨，你好，我是张耀。网络面具：白、YaoYaozz、耀耀zz、AIZhangyao在这里，此博客用来记录个人生活、分享技术踩过的坑。 Education Experience计算机科学与技术（嵌入式培养）@南通大学2015-2019高中@江苏省郑集高级中学2012-2019初中@徐州市铜山区黄集镇中心中学2009-2012幼儿园&amp;小学@神洼小学2002-2009 Work Experience嗑瓜子@某某信息技术有限公司2018.12-2019.04搬砖@某某能源股份有限公司2019.05-2019.07摸鱼@某某能源科技有限公司2019.08-至今 Honors2006年时代周刊年度风云人物2008感动中国年度人物特别奖 Skills Personal Resume点击在线预览 Short-term Plan暴富！！！ Long-term Plan科技造福人类！！","link":"/about/index.html"},{"title":"Old Resume of Zhang Yao","text":"&lt;&lt;手滑不看 我的简历个人信息张耀/男/1997.07本科/2015.09-2019.06南通大学计算机科学与技术(嵌入式培养)工作年限/1年技术博客/http://www.aizhangyao.com/GitHub/http://github.com/aizhangyao/手机/17805053916Email/819647113@qq.com微信号/izh_yao期望职位/Java开发工程师期望薪资/税前月薪15-20k,特别喜欢的公司可例外期望城市/上海 工作经历(2019.05-至今) 江苏林洋能源股份有限公司 Java开发工程师负责智能电表前置通讯，完成电表数据采集、电表设置等；参与系统需求分析，对系统设计所需要技术方案进行规划与制定，确保系统需求得到满足;负责相关数据模型设计，并完成Web后台开发，推动项目顺利开发;编写概要设计、详细设计、用户用例等软件开发相关文档; 项目经历2019.07-至今 MDMS(Meter Data Management System) Java开发工程师项目简介该项目主要服务于亚非拉国家各电力部门，为其提供智能电表的数据采集与控制，资产管理，数据分析等服务，目前已在伊朗，孟加拉等国家部署使用。系统主要有UI、Web服务端、前置采集系统等组成。 主要职责 参与前置采集系统的设计与开发，该模块用于实现智能电表的数据采集与控制。主要涉及的模块有定时任务采集数据，数据解析、编解码，存库等。(Java/Mina/Redis/Mq/Postgres) 完成Web服务端基础功能的实现,主要有数据查询，参数设置，请求终端数据等。(Springboot,Redisson,Socket) 负责对外接口的设计与开发工作，主要为第三方系统提供数据以及获取第三方系统的数据。(Webservice,Cxf) 对常用的一些工具类的封装。 开源项目和作品开源项目(写代码能力 Show me code) blogf : Star:0;Fork:0;简要说明; Project : Star:0;Fork:0;简要说明; 技术文章(挑选你的写作或者翻译的技术文章–沟通表达能力、英文技术文献的阅读能力) 浅谈互联网美发是种什么样的生活方式(写作文章) (翻译文章) 演讲和讲义(放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义。) 12月公司内部分享 : 我是怎么上班时间摸鱼的 技能清单（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错） 熟悉JavaWeb开发、Java基础扎实 熟悉并发编程、了解JVM 熟悉掌握spring/SpringMVC/SpringBoot等框架 熟悉Mina/Netty服务端模式开发 熟悉WebService/Xml等技术 熟悉MySql/Postgres等数据库 熟悉Redis/RabbitMQ等中间件 致谢感谢您花时间阅读我的简历，期待能有机会和您共事!","link":"/about/resume-old.html"},{"title":"Resume of Zhang Yao","text":"张耀的简历联系方式 手机号码：17805053916 Email：819647113@qq.com 微信号：izh_yao 个人信息 张耀/男 1997.07 本科/2015.09-2019.06/南通大学计算机科学与技术(嵌入式培养) 工作年限：1年以上 GitHub：http://github.com/aizhangyao/ 期望职位：Java开发工程师 期望城市：上海 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） (2019.08-至今) 上海云谏能源科技有限公司 Java开发工程师负责智能电表前置通讯，完成电表数据采集、电表设置等；参与系统需求分析，对系统设计所需要技术方案进行规划与制定，确保系统需求得到满足；负责相关数据模型设计，并完成Web后台开发，推动项目顺利开发；编写概要设计、详细设计、用户用例等软件开发相关文档； (2019.05-2019.08) 江苏林洋能源股份有限公司 软件开发工程师负责国网698前置机项目的二次开发。在原有代码基础上增加可视化界面，显示数据收发过程。主要是通过分析原有项目建立页面数据模型，并使用wpf显示数据。 (2018.01-2018.12) 南京虞如梦信息技术有限公司 软件开发工程师负责独立开发完成美发预约小程序以及系统上线后需求迭代和维护。 项目经历MDMS(Meter Data Management System) Java开发工程师项目简介该项目主要服务于亚非拉国家各电力部门，为其提供智能电表的数据采集与控制、资产管理、数据分析等服务，目前已在伊朗、老挝、孟加拉等国部署使用。系统主要有Web前端、Java服务端和前置采集系统三部分组成。 主要职责 参与前置采集系统的设计与开发，该模块用于实现智能电表的数据采集与控制。主要涉及的模块有定时任务采集数据、数据解析、编解码和数据存库等。(Java、Mina、Redis、RabbitMQ、Postgres) 完成Web服务端基础功能的实现，主要有数据查询、参数设置、请求终端数据等。(SpringBoot、Redisson、Socket) 负责对外接口的设计与开发工作，主要为第三方系统提供数据以及获取第三方系统的数据。(Webservice、Cxf) 对常用的一些工具类的封装。 这理美吧美发预约系统 软件开发工程师项目简介本项目主要功能是帮助用户进行美发预约。用户端主要使用微信小程展示美发项目供消费者挑选服务进行预约。商家端包含在线接单、店铺管理、统计分析等功能。 涉及技术 前端分别使用Color-UI和Element-UI框架完成微信小程序和商家端页面的开发。后端使用SpringBoot进行项目整合。 采用分布式的项目开发模式整个项目分为：后台管理、支付、优惠、用户、仓储、秒杀、订单、ELK检索、购物车、第三方服务、中央认证等十多个服务。* 基于RabbitMQ支持消息事务这一特点，在项目开发过程中使用这一特点，采用最大努力通知的分布式事务解决方案去处理分布式事务场景。 基于Redis消息中间件，实现了购物车，接口幂等，秒杀活动等高并发访问场景的开发。 对数据量较大的表使用Sharding-JDBC数据库中间件在主从同步，从从同步的基础上实现了分库分表，读写分离。 采用Elasticsearch、Logstash、Kibana这套经典组合，实现了数据库数据同步Es大幅提升了高并发场景的搜索效率，并采用ik中文分词器强化了分词搜索的功能。线上错误日志收集，提升开发人员线上问题的错误日志定位效率。 主要职责 独立开发完成项目前后台开发。 负责Es相关需求开发，如商品上架和检索、日志存储检索。 负责活动商品下单流程开发。 技能清单 熟悉Java基础。[集合、IO、并发、多线程等] 熟悉MySQL、Postgres关系型数据库。[事务、索引、sql语句调优等] 熟悉多线程基础知识。[并发理论、关键字、锁、线程池和其他并发工具等] 熟悉JVM原理。[内存模型、类加载、对象创建过程、垃圾回收、性能调优等] 熟悉Spring、SpringMVC、SpringBoot等框架。[IOC、AOP、SpringBoot自动装配原理等] 熟悉Redis、RabbitMQ等中间件。[消息队列的高可用、幂等性、可靠性、顺序性] 了解Spring Cloud Alibaba分布式服务框架。[Nacos、OpenFeign、GateWay等组件] 熟悉常用的设计模式，熟悉Maven项目构建工具。 熟悉Linux常用命令，掌握Nginx的使用方法及复杂均衡策略。 掌握基本的数据结构和算法，了解基本的计算机网络协议，如HTTP、TCP、UDP等。 自我评价 具备良好的语言表达和沟通能力，有责任心。 喜欢读工具书，遵循阿里开发手册，有良好的代码规范。喜欢代码Review，会思考重构自己的代码。 热爱技术，乐于和他人一起分享和讨论技术。不惧困难，勇于尝试探索。 致谢感谢您花时间阅读我的简历，期待能有机会和您共事!","link":"/about/resume.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"使用Github+Hexo搭建个人博客（一）","text":"【摘要】使用Github+Hexo搭建个人博客 前言：电脑系统为window 10专业版，64位。 1 安装Node.js和配置Node.js环境安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下： 2 安装Git和配置Git环境安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择： 注：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的话，可以运行git --version。 3 Github账户注册和新建项目项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。 并且需要勾选Initialize this repository with a README。 4 安装Hexo选取本地合适的地方，创建一个文件夹，然后使用命令行进入到该文件夹里面。 输入npm install hexo -g，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号。 出现下面的页面，说明成功了。 5 将Hexo与Github page联系起来设置Git的user name和email（如果是第一次的话）。进入文件夹右击鼠标右键，进入Git Base Here。 用户名可以设置为自己的，邮箱可以替换成自己的。 输入cd ~/.ssh，检查是否有.ssh的文件夹 输入sl，列出该文件下的内容。 输入ssh-keygen -t rsa -C &quot;zhangyao9707@163.com&quot;，连续三个回车，生成秘钥，最后得到了两个文件，id_rsa和id_rsa.pub（默认存放路径是：C:\\Users\\Administrator\\ .ssh） 输入eval &quot;$(ssh-agent -s)&quot;，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Cithub，点击右上方头像下面的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试： 在终端 ssh -T git@github.com 6配置Deployment在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值就是你在github项目里的ssh（右下角） 7 新建一篇博客在cmd执行命令：hexo new post &quot;博客名&quot; 这时候在文件夹_posts目录下将会看到已经创建的文件 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章","link":"/blog/githubio-1.html"},{"title":"搭建博客目录","text":"【摘要】个人博客搭建~ 内容目录搭建过程 使用Github+Hexo搭建个人博客（一） 使用Github+Hexo搭建个人博客（二） 工具选择 使MarkDown基本操作 赞助如果您认为此页对您有帮助，请扫描下方二维码请我喝一杯咖啡哦~ 微信赞助 支付宝赞助","link":"/catalog/a-blogf-catalog.html"},{"title":"使用Github+Hexo搭建个人博客（二）","text":"【摘要】使用Github+Hexo搭建个人博客 主题的配置：这里以Next主题为题材 1 安装Next在其文件夹中鼠标右键，点击Git Base Here。输入命令: 1git clone https://github.com/theme-next/hexo-theme-next themes/next 2 启用主题在站点目录中(blog)，打开配置文件_config.yml，修改theme:next 3 验证主题若端口号被占用还是得先修改端口号，然后启动服务。 如果看到了如下的界面，说明成功安装了NexT主题。 4 主题设定在next主题下的_config.yml文件中将scheme设定为Pisces 5 语言设定在站点根目录下修改配置文件_cofig.yml中的language为zh-Hans/zh-CN（简体中文） 6 修改菜单项在主题目录下修改配置文件_cofig.yml中的menu，增添一个something（注：千万不要在这设置中文，后面的值那是查找文件的地方！若你的站点运行在子目录中，请将链接前缀的 / 去掉） 这些配置都要与你主题目录下的languages文件中对应的yml文档里配置相关联。比如你在站点根目录中的配置文件设置language为zh-Hans，那么就要进入到主题目录下的languages文件中修改zh-Hans.yml，这样才能显示出菜单项新增的中文内容（以something为例子） 7 设置菜单项图标设置菜单项图标，对应的字段是menu_icons。格式为item name：icon name，其中item name与所配置的菜单名字对应，icon name是Font Awesome图标的名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 8 设置侧栏位置设置侧栏位置，修改主题目录下sidebar的position值。 9 设置头像设置头像，在站点根目录下载配置文件中的avatar，值设置为头像的链接地址。地址可以是网络地址，也可以是本地地址（放置在source//gallery/images/ 目录下） 10 设置文章代码主题设置文章代码主题，在主题目录下修改配置文件highlight_theme，默认值为nomal。可以设置为night。 11 添加标签页面添加标签页面，前面通过修改next主题下的_config.yml文件中的menu选项，可以在主页面的菜单栏添加标签选项，但是此时点击标签，跳转的页面会显示page not found。此时我们要新建一个页面。 在新建的index.md文件中添加type: “tags” 当要为某一篇文章添加标签，只需在blog/source/_post目录下的具体文章的tags中添加标签即可，如： 成功后的页面为 12 添加关于我页面步骤和上面差不多 在新建的index.md文件中添加如下内容 13 在首页添加github导航条点击这里选择需要的样式，然后将代码复制到themes/next/layout/_layout.swig 1&lt;a href=\"https://github.com/you\"&gt;&lt;img width=\"149\" height=\"149\" style=\"position:absolute;top:0;left:0;border:0;\" src=\"https://github.blog/wp-content/uploads/2008/12/forkme_left_darkblue_121621.png?resize=149%2C149\" class=\"attachment-full size-full\" alt=\"Fork me on GitHub\" data-recalc-dims=\"1\"&gt;&lt;/a&gt; 并将href改为你的github地址，最终界面如图 14 修改作者头像并旋转修改作者头像并旋转，打开\\themes\\next\\source\\css_common\\components\\sidebar\\sidebar-author.styl，在里面添加如下代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;}img:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);}/* Z 轴旋转动画 */@-webkit-keyframes play { 0% { -webkit-transform: rotateZ(0deg); } 100% { -webkit-transform: rotateZ(-360deg); }}@-moz-keyframes play { 0% { -moz-transform: rotateZ(0deg); } 100% { -moz-transform: rotateZ(-360deg); }}@keyframes play { 0% { transform: rotateZ(0deg); } 100% { transform: rotateZ(-360deg); }} 15 在网站底部加上访问量在网站底部加上访问量，打开\\themes\\next\\layout_partials\\footer.swig文件,在类copyright前加上画红线这话。 1&lt;script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 然后在合适的位置添加显示统计的代码(位置还是上述这个文件)，如图： 代码： 12345&lt;div class=\"powered-by\"&gt;&lt;i class=\"fa fa-user-md\"&gt;&lt;/i&gt;&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数:&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 16 修改底部的官方logo修改底部的官方logo，找到 \\themes\\next\\layout\\_partials\\下面的footer.swig文件，打开会发现，如下图的语句： 接下来，处理剩余的中文信息。找到这个地方\\themes\\next\\languages\\ 下面的语言文件zh-Hans.yml（这里以中文为例，有的习惯用英文的配置文件，道理一样，找对应位置即可） 这个就是传值传过去的。","link":"/blog/githubio-2.html"},{"title":"后台报表业务开发","text":"【摘要】有现成的报表工具，何必再浪费时间去开发呢？ 前言最近项目组在开发《智能远程抄表预付费系统》，因为进度紧张，所以领导临时安排我写写报表业务。简单的说：报表就是用表格、图表等格式来动态显示数据。在业务上理解起来并不困难，唯一的问题就是需要梳理清各个数据库表的关系。项目基于开源项目jeecg-boot 进行二次开发。 前端：Vue+使用开源项目jeecg-boot中封装的曲线、柱状图、饼状图、折线图等报表组件。后端：Spring Boot+Mybatis Plus数据库：PostgreSQL 1.熟悉相关表结构以及表与表之间的关系。2.参考原型图和后台数据库写出查询数据的sql。3.从mapper-&gt;service-&gt;controller在Java层面处理数据并返回json格式。 不要以为报表就是很简单的查出来几条sql数据，直接扔过去就ok了。其实，额额额，其实也差不多。不过呢，问题总会遇到的，下面我打算总结几个值得记录的问题。 注：为了保证公司业务的安全性，不会直接贴代码。创建几个简单的表，讲讲思路，达到效果就可以。 按日期分组(GROUP BY)查询统计时 空数据补0 1.新建日期临时表 联合查询 UNION 2.在Java中补充数据 同列分类求和并按其他列分组 userid type income 1 微信 4 2 支付宝 2 2 微信 6 1 支付宝 7 … … … 问题描述：如上表 INCOME，要分别统计每个用户微信、支付宝的收入总和，结果格式如下。(即按微信、支付宝分类，按照userid分group求和) userid 微信 支付宝 1 xxx xxx 2 xxx xxx 1234SELECT userid, SUM(CASE WHEN type='微信' THEN income ELSE 0 END) AS income_wx, SUM(CASE WHEN type='支付宝' THEN income ELSE 0 END) AS income_aliFROM INCOME GROUP BY userid Java实现打印机打印账单敬请期待… 结束语","link":"/business/report-business-summary.html"},{"title":"MarkDown基本操作","text":"【摘要】考研结束后，估摸着考试情况，哈哈哈哈，所以开始着手准备找工作的事情。元宵一过，春招也算是要开始了。嗯，整天在这个快节奏的环境中瞎忙活。所以，想要通过写一些博客沉淀一下自己，记录日常。后面也能算上简历上的一行文章吧。 前言考研结束后，估摸着考试情况，开始着手准备找工作的事情。元宵一过，春招也算是要开始了。嗯，整天在这个快节奏的环境中瞎忙活。所以，想要通过写一些博客沉淀一下自己，记录日常。后面也能算上简历上的一行文章吧。 所以，如何使用markdown的基本语法成为了我的第一篇技术博客。 2.Markdown简介Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 3.常用部分3.1 标题代码 注：#和h1之间有空格 123456# h1## h2### h3#### h4##### h5###### h6 演示 3.2 分级标题代码 注：= - 最少可以只写一个，兼容性一般 1234一级标题======================二级标题---------------------- 演示 3.3 TOC代码注：根据标题生成目录，兼容性一般 1[TOC] 演示 3.4 引用代码1（单行式） 1&gt; hello world! 演示 代码2（多行式） 123&gt; hello world!hello world!hello world! 或者 123&gt; hello world!&gt; hello world!&gt; hello world! 演示 代码3（多层嵌套） 123&gt; hello world!&gt;&gt; hello world!&gt;&gt;&gt; hello world! 演示 3.5 行内标记注：用 ` 标记代码块将变成一行 1标记`hello world`部分内容 演示 3.6 代码块3.6.1 代码块标记(```)注：用`````生成块 123456```&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;``` 演示 3.6.2 块缩进表示法(Tab)注：Tab缩进 1234567我是文字…… &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 演示 3.6.3 语法高亮显示(自定义语法)注：根据不同的语言配置不同的代码着色 1234567```javascriptvar num = 0;for (var i = 0; i &lt; 5; i++) { num+=i;}console.log(num);``` 演示 3.6.4 内联代码块（`）3.7 插入链接3.7.1 内链式注：{:target=&quot;_blank&quot;}跳转方式兼容性一般 ，多数第三方平台不支持跳转 1[百度1](http://www.baidu.com/\" 百度一下\"){:target=\"_blank\"} 3.7.2 引用式3.7.2 引用式12[百度2][2]{:target=\"_blank\"}[2]: http://www.baidu.com/ \"百度二下\" 3.8 插入图片3.8.1 内链式1![name](./pic/演示0.png '演示0') 3.8.2 引用式12![name][01][01]: ./pic/演示.png '演示' 3.8.3 图片带有链接1234[![name](./pic/演示.png '演示')](http://www.baidu.com){:target=\"_blank\"} [![name](./pic/演示.png '演示')][5]{:target=\"_blank\"} [5]: http://www.baidu.com 3.9 视频插入注：Markdown 语法是不支持直接插入视频的。普遍的做法是 插入HTML的iframe 框架，通过网站自带的分享功能获取，如果没有可以尝试第二种方法第二是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面。 3.9.1 代码一注：多数第三方平台不支持插入&lt;iframe&gt;视频 1&lt;iframe src=\"//player.bilibili.com/player.html?aid=44148498&amp;cid=77310600&amp;page=1\" height=498 width=510 scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt; &lt;/iframe&gt; 演示 3.10 表格注： : 代表对齐方式 ,: 与 | 之间不要有空格，否则对齐会有些不兼容 3.10.1 代码1234| a | b | c ||:-------:|:------------- | ----------:|| 居中 | 左对齐 | 右对齐 ||=========|===============|============| 演示 a b c 居中 左对齐 右对齐 ========= =============== ============ 3.10.2 简约代码写法1234a | b | c :-:|:- |-: 居中 | 左对齐 | 右对齐 ============|=================|============= 3.10.3 特殊表格注：一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的。所以常规的做法是使用HTML标签，但是这样的编写效率极低。但是有了这款工具的话，所有问题都迎刃而解。 在线生成HTML代码 Tables Generator (国外的站) 4.其他部分4.1 序表4.1.1 无序注：+ - 可替代 * 123* one* two* three 演示 one two three 4.1.2 有序注：序列.后 保持空格 1231. one2. two3. three 演示 one two three 4.1.3 序表嵌套1234567* one * two * three1. one 2. two 3. three 演示 one two three one two three 4.2 清单12- [x] 选项一 - [ ] 选项二 演示 选项一 选项二 4.3 锚点网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。 注意： Markdown Extra 只支持在标题后插入锚点，其它地方无效。 代码注：只有标题支持锚点， 跳转目录方括号后 保持空格。在你准备跳转到的指定标题后插入锚点{ #标记 }，然后在文档的其它地方写上连接到锚点的链接。 123[公式标题锚点](#4.2)[需要跳转的目录] {#4.2清单} 演示 公式标题锚点 4.4 脚注12Markdown[^1][^1]: Markdown是一种纯文本标记语言 // 在文章最后面显示脚注 演示 Markdown[^1] 4.5 表情github表情 :point_up: 1https://www.webpagefx.com/tools/emoji-cheat-sheet/ 4.5 分隔符注：最少三个 --- 或 ***或 * * * 123***---* * * 演示 4.6 自动邮箱代码代码 1&lt;zhangyao9707@163.com&gt; 演示 zhangyao9707@163.com","link":"/blog/markdown-basic-operation.html"},{"title":"Java基础目录","text":"【摘要】想变强必须搞好Java基础！ 内容目录准备工作 JDK的安装与配置 安装集成开发环境Eclipse/IntelliJ IDEA Java基本语法 代码结构、软件包、导入语句、注释 数据类型(8种基本类型、对象类型)、变量、常量、字面量 运算符(赋值、算术、比较、逻辑、三目、位运算符)、表达式、分支语句、循环语句 方法(调用、重载、递归)、修饰符、返回类型、参数列表、异常列表 Java数组(数组分类、定义、初始化、操作) JVM深度解析 JVM内存结构 JVM堆分带介绍 JVM垃圾回收算法 JVM垃圾收集器回收策略详解 JVM性能检测工具及问题排查详解 JVM参数调优实战 面向对象 类和对象、this、static、fianl关键字 面向对象三大特征：封装、继承、多态、super关键字 抽象类和接口、转型、格式化输出 内部类 API的学习 Object类 三大常用类型(字符串String、日期类Date、数字类Number) 有关异常 集合框架[JCF] JCF之Collection JCF之Map JCF之Enum 泛型 IO流 反射和注解 多线程 网络编程 XML的处理 Java8新特性 Lambda表达式 方法引用 Stream流 … 设计模式pattern 面向对象设计原则 开闭原则 里氏替换原则 依赖倒置原则 单一职责原则 接口隔离原则 迪米特法则 合成复用原则 UML统一建模语言 创建型模式 单例模式(Singleton) 抽象工厂模式(AbstractFactory) 建造者模式(Builder) 工厂模式(Factory Method) 原型模式(Prototype) 结构型模式 适配器模式(Adapter) 桥接模式(Bridge) 装饰模式(Decorator) 组合模式(Composite) 外观模式(Facade) 享元模式(Flyweight) 代理模式(Proxy) 行为型模式 模版方法模式(TemplateMethod) 命令模式(Command) 迭代器模式(Iterator) 观察者模式(Observer) 中介者模式(Mediator) 备忘录模式(Memento) 解释器模式(Interpreter) 状态模式(State) 策略模式(Strategy) 职责链模式(责任链模式)(Chain of Responsibility) 访问者模式(Visitor) 赞助如果您认为此页对您有帮助，请扫描下方二维码请我喝一杯咖啡哦~ 微信赞助 支付宝赞助 Q：你感觉女生喜欢什么样的男生？ A：肯定喜欢长的帅、的有钱的。其实我也羡慕这样的男生~ Q：为什么呢？ A：因为，，，他们拥有过很多女孩的青春， 而我，，，拼了命的努力，才能拥有一个他们拥有过的女孩。","link":"/catalog/a-javase-catalog.html"},{"title":"数据结构介绍","text":"【摘要】八大数据结构介绍~ 定义数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。 常用的数据结构数组(Array) 栈(Stack) 队列(Queue) 链表(Linked List) 树(Tree) 图(Graph) 堆(Heap) 散列表(Hash)","link":"/data-structure/data-structure-introduce.html"},{"title":"排序算法","text":"【摘要】十大经典排序算法~ 前言排序分类冒泡排序(bubble sort)选择排序(selection sort)插入排序(insertion sort)希尔排序(shell sort)归并排序(merge sort)快速排序(quick sort)堆排序(heap sort)计数排序(counting sort)桶排序(bucket sort)基数排序(radix sort) 参考文档结束语bye~","link":"/data-structure/sorting-algorithm.html"},{"title":"单例模式Singleton","text":"【摘要】单例模式Singleton就是某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 前言当在搜索引擎输入”单例模式”这四个字，我们一定可以看到五花八门关于单例模式的分类，最常见的莫过于饿汉式和懒汉式，还有什么5种的，6种，7种的。要是觉得这很重要的话，不妨考虑一下”茴香豆”的”茴”下面的”回”到底有几种写法。再说个题外话，记得高中时期班上有位同学天天吹嘘自己可以用N英文表示中文中”牛”字的表达方式。哈哈哈，有点扯远了。学习设计模式的过程中不断的深入理解面向对象的思想，灵活地运用到解决实际问题的场景下，这才是我们所需要的。 单例模式(Singleton Pattern)单例模式属于创建型模式，它提供了一种创建对象的最佳方式。 1.单例类只能有一个实例。2.必须保证自己创建自己的唯一实例。3.并且给其他对象提供访问这一实例的方式。 应用场景 1.要求生产唯一序列号。2.WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3.创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 分类单例模式常见的有饿汉式、懒汉式、双检锁/双重校验锁、静态内部类、枚举。 饿汉式这种方式类加载到内存后，就实例化一个单例，JVM会保证线程安全。简单实用，相当推荐使用。但是，他的唯一缺点就是：不管是否用到，类加载时就会完成实例化。 1234567891011121314151617181920212223/** * 饿汉式 */public class Singleton01 { private static final Singleton01 INSTANCE = new Singleton01(); private Singleton01() { } public static Singleton01 getInstance() { return INSTANCE; } public void m() { System.out.println(\"m\"); } public static void main(String[] args) { Singleton01 s1 = Singleton01.getInstance(); Singleton01 s2 = Singleton01.getInstance(); System.out.println(s1 == s2); }} 对于饿汉式的单例模式，还有一种是在静态代码块中进行new一个单例。和上面的本质没有区别，看看就好。 12345678public class Singleton02 { private static final Singleton02 INSTANCE; static { INSTANCE = new Singleton02(); } //...} 懒汉式（线程不安全）相比饿汉式，懒汉式的单例模式达到了按需初始化的目的，但是带来了线程不安全的问题。 12345678910111213141516171819202122232425262728293031323334/** * lazy loading 也称懒汉式 * 虽然达到了按需初始化的目的，但却带来线程不安全的问题 */public class Singleton03 { private static Singleton03 INSTANCE; private Singleton03() { } public static Singleton03 getInstance() { if (INSTANCE == null) {// try {// Thread.sleep(1);// } catch (InterruptedException e) {// e.printStackTrace();// } INSTANCE = new Singleton03(); } return INSTANCE; } public void m() { System.out.println(\"m\"); } public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { new Thread(() -&gt; { System.out.println(Singleton03.getInstance().hashCode()); }).start(); } }} 上面这种方式线程不安全，在判断INSTANCE == null的后面我们把线程阻塞1ms，运行后通过比较hashCode就会发现不同线程访问到的实例并不全是同一个对象实例。 12345678910111213141516171819202142205731350367436816505947511634218452116099971113416209071522804050727866141430746659966186071113304646315128643421151472681326204679422057313796465865796465865733365800796465865796465865... 懒汉式（线程安全）为了保证懒汉式单例模式线程安全，考虑到对getInstance()方法的改造。通过synchronized来实现线程安全。 12345678910111213141516171819202122232425262728293031323334/** * 可以通过synchronized解决，但却带来了效率下降 */public class Singleton04 { private static Singleton04 INSTANCE; private Singleton04() { } public static synchronized Singleton04 getInstance() { if (INSTANCE == null) {// try {// Thread.sleep(1);// } catch (InterruptedException e) {// e.printStackTrace();// } INSTANCE = new Singleton04(); } return INSTANCE; } public void m() { System.out.println(\"m\"); } public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { new Thread(() -&gt; { System.out.println(Singleton04.getInstance().hashCode()); }).start(); } }} 运行测试之后，发现这种方式可以保证线程安全。但是在内存当中的对象一定比我们上面这个简单的Singleton04对象大的多，还有就是在每一次使用的时候都需要去获取这把锁才可以获取实例。这样一来，效率就会降低。所以就有人想通过减少同步代码块的方式来提高效率，所有就产生了下面这种。 12345678910111213141516171819202122232425262728293031323334353637/** * 通过synchronized解决，但却带来了效率下降。所以就想通过减少同步代码块的方式来提高效率，但是不可行。 */public class Singleton05 { private static Singleton05 INSTANCE; private Singleton05() { } public static Singleton05 getInstance() { if (INSTANCE == null) { //试图通过减少同步代码块的方式来提高效率，不可行 synchronized (Singleton05.class) {// try {// Thread.sleep(1);// } catch (InterruptedException e) {// e.printStackTrace();// } INSTANCE = new Singleton05(); } } return INSTANCE; } public void m() { System.out.println(\"m\"); } public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { new Thread(() -&gt; { System.out.println(Singleton05.getInstance().hashCode()); }).start(); } }} 上面这种并不能保证线程安全。所以就出现了双检锁。 双检锁/双重校验锁双检锁/双重校验锁（DCL，即 double-checked locking）这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 123456789101112131415161718192021222324252627282930313233343536373839/** * 双检锁/双重校验锁 */public class Singleton06 { private static volatile Singleton06 INSTANCE;//JIT private Singleton06() { } public static Singleton06 getInstance() { if (INSTANCE == null) { //双重检查 synchronized (Singleton06.class) { if (INSTANCE == null) {// try{// Thread.sleep(1);// } catch (InterruptedException e) {// e.printStackTrace();// } INSTANCE = new Singleton06(); } } } return INSTANCE; } public void m() { System.out.println(\"m\"); } public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { new Thread(() -&gt; { System.out.println(Singleton06.getInstance().hashCode()); }).start(); } }} 静态内部类方式只有第一次调用getInstance()方法时，虚拟机才加载Singleton07Holder内部类 并初始化INSTANCE，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。 1234567891011121314151617181920212223242526272829/** * 静态内部类方式 * JVM保证单例，加载外部类时不会加载内部类，这样可以实现懒加载 */public class Singleton07 { private Singleton07() { } private static class Singleton07Holder { private final static Singleton07 INSTANCE = new Singleton07(); } public static Singleton07 getInstance() { return Singleton07Holder.INSTANCE; } public void m() { System.out.println(\"m\"); } public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { new Thread(() -&gt; { System.out.println(Singleton07.getInstance().hashCode()); }).start(); } }} 枚举单例模式1234567891011121314151617/** * 不仅可以解决线程同步，还可以防止反序列化。 */public enum Singleton08 { INSTANCE; public void m() { } public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { new Thread(() -&gt; { System.out.println(Singleton08.INSTANCE.hashCode()); }).start(); } }} 结束语文末就不聊单例了。“茴香豆”的”茴”下面的”回”的几种写法:回、囘、囬、廻;“牛”字的英文表达方式:ox;(菜牛)beef cattle;(纯种公牛)pedigree bull;(公牛)bull;(母牛)cow;(奶牛)milk cow,dairy cattle;(水牛)water buffalo;(小牛)calf.","link":"/design-pattern/singleton.html"},{"title":"DLMS电能表通讯协仪","text":"【摘要】回顾一下自己将近一年的工作，明显感觉到对DLMS协议缺乏整体性的认识。顾写此文记录和整理IEC62056协议族/DLMS/COSEM协议，以便于加强自己的理解和记忆。 内容目录参考文章 – DLMS电能表通讯协仪参考PPT – IEC62056-DLMS-COSEM培训DLMS/COSEM简介DLMS电能表通讯协议心得与个人理解 结束语未完待续~","link":"/dlms/dlms.html"},{"title":"状态模式State","text":"【摘要】状态模式State，即允许一个对象在其内部状态改变时改变它的行为。简单来说就是根据状态决定行为。 前言工作一年多来，公司项目中一直有一个烫手的系统功能部分，那就是关于电表设备的密钥变更。其实主要难在它复杂的变更流程以及设备回复的未知，复杂的流程主要就是产品经理画的流程图以及触发条件的参数构造和本次执行变更的众多数据，光流程图就打印了我十好几张A3纸。设备回复的未知体现在真实设备的匮乏，很难凑齐一套完整的组网集中器和下挂表去真实模拟。总之这项功能完成起来很不容易。为什么在这里提到这件事情，主要是因为这部分功能的实现就是基于状态模式。欲知后续，且慢慢看来。 状态模式(State Pattern)状态模式State，即允许一个对象在其内部状态改变时改变它的行为。简单来说就是根据状态决定行为。 应用场景你女朋友的哭笑叨唠举例一个简单的场景，说是我们需要描述你女朋友在不同心情下不同的行为，假设说你女朋友在开心的时候会笑，在难过的时候会哭等等。根据这个场景的描述，我们很容易就可以写出下面的代码。 12345678910111213141516171819package com.aiz.dp.state.v1;public class MM { String name; private enum MMState{HAPPY,SAD} MMState state; public void smile(){ //switch case } public void cry(){ //switch case } public void say(){ //switch case }} 这个时候我们想要增加你女朋友在紧张的时候怎么说话，那么我们需要怎么修改代码？考虑过后，我们需要添加一个方法，同时需要在每个方法都增加case代码。 但是，要是使用状态模式，我们就会写出下面这样的代码。首选还是先给你创建一个女朋友。 12345678910111213141516171819package com.aiz.dp.state.v2;public class MM { String name; MMState state; public void smile(){ state.smile(); } public void cry(){ state.cry(); } public void say(){ state.say(); }} 创建一个状态类。 1234567package com.aiz.dp.state.v2;public abstract class MMState { abstract void smile(); abstract void cry(); abstract void say();} 创建不同的状态实现类，分别在不同状态实现不同的动作。 12345678910111213141516171819package com.aiz.dp.state.v2;public class MMHappyState extends MMState{ @Override void smile() { System.out.println(\"happy smile\"); } @Override void cry() { } @Override void say() { }} 12345678910111213141516171819package com.aiz.dp.state.v2;public class MMSadState extends MMState{ @Override void smile() { } @Override void cry() { System.out.println(\"sad cry\"); } @Override void say() { }} 123456789101112131415161718package com.aiz.dp.state.v2;public class MMNervousState extends MMState{ @Override void smile() { } @Override void cry() { } @Override void say() { System.out.println(\"nervous\"); }} 根据上面的例子，我们可以很容易理解状态模式。类图大概如下。 我的理解是这样的如果你女朋友只是smile,cry,say这三个动作，同时它的心情是多边变的，就很适合使用状态模式来描述你女朋友的行为。不过状态模式用与不用还是根据实际情况决定。 TCPConnection案例不过在下面这本书籍中，里面有关于状态模式很经典的例子：TCP的Connection。 让人头疼的密钥变更公司秘密，不能外漏；等我跑路，定会带走。 有限状态机(FSM)有限状态机Finite state machine Java线程状态迁移图 结束语Car的State与Action State/Action open the door close the door run the car stop the car Open no yes no no Closed yes Running Stopped","link":"/design-pattern/state.html"},{"title":"Git基本操作","text":"【摘要】程序员必备Git基本操作，add、commit、push、checkout、pull… 前言master:默认开发分支；origin:默认远程版本库。 Git常见命令这一部分我是在这个下面那个链接里面抄的，人家总结的好我就要抄哈哈哈哈。 Git常规操作 初始化操作12345git config --global user.name &lt;name&gt; #设置提交者名字 git config --global user.email &lt;email&gt; #设置提交者邮箱 git config --global core.editor &lt;editor&gt; #设置默认文本编辑器 git config --global merge.tool &lt;tool&gt; #设置解决合并冲突时差异分析工具 git config --list #检查已有的配置信息 创建新版本库12git clone &lt;url&gt; #克隆远程版本库 git init #初始化本地版本库 修改和提交12345git add . #添加所有改动过的文件 git add &lt;file&gt; #添加指定的文件 git mv &lt;old&gt; &lt;new&gt; #文件重命名 git rm &lt;file&gt; #删除文件 git rm --cached &lt;file&gt; #停止跟踪文件但不删除 提交文件1234git commit -m &lt;file&gt; #提交指定文件 git commit -m “commit message” #提交所有更新过的文件 git commit -amend #修改最后一次提交 git commit -C HEAD -a -amend #增补提交（不会产生新的提交历史纪录） 查看提交历史12345678git log #查看提交历史 git log -p &lt;file&gt; #查看指定文件的提交历史 git blame &lt;file&gt; #以列表方式查看指定文件的提交历史 git log &lt;branch&gt; #查看某分支历史纪录 git log --all #查看所有分支历史纪录 git branch -v #每个分支最后的提交 git status #查看当前状态 git diff #查看变更内容 撤销操作1234git reset -hard HEAD #撤消工作目录中所有未提交文件的修改内容 git checkout HEAD &lt;file1&gt; &lt;file2&gt; #撤消指定的未提交文件的修改内容 git checkout HEAD. #撤消所有文件 git revert &lt;commit&gt; #撤消指定的提交 分支和标签123456789git branch -a #显示所有本地分支 git checkout &lt;branch/tagname&gt; #切换到指定分支或标签 git branch &lt;new-branch&gt; #创建新分支 git branch -d &lt;branch&gt; #删除本地分支 git tag -a #列出所有本地标签 git tag &lt;tagname&gt; #基于最新提交创建标签 git tag -d &lt;tagname&gt; #删除标签 git push origin --delete &lt;branchName&gt; #删除一个远程分支 git branch -D branchName #删除本地分支 合并与衍合12git merge &lt;branch&gt; #合并指定分支到当前分支 git rebase &lt;branch&gt; #衍合指定分支到当前分支 远程操作12345678git remote -v #查看远程版本库信息 git remote show &lt;remote&gt; #查看指定远程版本库信息 git remote add &lt;remote&gt; &lt;url&gt; #添加远程版本库 git fetch &lt;remote&gt; #从远程库获取代码 git pull &lt;remote&gt; &lt;branch&gt; #下载代码及快速合并 git push &lt;remote&gt; &lt;branch&gt; #上传代码及快速合并 git push &lt;remote&gt; : &lt;branch&gt;/&lt;tagname&gt; #删除远程分支或标签 git push --tags #上传所有标签 Git实战上面那一堆命令都是我网上抄的学院派，对于稍微有点Git基础的同学来说，上面那些就差不多了，但是我还是想多BB点东西。 安装Git1此处省略 进入文件目录1cd path #path代表需要管理代码的第一级目录 初始化1git init git配置123git config --global user.name \"aizhangyao\" git config --global user.email \"aizhangyao@hotmail.com\"#如果不设置个人信息，提交的信息将不会有更改者信息，这样会加大项目管理的难度。 ssh key配置123ssh-keygen #生成ssh keycd ~/.ssh #查看ssh key(将公钥配置到仓库中 操作不用输密码)cat id_rsa.pub 创建新版本库(将项目拉取到本地) 1git clone https://github.com/aizhangyao/aizhangyao.github.io.git 查看分支1git branch 切换并新建分支1git checkout -b feat-aizhangyao-init-project #分支命名规则feat-姓名-功能 将修改提交到暂存区1git add -A 查看暂存区修改的文件1git status 撤回修改的文件1git reset HEAD 文件名 将暂存区的代码提交到本地仓库1git commit -m \"feat(blogf): init project\" #并附上注释,注明本次提交内容(注释规则feat(blogf): 功能) 将本地仓库的代码推送到远程服务器端1git push origin feat-aizhangyao-init-project/master(远程分支名) Git进阶冲突处理注：这部分是之前一个朋友写给我用来学习的，说实话公司现在使用的是SVN，我暂时没有处理过Git冲突，等需要使用的时候再去细啃下面的，就先无脑贴过来了。 master分支有更新(别人写的代码被合进去了,你可以更新一下你本地代码,这也是你每次发merge request必须做得一步) 1.更新远程代码到本地仓库(在自己分支上执行)–本地分支代码是最新的了 1git fetch 2.将master分支的更新应用到自己分支上 1git rebase origin/master 3.有可能有冲突(两个人修改了同一文件即会产生冲突),有冲突解决冲突(保留你的修改/保留他的修改/保留双方修改) 4.解决完冲突,保存修改 1git add . 5.将master分支的更新应用到自己分支上过程中如果被冲突打断,继续rebase 1git rebase --continue 6.将本地仓库的代码推送到远程服务器端 1git push origin feat-aizhangyao-init-project -f (-f 参数强制提交， 必须) 现在你的远程分支上分支代码也是最新的了,现在想将自己的代码合进master分支,需要将你在完成此分支上的多个commit合成一个commit,再发merge request 1.查看分支的所有操作记录 1git reflog 2.将多个commit合并一个commit 1git rebase -i HEAD~2 (commit次数) 3.推送到远端 1git push orign 你的分之名 -f (-f 参数强制提交， 必须) 若是感觉操作失误,可以将代码回退到某一版本 1git reset --hard 65a5e7d(commitId 可以通过git reflog看到) 删除本地分支 1git branch -D 本地分支名 删除远程分支 1git push origin --delete 远程分支名 本地分支重命名 1git branch -m 源分支名 目标分支名 结束语我就是个菜比，文章里面有错的很正常，您要是发现请指出。参考文献： 廖雪峰Git教程 Git-Cheat-Sheet","link":"/git/git-basic-operation.html"},{"title":"抽象类和接口、转型、格式化输出","text":"【摘要】抽象类和接口、向上自动转型、向下强制转型~ 前言hi~ 抽象类[abstract class]抽象类是一种抽象数据类型，它的特点如下： A.不能被实例化。B.天生就是要被继承的。C.可以有构造方法、也可以有非抽象方法，也可以没有抽象方法。 所以，抽象类的定义除了多出一个abstract关键字外，与普通类一样。如： 123456public abstract class Animals { //属性 .... //方法 public void spark(){System.out.println(\"$%^&amp;##$%#$%\");}} 抽象方法就是没有方法体的方法，它直接以;号结束，没有大括号。它的意思是，对于这个方法的拥有类来说，“它”实现不了，故而做成抽象的。 A.拥有抽象方法的类必须是抽象类。B.但是，抽象类不一定有抽象方法。 如： 123public abstract void spark();public void spark(){....} 一个子类继承了一个抽象父类后，则必须实现抽象父类的所以抽象方法。除非这个类也是抽象方法。如：编写一个抽象父类Shape,他拥有计算面积和周长的抽象方法。 12345678910public abstract class Shape { //属性 private String name;// //抽象方法 public abstract double area(); public abstract double girth();}//然后定义子类 Triangle 接口[interface]接口它也是一种抽象数据类型，而且是完全抽象的。它的特点： A.所有属性都是公开静态常量B.所有方法都是公开抽象方法C.没有构造D.接口支持多重继承 如： 12345public interface 接口名 [extends 父接口1，父接口2…]{ //属性：公开静态常量 public static final //方法：公开抽象方法 public abstract xxx xxx();} 注：接口编译完成后，也是.class文件。 一个类实现了某个/某些接口，则这个类要实现这些接口的所有抽象方法，除非这个类也是抽象的。 接口的命名： 1.以 I 打头。2.以 able 结尾。 如： 12345678910111213141516171819202122232425262728293031323334public interface IA{ void ma();//相当于public abstract void ma();}public interface IB{ void mb();}public interface IC extends IA,IB{ void mc();}public interface ID{ int INDEX = 100;//public static final int INDEX = 100; void md(); void me();}//public class IC_Impl implements IC { // public void mc(){} //还要实现IC接口的父接口的方法 public void ma(){}; public void mb(){};}//public void ID_Impl implements ID,IB{ // public void md(){} public void me(){} // public void mb(){}} 特殊的两类接口 1.标记接口 既没有方法也没有属性的接口。如: 123public interface IHaha{ //nothing } 一个类实现这种接口是没有任何“负担”的。如：java.io.Serializable 2.常量接口 就是只有属性而没有方法的接口。如： 123456public interface Season{ int SPRING = 1; int SUMMER = 2; int AUTUMU = 3; int WINTER = 4;} 但是，这类接口从JDK5.0后就很少用了。因为有了枚举。如： 123public enum Season{ SPRING,SUMMER,AUTUMU,WINTER;} 转型Java是面向对象的语言，但是我们经常使用的基本数据类型却不是对象。所以实际使用中需要进行类型转换。 基本数据类型和对应的包装类型。 基本数据类型 包装类型 byte Byte boolean Boolean short Short char Character int Integer long Long float Float double Double 12345Integer a = 123; //自动装箱Integer a = Integer.valueOf(123);int b = a; //自动拆箱int b = a.intValue();Integer a = null;int d = c; //会报空指针 格式化输出在java中，也提供了printf方法做格式化输出。比如： 12345678int j = 9;int j=12;//想要输出i和j的值：System.out.println(\"i = \"+i+\",j = \"+j);//使用格式化输出System.out.printf(\"i = %d j = %d\",i,j); 则：占位符该如何定义呢？ 语法： %[index$][flag][width][.presision]conversion conversion指的是占位符的转换字母，它有：d 代表整数f 代表浮点数s 代表字符或者字符串b 代表布尔值t 代表时间和日期的前半部分….flag 标记width 占位符宽度.precisoin 只对浮点数有效，表示小数位index$ 表示占位符与变量之间的对应关系，默认是一一对应的。 结束语bye~","link":"/javase/abstract-interface-casting-printf.html"},{"title":"代码结构-软件包-导入语句-注释","text":"【摘要】写了好多代码，用过很多框架后，还记得一个.java文件的构成吗？本文用来快速回顾一个.java文件的组成部分。 前言对编程了解越多，才懂得编程是个汪洋大海，自己所知道的那点东西只不过是一滴水。只想通过回顾基础，更加深入的理解Java这门语言、编程这件事。 代码结构 基本代码结构1234567public class 类名{ public static void main(String[] args) { //代码块 }} 软件包[package] 语法： 12345package 包名;//包名就是由字母、数字、_，不以数字开头的字符字符序列。//多级包名之间使用.隔开，如：package java.lang;package a.b.c.d.e.f.g;//ok 命名规则： 12A)、一般以公司域名为前半部分，如：`com.ali.xx.xx.xx;` `com.aiz.xx.xx;`B)、以项目名和功能划分为后半部分，如：`com.ali.crm.servive;` `com.aiz.se.day01;` 包的作用； 包名在编译完成后生产的字节码中，会有对应的目录结构。 所以，它可以很好地管理源文件和字节码。 她还扩展了类的命名空间。 如：有一个类都叫:Date 那我们可以把它存放在不同的包中，如: java.util.Date; java.sql.Date; 这两个类的名字[简名]虽然不一样，但是处在不同的包中，是可行的。 他们的全限定名是不一样的，因为全限定名是 包名.类名 导入语句[import] 语法：1import 包名.类名|*; 支持通配，只能通配类名，不能通配包名。 可以写多次。 何时需要使用导入语句？ 当一个类中需要使用非本包中的其他类时，则需要使用导入语句。 除非目标类是在java.lang下 注释[commets] 是为了增加代码的可读性、理解性的一种手段，JVM的编译器是会忽略他的。 Java语言支持三种注释： 12345678910A、单行注释，以//开头B、多行注释，以/*开头，以*/结尾C、文档多行注释，以/**开头，以**/结尾 如： /** *XXXX *XXXX *XXXX */这种注释，将来可以通过javadoc命令来提取 Eclipse设置注释模板：Window-&gt;Preferences-&gt;Code Templates-&gt;Comments。选择Files设置文件注释模板。可自定义。 123/****/ 选择Types设置作者、版本等信息。 1234567/***@author &amp;{user}*@version 1.0*@CreateDate ${date} ${time}**${tags} 本类${file_name}的描述：*/ Window-&gt;Preferences-&gt;Code Templates-&gt;Code设置代码模板。 IDEA设置注释模板： 类头注释打开File-&gt;setting-&gt;Editor-&gt;File and Code Templates-&gt;Includes-&gt;File Header。 1234567/** * @ClassName ${NAME} * @Description TODO * @Author ${USER} * @Date Create in ${TIME} ${DATE} * @Version 1.0 */ 方法注释File-&gt;setting-&gt;Editor-&gt;LiveTemplates 点击右边上面那个的+号，选择Template Group双击，然后弹出一个窗口，随便添加一个名字，我这里添加的是ZYGroup然后点击OK。(缺少截图，我知道) 1234567/** * @Author $USER$ * @Description $DESCRIPTION$ * @Date Create in $TIME$ $DATE$ * @Param $PARAM$ * @Return $RETURN$ */ 找到关于设置注释模板笔记好的文章,等我有空就把他的文章抄过来。 结束语","link":"/javase/code-package-import-comment.html"},{"title":"数据类型-变量-常量-字面量","text":"【摘要】Java语言是静态类型的，也就是说所有变量和表达式的类型在编译时就已经完全确定。 前言记得之前学这一块的时候，老师告诉我们“数据类型”不只是“数据类型”而是“数据”和“类型”，叫我们好好体会~直到今天我还在假装明白~ 数据类型废话不多说，在Java中数据类型分为两大类：基本类型和对象类型。 基本类型(8种) 类型 占用字节 取值范围 byte 1个字节 [-128,+127] short 2个字节 [-32,768，+32,767] int 4个字节 [-2,147,483,648，+2,147,483,647] [-2^31,+2^31-1] long 8个字节 [-2^63,+2^63-1] 10^19 char 2个字节 一种特殊的整数，范围同short double 8个字节 10^308 float 4个字节 10^38 boolean 1个字节 只有2个值，true和false 在Java中，最高位代表符号位，1位负，0为正。以8位二进制为例，所以： 二进制 十进制 0 000 0000 0 0 111 1111 +127 1 000 0000 -128 1 111 1111 -1 对象类型所有不是基本类型的都是对象类型，如：String、System…所以，我们编写程序，也就是不断地创建类型。因为我们想表达我们要表达的数据。 变量变量，variable，是一种可以变化的量。语法： 123456789101112131415161718192021数据类型 变量名 [= 初始值]; []代表可以省略变量名，由字母、数字、_组成，并且不能以数字开头。如：i,a,ai,haha,a5...注：给变量命名时尽肯能地有意义[见名知意]如：定义一个变量来存储年龄int age;//变量没有初始化age = 10;//给变量赋值以上两行语句也可以合在一起：int age = 10;//定义一个长整型变量，并初始化为100.long a = 100L; //长整型字面量以L或l结尾//定义一个浮点数变量double height = 176.5;//单精度浮点float weight = 68.5F;//以F或f结尾 常量常量[literal]，是不变的变量。语法： 12345678910final 数据类型 常量名 = 初始值;如：int i = 100;i = 90;//okfinal int J = 200;//常量J = 230；//error注：常量名一般采用大写字母。如：final String MSG = \"hahaha\"; 字面量字面量[constant]，“双引号括起来的”，就是字面本身的量。 1234只有8种基本类型以及字符串String才有字面量。如：1,4,5,100L，true,false,'a',\"abc\";作用：用来给变量或者常量赋值。 相关知识了解计算机存储数据的方式123计算机存储数据的方式采用二进制【由0和1组成】规定每8位为一个字节。这样，1个字节所能表达的状态有：2^8=256 种 有关字符的表达方式在Java中，字符使用单引号括起来，它有如下三种表达方式：A.普通表达方式，每对单引号中只能有唯一的字符 1char c1 = 't'; B.特殊字符表达式[使用转义符转义过的] 12345678char c3 = '\\t';//制表符这类特殊字符有：'\\r' 回车'\\n' 换行'\\'' 单引号'\\\\' 反斜杠'\\\"' 双引号... C.采用UNICODE字符表示法 1234567语法：'\\u 4位16进制表示法'如：char c1 = '我';改成unicode表示法：char c1 = '\\u6211';通过jdk提供的 native2ascii.exe命令可以把任意的中文转换成unicode字符码ctrl + C 退出 字符是一种特殊的整数。Java采用双字节编码，就意味着它可以表达 2 ^ 16 = 65536 个字符 在计算机中，要存储字符，都需要把字符转换成整数，进而成为二进制。这就需要字符映射表，也就是码表【字符集表】。计算机中最原始的字符集是ASCII码表，不同的码表对字符的码表是不一样的，其中，ASCII码表采用单字节编码，也就是它最多可编256个字符。 字符 码值 ‘a’ 97 ‘z’ 122 ‘A’ 65 ‘Z’ 90 ‘0’ 48 ‘9’ 57 中文字符集采用双字节编码，但是，为了向上兼容ASCII码值，前256的值与ASCII码一模一样，这样就兼容了ASCII码表。【所有主流的字符集都会无条件向上兼容ASCII码表】中文字符集： GB2312-&gt;GBK全球统一的字符集： UTF-8 [支持中文]，它采用动态编码技术。 所以，当文本文件的编解码不一致时，就会产生乱码。 类型转换问题 隐式类型转换当小范围变量、字面量赋值给大范围变量时发生。如： 1234byte b1 = 12;int i = b1;//okchar c = 'a';i = c;//ok，结果是 97 显示类型转换【强制类型转换】当大范围变量、字面量赋值给小范围变量时发生。语法：(新类型）变量或者表达式或者字面量 123int i = 97;char c = i;//error,有可能丢失精度char c = (char)i;//ok,做了强制类型转换 结束语 尽量不要用记事本去存储UTF-8格式的文件。谢谢您的阅读！","link":"/javase/datatype-variable-constant-literal.html"},{"title":"Java泛型","text":"【摘要】Java泛型~ 前言在JDK5.0之前，没有泛型，那时的集合类本质上是以Object为泛型，因为这样可以存放任意对象。如： 123456List a = new ArrayList();a.add(123); //oka.add(\"jack\"); //oka.add(new Book(...)); //ok//迭代a集合//... 可见，在没有泛型的年代，集合在使用时，程序员要“主动”遵守约定，就是一个集合只存放一种类型。现在,JDK5.0开始，引入了泛型，它的目的就是让这些“容器”类能够事先约定好它将要存放什么类型的数据。并且JVM负责检查。如： 123List&lt;String&gt; b = new ArrayList&lt;&gt;(); //jdk7.0后，后面的泛型类型可以省略b.add(123); //compile error, 因为集合b只能存放 String类型的对象b.add(\"jack\"); //ok 泛型 [Generic Type]所谓泛型，就是 类型参数化[type parameterize]。也就是把类型当参传一样的传递。它的语法： 1类型&lt;泛型字母&gt; 在JDK5.0中，整个JCF都全部采用泛型的语法重写过。如： 1234567891011121314151617//jdk1.5之前的集合类public class ArrayList { public boolean add(Object e) { ... } //...}//JDK5.0之后的集合类public class ArrayList&lt;E&gt; { //泛型类 public boolean add(E e) { /*...*/ } //... //...}//soList&lt;Book&gt; bList = new ArrayList&lt;&gt;();List&lt;Integer&gt; iList = new ArrayList&lt;&gt;();Map&lt;String,Book&gt; map = new HashMap&lt;&gt;();//...Set&lt;Entry&lt;Integer,Book&gt;&gt; set = ...; 思考？是不是所有类型都要定义成泛型类？当然不是，如： 123456public class Student { private Integer id; private String name; private int age; //...} 只有需要把类型当做参数传递的类型定义时才需要泛型。 如何使用泛型类？如何自定义泛型类？如： 123456789101112131415161718192021222324252627282930public class Entry { private Object key; private Object value; //构造 //... //get/set public Object getKey() { return this.key; } //... public void setValue(Object obj) { this.value = obj; } //...}//使用它Entry e1 = new Entry(123,\"Spring\");Entry e2 = new Entry(\"Jack\",18L);//如果改写成泛型类public class Entry&lt;K, V&gt; { private K key; private V value; //构造 //... //get/set public K getKey() { return this.key; } //... public void setValue(V obj) { this.value = obj; } //...}//使用它Entry&lt;Integer,String&gt; e1 = new Entry&lt;&gt;(123,\"Spring\");Entry&lt;String, Long&gt; e2 = new Entry&lt;&gt;(\"Jack\",18L); 泛型仅仅是编译期间的概念，在运行时是没有泛型的。泛型是不存在多态性的。 如： 1234Number n = new Integer(100); //okList b = new ArrayList(); //ok//List&lt;Number&gt; bn = new ArrayList&lt;Integer&gt;(); // compile error 注：泛型是不存在多态性的 所以，上面这条语句是错误的。 1List&lt;Number&gt; bn = new ArrayList&lt;&gt;(); //ok 再看： 1234List&lt;Number&gt; bn1 = new ArrayList&lt;&gt;(); //okList&lt;Integer&gt; bn2 = new ArrayList&lt;&gt;(); //ok//bn1 = bn2; 泛型的通配符 ? 可以通配任意类型? extends 类型 来限定通配[?所代表的类型比后面的类型要小或一样]? super 类型 来限定通配[?所代表的类型比后面的类型要大或一样] 如： 12345678List&lt;?&gt; a = new ArrayList&lt;Integer&gt;(); //ok, 泛型没有确定//所以，这个集合a不能存放任何有效数据，除 null 外a.add(null); //oka.dd(100); //errorList&lt;Long&gt; b = new ArrayList&lt;&gt;();//a = b; //ok 自定义泛型方法就是指所在的类本身不是泛型类，而这个类的方法要定义成泛型方法。语法： 123修饰符 &lt;T&gt; 返回类型 方法名(参数列表) throws 异常 { //方法体} 在 修饰符 和 返回类型之间，使用 定义好泛型字母，然后，在方法的参数或方法体中就可以使用这个泛型字母。 如： 123456public class Demo { public static &lt;T&gt; void ma(T o) { // //... }} 例：定义一个泛型方法，找到两个对象的中的最大值。 12345public class Demo { public static &lt;T extends Comparable&lt;T&gt;&gt; T max(T a, T b) { //... }} 结束语bye~","link":"/javase/generic-type.html"},{"title":"安装集成开发环境Eclipse&amp;IntelliJ IDEA","text":"【摘要】“工欲善其事，必先利其器”，一个好的开发工具会起到事半功倍的效果。而Eclipse和IntelliJ IDEA是目前主流的Java开发工具，我相信能够熟练的使用它们，手撕代码都不怕。 前言上一篇文章中，我们已经成功安装了JDK。如您已经安装请忽略，若未安装请您移驾JDK安装与配置。 之后就可以开开心心地在Eclipse和IntelliJ IDEA当中翻牌子了。先介绍一下这两位爱妃的背景，Eclipse由IBM公司开发，是一个开放的平台。出身豪门的她曾一度碾压Sun公司的NetBeans，得到众多程序员的专宠。而JetBrains公司旗下的IDEA公主凭更加年轻，更加漂亮的优势，得到了程序员最佳搭档的美名。但是有一点不好的是，她是收费的，虽然有免费版的社区版【Community Edition】，但是免费的毕竟功能有限，姿势太少。所以我会在文中介绍一下如何破解她，如何白嫖收费的IDEA。因此，我更加推荐IntelliJ IDEA，原因很简单，年轻？漂亮？体验好？懂吧？更何况现在越来越多的人都在使用IDEA，说句不好听的话，当你在Eclipse上面遇到问题，同学同事用的是IDEA，这时候你们不一样他都不想帮你。我这边也不长篇大论讲两者的差异，总归意思就是没有特殊情况建议翻牌IDEA。 Eclipse安装教程那么我为什么还要把Eclipse的安装教程增加进来，原因很简单，上学时候老师教这个，更加操蛋的是，工作之后我们公司还使用的是这个。哈哈哈哈。 下载Eclipse下载东西不建议去乱七八糟的网站，沾上流氓软件、搞一大堆病毒文件有你受的。来来来，我带你走正门，Eclipse官方下载网站来到官网首先观察主页，看到如下图所示页面，那个黄色的按钮可以下载到exe可执行文件，下载好一顿傻瓜式安装。不过这里不讲那个，按我标记红框位置点进去。进入之后发现有好多个版本的，这里选择Eclipse EE版本的。点击黄色按钮下载。这时你会进入捐赠页面，谷歌浏览器的话下载提示会在如图所在位置。这里说一下这是捐赠页面，你可以忽略。 等待一段时间后就可以了。 安装Eclipse打开刚刚你下载的文件目录并且解压它。解压成功之后，你会发现根本不需要安装。找个合适的位置存放，我这里放在的C盘Program Files目录，建议发送快捷方式到桌面哦。双击exe文件就可以直接打开。安装要求选择默认的工作空间WorkSpace，就可以进入系统了。出现下图所示页面就代表你成功运行Eclipse了。 配置Eclipse网上看到一篇别人的博客，写的Eclipse配置比较漂亮。哪天有空抄下来，哈哈哈哈。 Eclipse快捷键Alt+Shift+N 新建项目Alt+Shift+C 新建ClassAlt+Shift+P 新建Packagesyso-&gt;system.out.println()Alt+/ 跳出提示Ctr+S 保存Ctr+Shift+S 全部保存Alt+Shift+X,J 运行程序这几个是我经常使用的，等我哪天去网上找个全的，抄下来放为这边。哈哈哈哈。 IntelliJ IDEA安装教程下载IDEA还是一样，我带大家走正门:官方下载网站。进去之后就是下面这张图。 点击DOWNLOAD按钮，进入下面这个页面，选择您需要的版本，建议选择exe可以执行文件，因为安装时候你就可以无脑点到底。注意，左边蓝色的是收费版的，右边灰色的是社区版的。我们当然要下载收费版本的安装啊，因为我后面会带你破解她。 点击下载过后，现在的版本文件有点大，六七百M的样子，稍微等一会就可以下载成功。 安装破解IDEA打开文件下载目录，直接双击运行。当上面所以步骤都顺利进行的时候，下面就带你破解她。上面说了，因为我们这里使用的是收费版，所以需要填写License。第一种方式走正版途径，你有账号密码直接输入就好了。第二种方式使用注册码。打开http://idea.lanyus.com/ 这个免费给我们提供注册码的网站。后面需要修改hosts，流程有点繁琐，但是很使用。 https://www.cnblogs.com/dxllp/p/10573498.html 配置IDEA下次带你配置。 IDEA快捷键下次去抄别人的快捷键。 结束语还没结束，没有结束语哦。","link":"/javase/install-eclipse-and-intellij-idea.html"},{"title":"IO流","text":"【摘要】IO流~ 前言IO流相关概念IO能力是一门编程语言的标准能力，几乎所有的编程语言都有IO的能力，但是，java语言的IO能力还是很强的。 IO可以简单解释为 对文件的输入输出操作。 文件[File]，它是一个宽泛的概念，包含： 普通文件 块文件 网络文件 文件夹 设备文件 … 在OS中，比较重要一个概念是文件系统[FS], 比如：NTFS, FAT32, …在java中，通过 java.io.File 类型来表示OS的文件，每一个OS的文件都可以使用一个路径来表示，而这个路径可以使用String类型来表达，并且我们可以很容易地把这个字符串所表示的路径转换成 File的实例。 如： 1234String path = \"E:\\\\JAVA实训\\\\note\\\\javase\\\\day01.txt\"; //文件的路径String path2 = \"code\\\\javase\\\\hehe\"; //相对路径File f = new File(path); 路径[path] 绝对路径[absolute path]:以盘符开头的路径 相对路径[relative path]:不以盘符开头的路径每一个资源[文件]都有唯一的绝对路径。 File类 File类[没有能力操作文件的内容]。 核心方法： length() canRead() canWrite() getAbsolutePath() getPath() getName() isFile() isDirectory() createNewFile(); //创建文件 mkdir(); //创建目录 mkdirs(); //创建目录结构，含父目录 delete(); //删除文件、空目录 deleteOnExit(); 在JVM进程退出之前再删除 listFiles list … 注：利用File类的delete方法删除文件时，需要注意 A.被其它进程占用的文件 删除会失败。B.有内容的文件夹 删除会失败。 流 [stream]流的源头文件、网络、内存、扫描器,…. 流的目的地文件、网络、内存、终端,… 流的分类 根据数据的流向以JVM为界，流可以分为： 输入流：把外界的数据读入到JVM之中。 输出流：把JVM之中的数据写出到外界。 以功能来划分 字节流：以字节为单位的流。 字符流：以字符为单位的流。[专门用来处理 文本类的文件] 根据流数据的包装过程： 节点流：又称为低级流，特点是：数据源明确，真实负责读写数据的流。 处理流：又称为高级流，特点是：不能单独存在(没意义)，用来处理其他流，所有高级流都封装了某些特定功能的读写操作，目的是简化我们的读写操作具体的流。 综合以上前两种划分，共计可以分为： 字节流字节输入流123456789101112131415java.io.InputStream方法： read(); 每次读1个字节，以返回值返回 read(byte[] buf); 每次至多读取buf.length个字节，存放在buf中 read(byte[] buf, int off, int length); 后2个read方法的返回值是int,表示实际读到的字节数。 当这个返回值是-1时，表示读到文件尾[EOF] close(); //关闭流具体的子类： FileInputStream 文件输入流,以文件为源头 ObjectInputStream 对象输入流，以对象来源头 FilterInputStream 过滤流 DataInputStream 基本数据类型输入流，以基本类型为源头 BufferedInputStream 提供缓存能力的输入流 ... 字节输出流1234567891011121314java.io.OutputStream方法： write(int b); 每次写入1个字节 write(byte[] buf);每次写入buf.length个字节 write(byte[] buf, int off, int length); 从off位置处，每次写入length个字节 close(); 具体的子类： FileOutputStream 文件输出流，以文件为目的地 ObjectOutputStream 对象输出流，以对象为目的地 FilterOutputStream 过滤流 DataOutputStream ... BufferedOutputStream ... ... 使用IO流的基本步骤： 1.把路径字符串转换成 File实例2.有效性判断3.创建流 [new ….]4.循环读、写5.释放资源 作业： 写一个程序，完成文件的COPY 写一个程序，完成文件夹的COPY。 节点流：拥有真正的读写能力的流 1234FileInputStream/FileOutputStream *[针对文件操作的字节流] 以 File/String 为构造参数ByteArrayInputStream/ByteArrayOutputStream [针对内存中的字节数组的流] 以 byte[] 为构造参数 过滤流 [FilterInputStream/FilterOutputStream]本身没有读写能力，它必需架接在节点流的基础上，才能做读写操作，它可以在节点流的基础上添加新的功能，如： 1234567BufferInputStream/BufferedOutputStream [添加缓存功能] 以 InputStream/OutputStream 为构造参数DataInputStream/DataOutputStream [添加读写基本数据类型的功能] 以 InputStream/OutputStream 为构造参数ObjectInputStream/ObjectOutputStream [添加读写对象数据类型的功能] 以 InputStream/OutputStream 为构造参数 IO流中API 的这种设计叫 装饰模式，它把类型分成两种： A. 拥有核心基本能力的类B. 装饰能力的类 [必需以 拥有基本能力的类 为构造] 基于这种模式，我们可以构建成功能强大的流：1.构建一个带缓存功能的文件流 1BufferedInputStream in = new BufferedInputStream(new FileInputStream(file)); 2.构建一个带缓存并且读基本数据类型的流 123DataInputStream dis = new DataInputStream( new BufferedInputStream( new FileInputStream(file))); 3.构建一个带缓存并且读对象类型的流 1234ObjectInputStream dis = new ObjectInputStream( new BufferedInputStream( new FileInputStream(file))); 读写基本数据类型 12345678DataInputStream readInt readLong readDoubleDataOutputStream writeInt writeLong writeDouble 读写对象数据类型 – 对象序列化要想持久化一个对象，要求这个对象必需要实现 java.io.Serializable接口，而且这个对象的属性类型也必需要实现 Serializable。 如： 12345678910111213public class Student implements Serializable{ private int id; private String name; private Date birth; private Clazz clazz;}public class Clazz implements Serializable { private int id; private String name; ...} 之所以要把对象写入文件中，是为了保存此对象的状态[持久化它的数据]。 对于对象的集合 又该如何？ 直接持久化集合即可【要求集合中的元素必需实现 Serializable】 如： 1234567List&lt;Student&gt; stuList = ....;ObjectInputStream Object readObject();ObjectOutputStream void writeObject(Object o); 利用IO流的知识，完成如下业务我们之前开发过银行帐户类：Account,改写：要求它的no属性是自动生成的，起始值A1000，每创建一个帐户，no自动增1，如：A1001, A1002, A1003, … 12345//Codepublic Account(String name) { this.realName = name; this.no = \"A\"+产生唯一性整数值的方法,从1000开始} 并且也开发过它的业务类：AccountService 现在，在之前的基础上，提供一个业务接口：IAccountService然后，改写之前的AccountService类，使用实现IAccountService接口. 新要求：开发一个银行类 Bank, 要求此类是一个单例，它提供如下属性： 12345678910111213141516private static final String PATH = \"\"; // 存放帐户文件的路径private List&lt;Account&gt; accountList; //存放所有帐户//业务功能：开户, 新建一个帐户public String open(String realName) { //创建一个Account //获取这个帐户的编号 //把这个帐户保存到 集合中 //并且要把这个集合固化到文件 //成功，则返回这个帐户的编号 //失败，则返回null} 字符流以字符为处理的基本单位的流 字符输入流1234567891011121314java.io.Reader核心方法 int read(); //读取1个字符 int read(char[] buf); //至多读取 buf.length 个字符 int read(char[] buf, int off, int len); //读取 len 个字符 close(); //释放资源具体的子类：[节点流] \\- FileReader \\- CharArrayReader \\- BufferedReader *[读取整行 readLine] \\- InputStreamReader * [桥接器，把字节流转成字符流的桥梁] \\- FilterReader \\- PushbackReader 字符输出流12345678910111213java.io.Writer void write(int c); //写入1个字符 void write(char[] buf); //写入 buf.length 个字符 void write(char[] buf, int off, int len); //写入len个字符 close(); //释放资源具体的子类： [节点流] \\- FileWriter \\- CharArrayWriter \\- BufferedWriter \\- PrintWriter *[写入一整行, println(String line); ] \\- OutputStreamWriter 桥接器 \\- FilterWriter InputStreamReader 把字节流转换成字符流的桥梁，它的构造： public InputStreamReader(InputStream in); //默认字符集 public InputStreamReader(InputStream in, String charSet);//指定字符集 如：在d:\\\\temp\\\\hehe.txt 文本文件，则可以用如下方式来打开： 12345678910//1.String path = \"d:\\\\temp\\\\hehe.txt\";InputStream in = new FileInputStream(path); //使用字节流//但是，使用字节去操作字符不方便，所以，我们可以把它转换字符流BufferedReader br = new BufferedReader(new InputStreamReader(in)); //默认字符集//2. 直接使用字符流去打开BufferedReader br = new BufferedReader(new FileReader(path)); //不涉及到解码的问题 了解System.in =&gt; InputStream 它被JVM默认指定为 标准输入设备，也就是键盘 System.out =&gt; PrintStream [OutpuStream的子类] 它被JVM默认指定为 标准输出设备，也就是终端[console] JVM允许我们修改标准输出输出设备，也就是对流进行重定向。 System.setIn() 和 System.setOut() 利用System.in和桥接器，我们可以让用户从键盘输入任意字符。 如： 12345BufferedReader br = new BufferedReader( new InputStreamReader(System.in));//然后，就可以从键盘读到用户的输入String line = br.readLine(); //阻塞方法 随机存取流java.io.RandomAccessFile这个流既可以读也可以写。而且支持基本数据类型、对象类型的读和写。更关键的是，这个流支持文件指针的定位【指定从哪个位置开始读】 12345678910111213构造方法：RandomAccessFile(String path, String mode);RandomAccessFile(File file, String mode);mode是指打开文件的模式，支持： r 只读模式 rw 读写模式主要方法： long getFilePointer(); //获取当前的文件指针偏移量 void seek(long pos); //定位 long length(); // ... 思考：如何读取一个巨大的日志文件的最后一行？ 作业：请把 文件夹“文本文档”下的8个文本文件全部读取出来进行分析：要求：统计出空行的数量英文单词的数量中文词的数量 进阶：分析每一个英文单词出现的次数。 结束语作业现在不写~","link":"/javase/io-stream.html"},{"title":"Java数组","text":"【摘要】这是一份记录本人【Java Learning】的资料库，输出形式主要为Java相关的Demo演示，对于一些理解比较困难的地方会拎出来通过博客详细介绍。旨在帮助自己强化相关知识的理解和养成良好的学习习惯，同时也希望可以帮助到更多的人。 前言回顾一下自己刚刚开始认识数组的那会，还是感觉好神奇的，对着课本赞叹666。当然肯定是结合着实际场景才会体会到数组的美丽。这么聊吧，如果你想要存放全班同学的姓名，你怎么办？如果没有接触过数组，我们一定想这样做： 1234String name1 = \"小A\";String name2 = \"小B\";//...String nameN = \"小N\"; 但是，肯定不是这样啦！班级如果50人，这样搞你会炸掉的，哈哈哈哈。创造来源于需求，那么，下面就来走进数组的世界。 数组特点 具备相同的数据类型。 所有的数组元素共享同一个数组名字。 通过下标来访问元素，下标从0开始，到length-1结束。 数组定义定义：数组是具有相同数据类型的一组数据集合。语法：数据类型[] 数组名；如： 1int[] iarr ;//仅仅是定义/声明 一个整型数组。 数组初始化如何初始化一个数组？ 首先，我们要记住，数组是对象类型。所以，需要使用new运算符来初始化数组。最后，要明确指定数组的初始化长度。而且，长度一旦确定，是不可再变的。 如： 12345678int[] iarr = new int[100];String[] names = new String[100];//数组初始化后，它的每个元素都是默认值，其中：byte,short,int,long =&gt;0double,float =&gt; 0.0boolean =&gt; falsechar =&gt; '\\u0000'对象类型 =&gt; null 数组操作迭代数组如何迭代一个数组？1.普通for循环 12345//Code:int[] iarr = new int[10];for(int i = 0;i&lt;iarr.length;i++){ System.out.println(iarr[i]);} 2.增强for循环 123456789语法：for(数据类型 e: 数组名字){ //...}//Code:int[] iarr = new int[10];for(int e: iarr){ System.out.println(e);} 元素赋值如何给数组元素赋值？A.一个一个赋值 12345//CodeString[] name = new String[3];name[0] = \"jack\";name[1] = \"rose\";name[3] = \"john\"; B.在初始化时直接赋值。 12345678910//CodeString[] names = new String[]{ \"jack\",\"rose\",\"john\"};或：String[] names = {\"jack\",\"rose\",\"john\"};或：String[] names;names = {\"jack\",\"rose\",\"john\"};//errornames = new String[]{\"jack\",\"rose\",\"john\"};//ok C.利用循环给元素赋值。用来用在元素值是有“规律”的情况下。如： 1234int[] arr = new int[10];//想在此数组中存放1~10for(int i=1;i&lt;=10;i++){ arr[i]=i;} 数组操作说明数组是一种基本的数据结构[data structure]。有数据结构就会想到算法，它们相辅相成，最终目的为了数据存取的高效性。对数据的操作，本质上可以归为：增、删、查、改。 二维数组二维数组就是数组中的元素还是一维数组。 多维数组就是数组中的元素还是数组。 Java语言支持多维数组。 二维数组的定义：数据类型[][] 数组名 = new 数据类型[rows][cols];其中，在初始化二维数组时，rows必需要指定。而cols可以省略。 如果省略了cols，则表示只初始化了二维本身，而二维数组中的元素没有初始化。 如： 12int[][] arr = new int[3][]; //初始化了二维数组，但是它的元素[一维的]并没有初始化 所以，在初始化二维数时，如果指定了 cols，则这个二维数组我们说是规则的。如 12345678910111213141516int[][] arr = new int[n][m]; //如果不指定cols，则可以实现不规则的二维组。如：int[][] brr = new int[n][]; //只初始化了二维进一步去初始化它的每一个元素[一维]brr[0] = new int[1];brr[1] = new int[2];brr[2] = new int[3];...brr[n-1] = new int[n];int[][] crr = new int[][]{ {1,2}, {3,4},}; 练习题1.数组元素的copy。 A.利用java.lang.System类中的arraycopy方法。 System.arraycopy( Object src,//源数组 int scrPos,//起始位置 Object dest,//目标数组 int destpos,//目标数组的存放起始位置 int length,//COPY元素的个数 ) 要求：源数组和目标数组都是事先初始化的。 B.利用java.util.Arrays类中的copuOf方法。 2.请设计一个方法，根据用户指定的长度，来生产一个存放了指定长度的斐波那契数列值。(Fibonacci)如：长度为10的数列为下：1 1 2 3 5 8 13 21 34 55点击进入答案解析 3.猜数字游戏:由程序生成一个1~100以内的随机数，然后让用户猜，如果用户所猜的数比答案大，则提示：大了。如果用户所猜的数比答案小，则提示：小了。直到猜对为止，并输出用户猜的次数。点击进入答案解析 4.找出1000以内的完美数。完美数是指这个数刚好是它的所有约数之和。如：6=1+2+3；点击进入答案解析 5.假设有N个小孩围成一圈，这些小孩从1开始编号，直到报到N,现在假设从1号小孩开始报数，依次类推，每报到M的小孩出列，直到所有的小孩都已出列。请打印出出列小孩的序列。(数组存放小孩)点击进入答案解析 结束语哈啊哈哈，每天进步一点点哦！","link":"/javase/java-array.html"},{"title":"方法-修饰符-返回类型-参数列表-异常列表","text":"【摘要】方法、修饰符、返回类型、参数列表、异常列表 前言start! 方法[method name]定义方法[method]是类的成员之一，[因为在java中，方法不能单独定义，它必须在类之中]。 123修饰符 返回类型 方法名()[throws 异常类型]{ //方法体} 方法名字：只要是一个合法的名字就可以，尽可能有意义。如：getName,nextInt… 调用当被调用的方法使用static修饰符修饰时: 通过类名来调用，也就是：ClassName.methodName();如：12double d = Math.sqrt(4.5);String istr = Integer.toBinaryString(8); 当被调用的方法没有使用static修饰符修饰时: 通过对象来调用，也就是：obj.methodName();如：123Scanner sc = new Scanner(System.in);//此处的sc就是对象[变量]int i = sc.nextInt(); 注：在Java中，方法之间是没有顺序的。 /*this 当前对象same classcontext 上下文一个静态方法不能直接调用非静态方法。所以要先创建对象。*/ 重载在一个类中，具有相同方法名称但不同参数的方法就构成了方法的重载。什么叫方法的重载？ 参数个数不同 参数类型不同 参数顺序不同如：123456public class Demo{ public int add(int a,int b){return a+b;} public double add(double a,double b){return a+b;} public double add(int a,double b){return a+b;} public double add(double a,int b){return a+b;}} 当调用重载方法时，JVM是根据参数列表来判断出准确的方法的。 递归[recursive]递归就是指方法直接或间接地调用自己。利用递归可以用简单的程序来解决一些复杂的问题，比如：斐波那契数列的计算、汉诺塔问题、快排等问题。递归结构包括两个部分： 定义递归头。解答：什么时候不调用自身方法。如果没有头，讲陷入死循环，也就是递归的结束条件。 递归体。解答：什么时候需要调用自身方法。 如：求一个整数的阶乘。5! = 54!; 4! = 43!; 3! = 32!; 2! = 21!; 1! = 1;使用数学公式就可以表达为：f(n) = n*f(n-1);所以，递归要有2个条件，也就是上面说的递归结构的两个部分。一要有规律，二要有退出时机。 注：使用递归时方法的效率不是很高，它对栈的容量有较大的要求，因为每一次的调用都是利用栈来保存中间的计算结果，直到最后一次递归返回结果。如果栈不够的话，则JVM会抛出StackOverflowException。 12345678910111213141516171819202122232425262728293031323334353637383940/* 求阶乘方法 */public static long factorial(int n){ if(n==1){//递归头 return 1L; }else{//递归体 return factorial(n-1);//n! = n * (n-1)! }}/* 所有用递归可以实现的方法都可以使用非递归实现。 *//* 非递归求阶乘方法 */public static long factorialLoop(int n){ long result = 1; while(n &gt; 1){ result *= n * (n-1); n -= 2; } return result;}/* 求整数的二进制字符串形式 */public String toBinary(int n){ if(n==0){//退出条件 return \"\"; } return toBinary(n/2)+n%2;}/* 汉诺塔问题 */public void move(char a, char b, char c, int n) { // if(n == 1){ System.out.println(a+\" -&gt; \"+c); } //调用自己 move(a, c, b, n-1); System.out.println(a + \" -&gt; \"+c); //再调用自己 move(b, a, c, n-1);} 修饰符[modifier]访问控制修饰符piblic ,prootected,默认,private其他修饰符 static,abstract,final,syschronized,native,volatile…注：修饰符之间是不没有顺序的。在java中，针对类的成员访问限权有四种，分别对应四种修饰符。 全局 子类 同包 本身 public Y Y Y Y protected N Y Y Y 默认 N N Y Y private N N N Y 返回类型[return type]1.所有合法的数据类型【包含基本数据类型和自定义对象】 表示这个方法有返回值，则在代码体中必须有return语句，并返回与表示这个方法有一致类型的。2.void表示这个方法没用返回值，则在代码体中可以不写return语句，如果一定要写，只能写空返回，如：return; 参数列表[parameters]参数列表就是局部变量【Local variable】，它的语法与变量一样，只是不能初始化。如有多个参数，则每个参数之间使用逗号隔开。 如： 123public int add(int a,int b){ //...} 当这个参数被调用[invoke]之时，它的参数才会有值【传递进来】。 所以，对于参数，有两种叫法：形参，是在方法的定义时所叫，它只有类型，暂时无值。实参，实在方法的调用时所叫，它既有类型又有值。 异常列表暂时省略 练习题design 设计implements 实现从以下业务中设计出相关的方法【不考虑实现】。 12345678910111213141516A.判断一个整数是否是质数public static int isprime(int num){ //...}B.求两个浮点数之和public static float add(float a,float b){ //...}C.获取给定整数的二进制字符串表示形式public static String getNumberBinary(int num){ //...}D.打印输出指定上限范围内的所以质数public static void printprime(int max){ //...} 刚刚开始接触一个新的知识，拿几个简单的例题联系几次也就知道这是个什么玩意了，当我们搞完上面几个题目就会理解Java方法这个东西了。点击进入答案解析 求两个整数的最大公约数[可以利用递归] 结束语over!","link":"/javase/java-method-modifier-returntype-parameter-exception.html"},{"title":"Java异常","text":"【摘要】Java异常~ 前言hi~ 异常定义java异常[exception]定义：是一种“信号”传递机制如： 1234567int i = ...;int j = ...;if(i / j == ...) { //有可能会出现异常【除0异常】 //...}//... 一段代码中，如果存在“有可能”出现异常的代码，而你的程序中又没有针对它做出“处理”，则一旦出现异常，程序就有可能会异常结束，从而达不到你的预期。 会有哪些异常？java的异常可以分为：A. 运行时异常，也叫未检查异常； B. 非运行时异常,也叫已检查异常； 运行时异常，也叫未检查异常所有直接或间接继承于RuntimeException异常的类都叫未检查异常，有：NullPointerException 空指针异常ClassCastException 类型转换异常ArrayIndexOutofBoundsException 下标越界异常…以上这类异常都有一个共性：都是在JVM内部造成的，而不是由外部环境引起的。所以，这种异常可以说是由程序员编码粗心造成的。解决方案是：希望程序员编码谨慎，比如：对象使用之前做非空判断，…. 非运行时异常,也叫已检查异常它们直接或间接继承于Exception类，或者换句话说，只要不是RuntimeException的子类，就是已检查异常。如：IOException,SqlException,FileNotFoundException,NetException, …以上这些异常也有一些共性，就是它们都是由JVM外部环境造成的，所以，对于此类异常，光编码谨慎是不够的，还有做出处理。 注：在java中，对异常还有更高层次的抽象，叫可抛出的，由java.lang.Throwable来表示。 12345java.lang.Throwable \\- java.lang.Error [错误] 无需处理它 \\- java.lang.Exception [异常] 重视 \\- RuntimeException 未检查异常 \\- 直接继承或间继承于 Exception 的类 如何处理异常？有如下两种处理方式A. 消极处理方式，B. 积极处理方式。 消极处理方式利用 关键字 throws 把异常抛出。如： 123456789101112public void ma() throws InterruptedException { Scanner sc = new Scanner(System.in); System.out.print(\"please enter int&gt;\"); // int i = sc.nextInt(); //这个方法有可能会抛出异常的。 //但是，由于是未检查异常，所以，可以不用处理。 //... Thread.sleep(1000); //这个方法也是有可能会抛出异常的. //这个异常是已检查异常，所以，必需要做出处理 //...} 积极处理方式利用 try catch finally 语句块来处理这个语句块有多种不同的变种。如： 12345678try { //有可能出现异常的代码 ...} catch(异常类型 e) { //...做日志，或者可以恢复...} catch (异常类型 e) { //...} 还有： 12345678910try { //有可能出现异常的代码 ...} catch(异常类型 e) { //...做日志，或者可以恢复...} finally { //... 一般做释放资源}//.... 注：不管try块中的代码是否出现了异常，finally块总会执行，除非在try块中执行了 System.exit(1) //退出JVM 进程 还有： 123456try { //.... ...} finally { //...一般做释放资源} 自定义异常类自定义异常类是一般是自定义已检查异常。只需要定义一个类继承 java.lang.Exception 类即可，并且重写父类的构造方法。 如： 1234567891011public class BalanceNotEnoughException extends Exception { public BalanceNotEnoughException() { super(); } public BalanceNotEnoughException(String msg) { super(msg); } public BalanceNotEnoughException(Throwable cause) { super(cause); } public BalanceNotEnoughException(String msg,Throable cause){ super(msg,cause); }} #结束语bye~","link":"/javase/java-exception-class.html"},{"title":"内部类","text":"【摘要】内部类~ 前言一般情况，我们把类定义成独立的单元。但在有些情况下，我们将一个类定义在另外一个类或者另外一个方法当中，这样的类称为内部类。 内部类在Java中，由于内部类所处的“位置”不同，可以分为以下几种不同的内部类： 成员内部类把内部类当做普通属性存在，可以使用private/default/protected/public任意进行修饰。类文件：外部类$内部类.class。 非静态内部类如： 1234567891011121314151617181920212223242526public class Outer { //属性 private int i; //成员内部类 private class Inner { //内部类的属性 private int j; //... //内部类的方法 public void innerF() { //... System.out.println(\"outer: \"+i); //访问外部类成员 } } //end of inner class private Inner inner; public Outer(int i) { this.i = i; //外界传入 this.inner = new Inner(); //组合 } //外部类的方法 public void outerF() { .... }} // end of outer class 静态内部类1234567891011class Outer{ //相当于外部类的一个静态成员 static class Inner{ }}public class TestStaticInnerClass { public static void main(String[] args) { //通过 new 外部类名.内部类名() 来创建内部类对象 Outer.Inner inner =new Outer.Inner(); }} 局部内部类1234567891011121314public class Test { public void show() { //作用域仅限于该方法 class Inner { public void fun() { System.out.println(\"helloworld\"); } } new Inner().fun(); } public static void main(String[] args) { new Test2().show(); }} 匿名内部类适合那种只需要使用一次的类。比如：键盘监听操作等等。 123456789101112131415161718this.addWindowListener(new WindowAdapter(){ @Override public void windowClosing(WindowEvent e) { System.exit(0); } });this.addKeyListener(new KeyAdapter(){ @Override public void keyPressed(KeyEvent e) { myTank.keyPressed(e); } @Override public void keyReleased(KeyEvent e) { myTank.keyReleased(e); } }); 总结 内部类的优点： A. 可以直接访问所在外部类的成员 B. 对于外部类来说，封装性更好。缺点： 语法古怪，不方便使用。 应用：考虑如下问题？ 1234567891011121314151617public interface Runnable { void run();}//还有一个抽象类public abstract class Person { //有一个方法 public abstract void run();}//现在我们要写一个类，即要有Person的能力，也有要Runnable的能力，怎么办？public class Teacher extends Person implements Runnable { // @Override public void run() { //此处，你实现的是“谁”的run? }} 在java中，此类问题可以看做是多重继承带来的问题，要用内部类来解决。如： 123456789101112131415161718public class Teacher extends Person { //... @Override public void run() { //就是 Person的run ... 拥有Person的能力 //调用内部类的 run方法 //...拥有 Runnable的能力 } //通过一个内部类来实现 Runnable 接口 class Inner implemensts Runnable { @Override public void run() { //Runnable的 run ... } }} 结束语bye~","link":"/javase/java-inner-class.html"},{"title":"类和对象、this、static、final关键字","text":"【摘要】类和对象、this、static、final关键字~ 前言hi~先简单聊聊我个人的理解，我理解的面向对象是思想层面的。Oriented Object，简称OO。与面向对象相对于的编程思想是面向过程。面向过程比较注重的是功能的实现，像C语言那样，以函数为载体，也是基本单位。所有的代码都是由函数来组织的。面向对象比较注重的是对象的构建，以类为单位，而把功能[方法]封装在类中，以对象为载体，代码都是以类来组织的。面向对象三大基本特征分别是封装、集成、多态。由面向对象才引申出类和对象的概念。 类和对象定义类是对象的抽象化，它是一个抽象的概念。对象是类的具体化，它是一个具体的概念。 如何知道要定义某个类呢？以面向对象的思想去描述客观事物的能力，决定你编写代码的思想。所以，OO的步骤为： A. 得到一个需求 B. 根据这个需求去找出所涉及到的所有”对象” C. 利用抽象的能力，把找出的这些“对象”进行“归类”[抽象化的过程] D. 利用java的语法把它描述成 xxx.java 类型，从而得到这个类。 如何定义一个类？根据对象拥有的属性和能力来定义一个类型，也可以说，一个类由如下部份组成： A. 这个类拥有什么？也就是属性。 B. 这个类能干什么？也就是方法。 属性[field]修饰符 数据类型 属性名[ = 初始值];从语法上可以看出，属性的定义与变量基本一样，所以，属性也叫实例变量。如： 123456public class A { //属性 private int i; private String name; //} 那么一个类，到底应该定义哪些属性呢？要根据所在对象的上下文来定义。注：同一个类从不同的视角分析同一个对象，所得到的这个对象属性和功能是不一样的。如： 123456789101112131415161718public class Student { //属性：拥有什么？ 它是数据[数据结构]的载体 private String stuNo; //学号 private String stuName; //姓名 private char gender; //性别 private String major; //专业 //... //方法：能干什么？ 它是算法的载体 //学习 public void study() { //... } //考试 public void exam() { //... } //...} 注：在Java中，只有三种量：A. 局部变量[Local variable]B. 实例变量[instance variable]C. 类变量,也叫静态属性[class variable]它们的生命周期大大的不同。局部变量的生命周期只存在于定义它的那一对大括号中。实例变量随对象而存在。类变量随类而存在，只要类加载进JVM,则它就在。 构造方法[constructor]构造方法是一个特殊的方法，用于类的初始化。当类中没有定义任何的构造方法时，则JVM会自动提供一个默认构造[空参构造]。它有以下特点：A. 没有返回类型。B. 方法名必须与类名同名。C. 支持重载。 注：构造方法的作用：A. 用来给属性赋值的。B. 满足创建对象的语法要求。注：对象创建的过程： 1).申请堆空间 [对象就创建好了] 2).给属性赋初始值 3).调用构造方法[给属性赋值]如： 12Student s1 = new Student();int i; 对象[object]和引用[references]对象是存放在堆空间中的”数据”。引用是指向堆空间中对象的地址。 我们必需通过引用去操作对象，而不能直接操作对象。没有引用，对象是不会单独存在的。 注：一个没有初始化的对象是不能使用的，否则会出现NullPointerException【空指针异常】。如： 12Student s1 = null;s1.study();// 会出现异常 注：一个对象可以有多个引用指向它。一个引用在某一时间最多指向一个对象。 this关键字1.表示当前对象[current object]。本质就是”创建好的对象的地址”!由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代“当前对象”。2.用来同类的调用其它的构造方法。 注：this不能用于static方法中。 static关键字static是Java中表示修饰符的关键字，根据他所修饰的目标不同进行分析。 修饰方法被修饰的方法就是静态方法，它将来是通过ClassName来访问的。如： 1234567891011public class A { // public static int add(int a, int b) { return a + b; } // public static void main(String args[]){ int sum = A.add(1,2); System.out.println(sum);//3 }} 静态方法不能被重写。 修饰属性被修饰的属性就是静态属性，也叫 类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。它是属于“类的”，而不是属于“对象的”。 12345678910111213141516171819202122public class B { private int i; //实例变量 private static int j; //类变量,所有此类的实例共享 //... public void setI(int i) { this.i = i;} public int getI() { return this.i; } // public static void setJ(int j1) { j=j1;} public static int getJ(){ return j; } // public static void main(String args[]){ B b1 = new B(); b1.setI(100); B b2 = new B(); b2.setI(200); b2.setJ(500); System.out.println(B.getJ()); //500 System.out.println(B.getJ()); //500 }} 静态方法不能直接访问非静态成员。 非静态方法可以直接访问静态成员。 静态方法中不能使用this。因为静态成员和非静态成员在初始化的时机上是不一样的。有了静态成员后，创建对象的过程如下： 在类加载[classload]时： 首先。给静态属性申请空间[永久区] 其次，给静态属性赋初始值。 最后调用静态代码块[如果有的话] 在创建类的实例时，总是按如下4步递归地创建父类对象： 为类的非静态属性申请堆空间 给非静态属性赋初始值 调用普通代码块[如果有的话] 调用构造方法 注：类加载只会发生1次。 修饰代码块静态代码块只有类加载时被执行1次。所以，它适合用来执行： A. 加载一些大的、固定的资源，如文件 B. 建立连接池 …注：静态代码块不能直接访问非静态属性。 修饰内部类被修饰的类称为静态内部类。如： 123456789101112public class Outer { //属性 .... // static class Inner { //属性 //方法 ... } //方法} final关键字final和static都是表示修饰符的关键字，所以我们也根据他所修饰的目标不同进行分析。 修饰局部变量，就称为常量。如： 1final int I = 9; //局部常量 修饰属性，就成了常量属性。如： 12345public class A { //public final int I = 9; //属性 public static final int I = 9; //属性 //...} 注：常量属性往往都是再加static修饰。 修饰方法，就成了最终方法。如： 123456public class A { //... public final void f() { //.... } } 注：final方法是不能被子类重写的。 修饰类，就成了最终类。如： 12345678public final class B { //..}public class C extends B { //报错 //..} 注：final类是不能被继承的。 问：abstract和final能共同修饰一个类吗？答：不能。 问：abstract和private、static能共同修饰一个方法吗？答：不能。 结束语bye~","link":"/javase/java-class-object-this-static-final.html"},{"title":"Object类","text":"【摘要】Java类层次结构是一棵倒置的“树”，根就是Object~ 前言hi~ Object废话不多说，先怼源码！下面这段代码是JDK1.8中的Object。其他版本的咱也没看，咱也不多扯。 123456789101112131415161718192021222324252627282930313233343536package java.lang;public class Object { private static native void registerNatives(); static { registerNatives(); } public final native Class&lt;?&gt; getClass(); public native int hashCode(); public boolean equals(Object obj) { return (this == obj); } protected native Object clone() throws CloneNotSupportedException; public String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); } public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException { if (timeout &lt; 0) { throw new IllegalArgumentException(\"timeout value is negative\"); } if (nanos &lt; 0 || nanos &gt; 999999) { throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); } if (nanos &gt; 0) { timeout++; } wait(timeout); } public final void wait() throws InterruptedException { wait(0); } protected void finalize() throws Throwable { }} 学习和了解Java里面的终极父类Object也就是弄清楚上面每个方法也就可以了。 registerNatives方法静态代码块是一个类在初始化过程中必定会执行的内容，所以在类加载时会执行该方法，通过该方法来注册本地方法。 getClass方法getClass方法用来获取对象的编译时类型。任一类型在JVM中的实例只有一个。如： 123456Book b1 = new Book(...);Book b2 = new book();//Class&lt;Book&gt; c1 = b1.getClass();Class&lt;Book&gt; c2 = b2.getClass();System.out.println(c1 == c2);//true Class是用来表示类型的类型，任何一个类型，被加载进JVM后，它在JVM中类型都是Class。 hashcode方法hashcode方法, 用来生成哈希码值，它是为了将来通过哈希算法存储数据时所需要调用的，目的是计算出具体的位置。默认的实现就是内存地址的码值。如果你想与equals方法保持一致，则也应该重写此方法。 equals方法equals方法,用来判断两个对象是否”相等”,它的默认实现就是比地址。同==如果你想从逻辑上去比较两个对象是否相等，则应该重写equals方法。 注：hashcode和equals方法是“联动”的，它有如下关系：A. equals返回true的两个对象的哈希码值必需一样B. equals返回false的两个对象的哈希码值要尽最努力保持不一样。如： 1234567891011public class Student { private String stuNo; private String name; private int age; //...}Student s1 = new Student(\"1001\",\"ZhangYao\",18);Student s2 = new Student(\"1001\",\"ZhangYao\",18);System.out.println(s1); //会打印出什么呢？System.out.println(s1.equals(s2)); // false 如果重写了比较逻辑，则会返回trueSystem.out.println(s1 == s2); //false clone方法如： 123456789101112Book b1 = new Book(\"人类群星闪耀时\",\"茨威格\",19.8);Book b2 = b1;//这不叫克隆[此时b2和b1指向同一个对象]b2.setPrice(45.6);//System.out.printl(b1.getPrice());//45.6//克隆public calss UseBook{ public static void main(String[] args){ Book b3 = b1.clone(); }} 注：Object类的clone方法的实现只完成了 浅拷贝，是指COPY了基本类型的属性以及实现了Cloneable接口的对象类型属性，如：String ,Date,而对于没有实现的Cloneable接口的对象类型属性，则还是会“共用”。 toString方法toString 方法，把对象以字符串的形式表达出来。它的默认实现是把对象的内存地址以16进制方式表达出来。所以，在你的类中应该去重写 toString方法。 notify方法notifyAll方法wait方法finalize方法finalize方法，当一个对象被GC回收之前，JVM会调用这个对象的finalize方法。虽然这个方法的目的很明确，但是，对象被GC回收的时机确时不确定的。所以，JVM调用此方法的时机也就是不确定的。如： 1234567Book b1 = new Book();//如何让这个对象被“GC”看上呢？b1 = null;//此时，按道理，GC会去回收这个对象，但是，时机并不确定。因为GC的执行时机，程序员是不能强制的，它有自己的打算。//可以尝试去 催促 GC ，比如调用这个方法：System.gc(); 结束语bye~","link":"/javase/java-object.html"},{"title":"运算符-表达式-分支语句-循环语句","text":"【摘要】运算符、表达式、分支语句、循环语句 前言说句实话，按照道理说我应该对这一部分很熟悉，毕竟大学考前突击了好几个夜晚。但是，哈哈哈哈。特别的位运算那边，想不起来，故查阅自己当时学习的笔记和现在的理解整理出此文~ 运算符赋值运算符=左值，出现在赋值运算符左边的量【局部变量、常量】右值，出现在赋值运算符右边的量【局部变量、常量、字面量】 算术运算符+,-,*,/,%,++,--,+=,-=,*=,/=,%= 针对++和——运算符，它分为：前 和 后 操作前++，变量本身和表达式的值都增1.后++，表达式的值不变，变量本身的值增1.Java基本数据类型中，除了boolean不能做算术运算外，其它的7种类型都可以进行算术运算，它们遵守如下两条规则：A.byte,short,char,int之间的运算，结果总是intB.除A外规则，其他的按照从小到大的原则进行转换，如下：byte,short,int -&gt;long -&gt;float -&gt;double 比较运算符&gt;,&lt;,&gt;=,&lt;=,==,!=比较运算符的结果一定是boolean值,如： 1boolean b = 5 &gt; 3; 逻辑运算符 运算符 说明 &amp;&amp; 逻辑与，两边同时成立，结果才成立。 ｜｜ 逻辑或，两边同时不成立，结果才不成立。 ! 真为假，假为真 注：逻辑运算符要求它的操作数必须是boolean类型。如：boolean b = (5 &gt; 3) &amp;&amp; (5 % 3 == 0);&amp;&amp; 和 || 是 短路运算符。 三目运算符？：语法： expr1?exper2:exper3;当expr1成立时，则执行并返回expr2，否则，执行并返回exper3。 如： 12int i = 19;String str = (i % 2 == 0) ? \"偶数\" : \"奇数\"; 位运算符基本概念 运算符 说明 &amp; 按位与，两边为1，结果为1，有一边为0，结果为0。 ｜ 按位或，两边为0，结果为0，有一边为1，结果为1。 ^ 按位异或，相同为0，不同为1。 ~ 按位取反，0位1,1为0。 &gt;&gt; 右移位，高位补符号位。 &gt;&gt;&gt; 无符号右移位，高位总是补0。 &lt;&lt; 左移位 &amp;=,|=,^=,~=,&gt;&gt;=,&gt;&gt;&gt;=,&lt;&lt;= 12 以整数为例，如： 二进制转十进制，乘幂相加法。 十进制转二进制，除2取余，直到商为0。 二进制 十进制 10 2 11 3 10110 22 101111011 187 注：在Java中，支持二、八、十、十六进制的字面量，默认下，整数都是以十进制表达的。 12345678//如果你想用二进制表达整数，则需要以0b开头。int i = 0b1011101;//ok//如果你想用八进制表达整数，则需要以0开头。int i = 015;//ok，相当于十进制13//如果你想用十六进制表达整数，则需要以0x开头。int i = 0x1F;//ok，相当于十进制的31 求负数的二进制方法：1).先算 这个负数 绝对值 减1的 二进制。2).按位取反：1111111111… 011 =&gt; 共计32位。 位运算口诀清0取位要用与，某位置1可用或，若要取反和交换，轻轻松松用异或。 这个口诀中，关键要找到掩码[mask] 比如：1.判断一个整数的奇偶性。 12345//定义掩码：int mask = 0x1;//00000...0001int i = ...;//判断String iStr = (i &amp; mask) == 0 ？\"偶数\" : \"奇数\"; 2.高24位不变，低8位取反 1234567891011//定义掩码：int mask = 0xFF;int i = ...;//判断String iStr = mask ^ i;//中间8位取反//定义掩码：int mask = 0xFF000;int i = ...;//判断String iStr = mask ^ i; 3.一个整数连续异或另一个整数两次，其值不变。(最简单的加密)如： 1234567int a = 18;//10010int b = 21;//10101//a ^ b ^ b 的结果将会还是 a//交换a和b:a = a ^ b;//a = a ^ b;b = a ^ b;//b = b ^ a ^ b;//相当于a异或了b两次，回到ba = a ^ b;//a = a ^ b ^ a;//相当于b异或了a两次，回到a 表达式[expression]概念：由变量、常量、字面量与运算符组合成的合法语句。如： 12int i = 9;//变量定义，也是 赋值表达式int j = i * 2 + 1; 分支语句if语句语法： 1234567891011121314151617181920if(条件表达式){ //代码块}//或：if(条件表达式){ //代码块1}else{ //代码块2}//或：if(条件表达式){ //代码块1}if else(条件2){ //代码块2}if else(条件3){ //代码块3}else{ //其他代码块...} 举个栗子，如： 123456int i = 9;if((i &amp; 1) == 0){ System.out.println(i+\" 是一个偶数.\");}else{ System.out.println(i+\" 是一个奇数.\"); } 牛刀小试，请根据如下要求编写一个程序。1.从键盘输入学员的成绩，根据成绩打印出相依的等级，成绩和等级的关系是： 成绩 等级 &gt;= 95 A+ [90,95) A [80,90) B [70,80) C [60,70) D &lt;60 E 点击进入答案解析 switch语句语法： 123456789101112131415switch(变量因子){case 值1： //代码块; [break;]case 值2： //代码块; [break;]...case 值N： //代码块; [break;]default: //默认代码块; [break;]} 注：变量因子的数据类型只能是：byte,short,char,int,枚举,Sting。举个栗子，如： 12345678910111213141516int i = ...;switch(i){case 1: System.out.println(\"1\"); break;case 2: System.out.println(\"2\");case 3: System.out.println(\"3\"); break;case 4: System.out.println(\"4\"); break;default: System.out.println(\"other\");} 牛刀小试，请根据如下要求编写一个程序。1.提示用户从键盘上输入年份和月份，然后判断此年月最大有多少天。点击进入答案解析 循环语句for循环语法： 1for(expr1;exper2;exper3){} 注：事先已经明确循环次数的场景下可以使用for循环。循环都可以嵌套。 举个栗子,如： 1234//使用for循环来循环5次。for(int i = 0; i&lt;5;i++){ } 牛刀小试，请根据如下要求编写一个程序。1.打印输出一个99法则表。点击进入答案解析 while循环语法： 123while(条件表达式){ //循环体} 比如，使用while循环5次 12345int i = 0;while(i&lt;5){ System.out.println(\"haha\"); i++;} 注：如果事先不知道循环次数，可以使用while语法。如果事先明确知道循环次数，则建议使用for语法。 如： 12345678910111213141516while(true){ System.out.println(\"haha\"); // if(满足某个条件){ break;//打破循环 }}//或：【不适用break】boolean exit = false;while(!exit){ System.out.println(\"haha\"); // if(满足某个条件){ exit = true;//修改变量的值 }} 案例：随机生成1~100之间的随机整数，当生成的随机数恰好是你事先指定的一个整数时，则此程序退出，并打印输出循环次数。思考：在java中，如何生成随机数？ 1234567方法一：利用java.util.Random类//CodeRandom r = new Random();int i = r.nextInt(100) + 1;方法二：利用java.lang.Math类//int i = (int)(Math.random()*100)+1; do while循环语法： 123do{ //循环体}while(条件表达式); 它是一个先执行循环体而后做条件判断的循环。如： 12345int i = 0;do{ System.out.println(\"haha\"); i++}while(i&lt;5); break和continue语句break语句，用来打破循环。continue语句也是一样只能用在循环中，它是结束本轮循环，开始下一轮循环。 注：不管是break还是continue语句，它们影响的都是最接近于自己那一层循环。 如： 123456for(int i = 0;i&lt;9;i++){ if(i%3 == 0){ break; } System.out.println(\"haha\");} 习题打印形状1.编写一个程序，打印如下形状：[高度由用户输入] 12345*************** 2.打印形状[高度由用户输入] 1234 * *** ************ 3.打印形状[高度由用户输入] 123456789 * * * * * * ** * * * * * * * * 点击进入答案解析 打印数字1.输出打印如下数字 123451*1=1 11*11=121111*111=12321...1111111*111111=12345654321 2.输出如下数字 123451*8+1=912*8+2=98123*8+3=987...123456789*8+9=987654321 点击进入答案解析 算法题1.根据用户输入的整数，计算出此数的阶乘5！ = 5*4*3*2*1 2.找出1000以内的所有水仙花数水仙花数是指一个N位正整数(N&gt;=3)，它刚好是它每一个数的n次幂之和。如：153=1^3+5^3+3^3 3.找出200以内所有的质数，并打印出来，要求：每行最多输出10个。点击进入答案解析 结束语上面这些习题是我曾经做过的题目，这些题目很基础，不要动脑子，适合初学者。但是呢，一旦我去LeetCode上面刷题，我就怀念这些基础题，哈哈哈哈。所以，现在先在这篇文章贴出来，等哪天被LeetCode虐了，再来这边找找存在感，后续贴源码链接。","link":"/javase/java-operator-experssion-branch-loop.html"},{"title":"三大常用类型(字符串String、日期类Date、数字类Number)","text":"【摘要】三大常用类型(字符串String、日期类Date、数字类Number)~ 前言hi~ 字符串定义有关字符串类型，java.lang.String 类，它的本质就是char[],它的实现代码： 123456public final class String implements CharSequence{ private char[] content; private int capacity; private int index; //...} 也就是说，字符串就是由字符数组组成的。但是，String是不变类，它的实例也就是不变对象。 如： 12String s1 = new String(\"abc\");//一旦这个字符串生成，则就是不可变的。s1 = \"def\";//ok,这是新建了字符串def ,原来abc 会被GC回收 对于字符串而言，它是最常用的数据，所以，JVM针对它做了特殊处理；其次，专门有一个“串池”的内存空间来存放String实例，但是，字符串实例是否存放在串池中要由程序员的定义决定。 创建字符串创建字符串的实例有如下两种方式: 普通方式[在堆空间中]1234String s1 = new String(\"abc\");//okString s2 = new String(\"abc\");//okSystem.out.println(s1 == s2);//false 串池方式123456String s3 = \"abc\";//okString s4 =\"abc\";//okSystem.out.println(s3 == s4);//trues4 = \"xyz\";//此时，会在串池中重新申请空间并存放 xyz,并把地址赋给s4 由于字符串是不变对象，所以，它的每一次拼接都会产生临时对象。String s5 = “abc” + “def” + “xyz”;//abcdefxyz这个代码会产生5个对象，其中，2个临时对象。s5是引用，是地址。 所以，考虑到字符串的性能问题，JDK提供了StringBuilder拼接工作，它利用一个可变字符串数组来进行拼接。 StringBuilder和StringBufferStringBuilder和StringBuffer这两个类的区别： 1.StringBuffer是多线程安全的类2.StringBuilder是多线程不安全的类 本质上这两个类的功能一模一样，唯一不同的就是StringBuffer的所以方法都是同步的[synchronized]。 建议大家使用StringBuilder,因为大多数时候我们的环境都是单线程环境的。即使是多线程环境，我们也可以自己加同步代码块来保证StringBuilder的多线程安全。 常用方法... ...字符的编解码操作 编码：把字符转换成字节的过程解码：把字节转换成字符的过程 每一个字符背后都是一个整数[byte也是一种整数]，所以，不同的字符集采用不同长度的编码，如： ASCII 采用单字节GBK 采用双字节编码UTF-8 采用多字节[1~3] 如： 12345678910111213String name = \"张三丰\";//把此字符进行编码byte[] arr = name.getBytes();//默认字符集//byte[] arr = name.getByte(\"UTF-8\");//也可以解码String str = new Strin(arr);//默认字符集String str = new String(arr,\"UTF-8\");//...有关字符串的切割 --split方法String str = \"abc:def:::haha:heihei::\";String[] arr = str.split(\":\"); 正则表达式定义：就是一些有“特殊”功能的字符序列。早先，JAVA并不支持正则表达式，从JDK1.4开始，引入了java.util.regex包，开始正式支持正则。 如何使用正则： 1.先把正则表达式[字符串]编译成Pattern实例2.利用Pattern提供的方法或者进一步得到Matchr3.利用Matcher进行匹配 如： 123456789101112131415String regex = \"a\";Pattern p = Pattern.compile(regex);//把这个字符串[正则]编译成Pattern实例String str = \"aaaab\";//准备你要测试的字符串Matcher m = p.matcher(str);//得到Matceher对象//str.matches(regex);//Pattern.matches(regex,str);//接下来就可以使用Matcher的方法m.matches(); 匹配一次，成功为true,否则为falsem.find();//依次去尝试匹配多次m.group();//配合find使用m.start();//配合find,匹配成功的起始位置m.end();//配合find,匹配成功的最后位置//... 日期12345java.util.Date \\- java.sql.Date [专门针对数据库的数据类型]Date的构造 public Date(); public Date(long millis); 注：在计算机中日期是使用一个长整型来表示的，它规定从1970年1月1日午夜开始到现在所经过的毫秒数。通过 System.currentTimeMillils() 方法来获取这个值。利用这个值可以来构建一个Date实例。 构建Date实例如： 1234Date now = new Date(); ////2个小时前Date now2 = new Date( System.currentTimeMillils()-2*60*60*1000); 构建一个 2008-8-8号? 怎么办？这就需要利用下面的Calendar类。 12java.util.Calendar \\- java.util.GregorianCalendar 123456789101112131415161718192021//CodeCalendar cal = new GregiroanCalendar();//但是不推荐这么做，因为使用了具体的子类，而应该：Calendar cal = Calendar.getInstance();//得到了日历类，就可以对它进行操作//1. 可以修改时间 [通过长整型修改或通过修改年、月、日]cal.set(Calendar.YEAR,2008);cal.set(Calendar.MONTH,7);cal.set(Calendar.DAY_OF_MONTH,12)//2. 可以获取时间Date now = cal.getTime();//3.获取单个值 int year = cal.get(Calendar.YEAR);..int month = cal.get(Calendar.MONTH);int week = cal.get(Calendar.DAY_OF_WEEK);//注：返回的值是1~7， 1代表周日，7代表周六 日期的格式化12java.text.DateFormat \\- java.text.SimpleDateFormat 由于DateFormat中内置工厂方法的格式不符合我们的使用，所以，此处我们直接使用 SimpleDateFormat。 1234567891011DateFormat df = DateFormat.getInstance();//但是：String p = \"yyyy-MM-dd\";SimpleDateFormat sdf = new SimpleDateFormat(p);//现在，就可以利用sdf来格式化或解析一个字符串如：String str = \"2008-08-8\";Date d1 = sdf.parse(str);//Date now = new Date();String str2 = sdf.format(now); //2017-07-20 数字类数字操作包装类[Wrapper]，也就是针对8种基本类型而言的。 基本类型 包装类型 byte Byte short Short int Integer long Long double Double float Float char Character boolean Boolean 包装类就是基本类型的对象类型，并且基本类型与对应的包装类型之间可以自动解封箱。也就是它们之间可以自动转换。如： 123456789int i = 9;Integer j = i;//自动封箱[auto boxing]int k = j;//自动解箱[auto unboxing]short s =19;int i = s;//okShort s1 = new Short(19);int i1 = s1;///ok 字符串与数字之间的转换123456789101112String iStr = \"19\";Integer i = new Integer(iStr);//ok//然后int ii = i.intValue();//int ii = i; //ok//或者利用parseInt方法int k = Integer.parseInt(iStr);int r = 119;//String rStr = r +\"\";//String rStr = String.valueOf(r); 大数字类型 java.math.BigInteger 大整数java.math.BigDecimal 大浮点数 原有的数字范围所不能表达的，就需要使用大数字。如： 12345678int i = 9;int j = 19;int k = i + j;//换成大数据对象的计算：BigInteger i = new BigInteger(\"9\");BigInteger j = new BigInteger(\"19\");BigInteger k = i.add(j); 数字的格式化 [美化数字]数字和字符串之间的转换如：1358.6 =&gt; ￥1,358.6以上的这个美化靠 String.valueOf做不到，需要使用NumberFormat 来进行。 #结束语bye~","link":"/javase/java-string-date-number.html"},{"title":"JCF之Collection","text":"【摘要】JCF,Java Collection Framework, JAVA集合框架~ 前言hi，思考一下：共计有1亿个整数，范围是【1~10000001】，每个数只出现1次，所以其中有一个数没有，请找出这个数。 CollectionJCF,Java Collection Framework, JAVA集合框架。它解决了数据在存储中数据结构的问题，使用它，程序只关心自己的业务，不需要关心底层的数据结构。 容器类[Container]，就是可以存放其它对象的对象，比如：数组就是容器。 比如：数组就有一个问题，就是它的长度是不可变的，所以，用数组来存放数据时，你得事先知道大小，但问题是，我们逻辑不允许我们事先知道，因为它是动态的。所以，我们使用数组做为数据的结构时，都得程序员自己想办法“扩容”。 而JCF就是解决此问题而来的，有了它，我们再也不用自己去“扩容”了，而且JCF中提供了多种不同的数据结构来供我们选择。 首先，JCF的包：java.util，它采用接口+实现类的方式提供服务。先看接口： 1234567891011java.util.Collection \\- List 【有序、可以重复】 \\- ArrayList 以数组为数据结构的集合 \\- Vector 同ArrayList \\- LinkedList 以链表为数据结构的集合 \\- Set 【无序、不可以重复】 \\- SortedSet 【排好序的、不可以重复的】 \\- TreeSet[类] 以二叉树为数据结构的集合 \\- HashSet[类] 以哈希表为数据结构的集合 Collection以对象为存储单元，我们通过字母E 代表对象的类型。如： 12345678Book b1 = new Book();Book b2 = new Book();Book b3 = new Book();//创建集合对象List collectionObj = new ArrayList();collectionObj.add(b1);collectionObj.add(b2);collectionObj.add(b3); 如何选择集合? A. 从业务功能上去选。B. 从有序还是无序上去选。C. 从性能上选【要根据业务】。 ArrayList和Vector的区别是什么？ 相同点：它们的操作都是一样的，底层的数据结构和算法也是一样的。唯一的不同点在于 Vector的所有方法都是同步的，也就是多线程安全的。而ArrayList则不是，所以，它是轻量级的。 注:StringBuilder和StringBuffer的区别同上。[StringBuffer是多线程安全的，同步的方法]。 在 List和Set 中，如何选择？从它们本身的特点中可以选择 List =&gt; 有序、可重复Set =&gt; 无序、不可重复 在 List的实现类：ArrayList和LinkedList如何选择？从底层的数据结构的特点进行选择 如果业务操作中，增删较多，选 LinkedList。如果业务操作中，查询较多，选 ArrayList。 在 Set的实现类：HashSet和TreeSet如何选择？从它们本身的特点中可以选择 HashSet是无序的。TreeSet是排好序的。 Collection的迭代方式一：使用 foreach循环，因为Collection接口继承于 java.lang.Iterable 接口。 [JDK5.0]如： 12345678List aList = new LinkedList();aList.add(\"...\");aList.add(\"...\");aList.add(\"...\");//for(Object e : aList) { //...} 方式二：使用迭代器[iterator]进行迭代… 来自于上面的代码 12345//Iterator iter = aList.iterator();while(iter.hasNext()) { Object e = iter.next(); //访问下个元素} 注：使用迭代器迭代集合时，元素是不能执行更新的。否则，会出现一个并发修改的异常。【ConcurrentModificationException】 Collections工具类12345678Collection集合的工具类 java.util.Collections 方法： addAll copy sort 排序 shuffle 打乱顺序[洗牌] ... 集合和集合元素在内存中是如何存储的？注：针对集合的操作大多都是仅仅操作集合本身，而不是通过集合去操作元素。如果是通过集合去操作了元素，那会影响到多个使用这些元素的集合。如： 12345678910Book b1 = new Book();Book b2 = new Book();Book b3 = new Book();//List&lt;Book&gt; a = new ArrayList&lt;&gt;();Collections.addAll(a, b1, b2, b3);//List&lt;Book&gt; b = new ArrayList&lt;&gt;(a);//这样一来，集合b和集合a 的确是两个集合对象，//但是，它们的元素是共用的。 所以，如果你操作的是集合本身，它们互不相干。但是，一旦某个集合操作了元素本身，则会影响另一个。 集合元素的排序 默认规则 [自然规则] 1Collections.sort(List a); 此方法中所讲的“默认规则”，就是这个集合中的元素都实现了一个叫 java.lang.Comparable的接口。事实是，8种基本类型的包装类和String,Date都实现了这个接口，换句话说，这些对象都是可比较的。所以： 1234567891011121314List&lt;Integer&gt; a = new ArrayList&lt;&gt;();Collections.addAll(a, 1,5,89,45,12,6,2,3);//Collections.sort(a); //直接可以排序。//排序后：{1,2,3,5,6,12,45,89}//但是，List&lt;Book&gt; b = new ArrayList&lt;&gt;();Book b1 = new Book();Book b2 = new Book();Book b3 = new Book();//Collections.addAll(b, b1, b2, b3);//Collections.sort(b); //运行时报错。 指定比较规则 1Collections.sort(List a, Comparator c); 这个方法针对集合List中的元素没有实现Comparable接口的要求，那它是如何进行比较的呢？答案就是利用 Comparator 比较器接口。 注：使用Comparator接口相比Comparable接口有什么优势？Comparator比较灵活，可以使用多种不同的比较规则。而且对元素的类型没有要求。 集合本身是对象，所以，集合中也可以存集合。 作业： 改写BookServiceImpl, 使用集合来实现。 结束语bye~","link":"/javase/jcf-collection.html"},{"title":"Lambda表达式","text":"【摘要】Lambda表达式~ 前言没有前言~ lambda表达式概念概念λ是希腊字母表中排序第十一位的字母，英语名称为lambda。为了避免匿名内部类定义过多，Java8引入这一新特性。其实质是函数式编程的概念。 语法格式123(params)-&gt;expression(params)-&gt;statement(params)-&gt;{statements} 借助Runnable推导演示普通方式启动线程比如创建线程时，我们只需要关注线程体(内容)，而不需要线程类和结构。先来看一下这个代码。 12345678910111213141516171819202122232425package com.aiz.se.lambda;/** * @Description 启动一个线程的一种方法 * @Author ZhangYao */public class StartRun implements Runnable { /** * 线程入口 */ @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(\"喝酸奶\"); } } public static void main(String[] args) { new Thread(new StartRun()).start(); for (int i = 0; i &lt; 10; i++) { System.out.println(\"吃爆米花\"); } }} 通过内部类我们知道一个类如果只是使用一次，我们可以把这个类做成内部类。 12345678910111213//静态内部类static class InnerThread1 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(\"喝酸奶\"); } }}public static void main(String[] args) { new Thread(new InnerThread1()).start();} 通过局部内部类其实我们可以把上面那个类中的类进行挪动，放在一个方法当中。 123456789101112public static void main(String[] args) { //局部内部类 class InnerThread2 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(\"喝酸奶\"); } } } new Thread(new InnerThread2()).start();} 通过匿名内部类123456789//匿名内部类 必须借助接口或者父类new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(\"喝酸奶\"); } }}).start(); jdk1.8 lambda相比匿名内部类省略接口名和方法名，但是，这种方式接口里面只能有一个没有实现的方法。 1234567//jdk8使用lambda简化 省略接口名和方法名new Thread(()-&gt;{ for (int i = 0; i &lt; 10; i++) { System.out.println(\"喝酸奶\"); } }).start(); 一般来说比较简单的线程体我们才使用lambda，lambda就是用于简化简单的线程体，jdk8会自己进行推导是Runnable的run()方法。接口中如果有多个没有实现的方法无法则进行推导。 推导总结通过上面一步一步的推导，我想应该明白了lambda表达式创造的用意和如何进行使用。由于上面每个步骤的代码片段不在一起，下面先放一个总的代码类，方面直接观察。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.aiz.se.lambda;/** * @Description Lambda表达式简化线程(只用一次)的使用 * @Author ZhangYao */public class LambdaThread { //静态内部类 static class InnerThread1 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(\"喝酸奶\"); } } } public static void main(String[] args) { //静态内部类 new Thread(new InnerThread1()).start(); //局部内部类 class InnerThread2 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(\"喝酸奶\"); } } } new Thread(new InnerThread2()).start(); //匿名内部类 必须借助接口或者父类 new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(\"喝酸奶\"); } } }).start(); //jdk8使用lambda简化 省略接口名和方法名 new Thread(()-&gt;{ for (int i = 0; i &lt; 10; i++) { System.out.println(\"喝酸奶\"); } } ).start(); }} lambda的使用在推导过程中，考虑到只是简单的推导越简单越好，我使用的是线程相关的Runnable的例子，其中的run()方法并未涉及到返回值和参数。其实在我们实际使用过程中需要参数和返回值，下面我就来介绍如何来使用。自定义一个接口，其中只包含一个未实现的方法，并且该方法有返回值和参数。下面我定义了一个数学运算的接口。 123interface MathOperation { int operation(int a, int b);} 为了使用上面数学运算的接口，我们需要定义一个操作的方法。 123private int operate(int a, int b, MathOperation mathOperation) { return mathOperation.operation(a, b);} 下面列出全部代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.aiz.se.lambda;/** * @Description 测试Java8 Lambda表达式 * @Author ZhangYao */public class LambdaTester { /** * 自定义接口 */ interface MathOperation { int operation(int a, int b); } /** * @param a * @param b * @param mathOperation * @return a和b经过某种数学运算MathOperation后的结果 */ private int operate(int a, int b, MathOperation mathOperation) { return mathOperation.operation(a, b); } public static void main(String[] args) { LambdaTester tester = new LambdaTester(); //类型声明 MathOperation add = (int a, int b) -&gt; a + b; //不声明类型 MathOperation sub = (a, b) -&gt; a - b; // 大括号中的返回语句 MathOperation mul = (int a, int b) -&gt; { return a * b; }; // 没有大括号及返回语句 MathOperation div = (int a, int b) -&gt; a / b; //输出结果 System.out.println(\"10 + 5 = \" + tester.operate(10, 5, add)); System.out.println(\"10 - 5 = \" + tester.operate(10, 5, sub)); System.out.println(\"10 * 5 = \" + tester.operate(10, 5, mul)); System.out.println(\"10 / 5 = \" + tester.operate(10, 5, div)); }} 注：Lambda 表达式只能用于 functional interface ，而 functional interface 只有一个方法。 经常使用场景 实现Runnable/Comparable/迭代列表/事件监听… 参考 菜鸟教程 结束语没有结束","link":"/javase/jdk-8-lambda.html"},{"title":"JCF之Enum","text":"【摘要】JCF之Enum[枚举]~ 前言hi~ 枚举 [enum]JDK5.0开始有了枚举类型，它也是一种数据类型，是一种值类型。它的目的是为了提供 “类型安全的常量”。没有枚举之前，表达学员类型的性别： 12345678public class Student { private Integer id; private String name; private Gender gender; //性别 [男，女] private StuStatus status; //学员的状态[未入学，学习中，退学，休学，毕业]}//创建一个学员对象，并赋给属性值Student s1 = new Student(1,\"ZhangYao\",Gender.MALE,StuStatus的实例); 我们如何才能做到让Student的gender属性和status属性的值只能从固定好的几个值中进行选择？答案：利用枚举。如： 123456public enum Gender { MALE, //public static final Gender MALE = new Gender(); FEMALE; //public static final Gender FEMALE = new Gender();} 它的特点： 1.构造方法是私有的2.每一个枚举常量值都是一个公开、静态、类本身的常量实例3.自动继承于java.lang.Enum 类 语法： 1234567public enum 枚举名 { 枚举常量1, [枚举常量2,] [枚举常量3,] .... [枚举常量N];} 如： 1234567public enum Season { SPRING, //public static final Season SPRING = new Season(); SUMMER, AUTUMN, WINTER;} 枚举类中也可以有抽象方法但是要注意：因为有抽象方法，则这个枚举从语法上来看，它属于抽象类。它就不能被实例化，这样一来，它的所有枚举常量就是非法的。所以，只能通过匿名内部类来实例化每一个枚举常量，并实现抽象方法。如： 123456789101112public enum Hehe { A{ @Override public void ma() { //... } }, //相当于：public static final Hehe A = new Hehe(); B; //抽象方法 public abstract void ma();} 有关枚举的集合java.util.EnumMapjava.util.EnumSet 作业编写一个模拟扑克牌中的洗牌、发牌的业务，包含如下类型 开发两个枚举类型 123456public enum 花色 { //黑、红、梅、方}public enum 点数 { //...从A至K} 如果要考虑大小王，则再提供一个枚举123public enum Joker { //大、小} 开发一个卡片类 [Card]， 由 花色、点数12345public class Card { private 花色 花色; private 点数 点数; private 王牌 王牌; } 开发一个扑克牌类 [Poker], 它由 52/54张卡片组成123456public class Poker { //属性 private String vendor; // private List&lt;Card&gt; cards; //这个属性很关键 //...} 再写一个类，针对Poker的业务类12345public class PokerService { //有强大需求的可以定义接口 //洗牌方法... //发牌方法... [玩家数，每人发几张] 此方法把每个玩家的牌给打印出来..} 结束语bye~","link":"/javase/jcf-enum.html"},{"title":"JVM垃圾回收算法","text":"【摘要】JVM垃圾回收算法 参考 什么是垃圾？没有任何引用指向的一个对象或者多个对象（循环引用） 如何定位垃圾？引用计数法 根可达算法什么是根？ 垃圾回收算法 标记清除 - 位置不连续 产生碎片 效率偏低（两遍扫描） 拷贝算法 - 没有碎片，浪费空间 标记压缩 - 没有碎片，效率偏低（两遍扫描，指针需要调整） Mark-Sweep(标记清除) Copying(拷贝) Mark-Compact(标记压缩)","link":"/javase/jvm-garbage-collection-algorithms.html"},{"title":"JCF之Map","text":"【摘要】JCF之Map[映射]~ 前言hi~ Map的存储方式它不像Collection直接存储元素本身，而是通过key -&gt; value的方式进行存储,也就是键、值对的映射。如： 12345678Book b1 = ....;Book b2 = ....;Book b3 = ....;//采用Collection存储Collection&lt;Book&gt; colObj = new ArrayList&lt;&gt;();colObj.add(b1);colObj.add(b2);colObj.add(b3); 而利用Map存储： 12345Map&lt;Integer,Book&gt; map = new HashMap&lt;&gt;();//map.put(b1.getBookId(), b1);map.put(b2.getBookId(), b2);map.put(b3.getBookId(), b3); 注：可以看出，Map通过key-&gt;value方式存储的效率更高，原因是map通过key[它只是对象的一小部份]来操作value。 所以，对于Map，最核心的就是Key，一般而言，key只会选择如下三种类型： IntegerLongString 因为，这三种类型都是API自带的，并且它们都是可比较的，也就是都实现了Comparable接口。 Map的特点： key不允许重复。它是无序的。对于HashMap实现来说，允许null键和null值。 有关Map的API12345java.util.Map \\- HashMap[C] 采用哈希表为数据结构 \\- Hashtable[C] 同上，它是同步的 \\- SortedMap \\- TreeMap[C] 采用二叉树为数据结构 在Map中，可以通过key来获取value,但反过来不行。所以，Map中，对Key是有要求的【不允许重复、无序】。 Map的操作 put(K k, V value);get(K k);clear();remove(K k);putAll(Map&lt;K,V&gt; map);size();isEmpty();… 如何迭代Map首先，Map没有继承 Iterable接口，所以，不能使用foreach循环来迭代。其次，也没有方法返回 Iterator 接口实例。so, how?由于Map由key-value组成，我们有理由从如下三个角度来看集合： 把Map的key单独取出来形成 Set。12345678910//Code:Map&lt;Integer, Book&gt; map = ....;//...Set&lt;Integer&gt; keys = map.keySet();//接下来就是迭代 Setfor(Integer key : keys) { //再通key来获取 value Book value = map.get(key); //...} 把Map的value单独取出来形成 Collection。1234Collection&lt;Book&gt; values = map.values();for(Book b : values) { //...} 把Map的key和value都取出来形成 Set。这需要把key和value封装成一个类型，才能存放到Set中，所以：1Set&lt;Entry&lt;Integer,Book&gt;&gt; entry = map.entrySet(); SortedMap的实现类 TreeMap 我们使用此类的目的就是为了排序，而它同样支持两种排序的使用： 空参构造时使用 自然顺序,也就是要求Key的类型要实现 java.lang.Comparable接口。 以比较器为构造参数，也就是对Key的类型没有要求，但是要传入一个Comparator实例为参。 如： 12345Map&lt;Integer,Book&gt; map = new TreeMap&lt;&gt;();//map.put(b1.getBookId(),b1);map.put(b2.getBookId(),b2);map.put(b3.getBookId(),b3); HashMap是如何保证Key不重复的？ 答：调用Key的 hashcode方法,得到哈希码值，并由这个值来决定存放的位置。当第二次放入对象时，同样会调用hashCode方法，得到哈希码值，会比较这个值所对应的位置，如果之前所存放的对象位置一样，则进一步调用equals方法。如果equals为true,则表示key值一样，那只留下1个。如果equals为false,则继续算出另一个位置来存放。 TreeMap是如何保证Key不复重的？ 答：通过比较器或自然顺序，当通过空参构造时，则利用Comparable接口。当通过带比较器参数来构造时，则利用Comparator接口。 TreeMap和HashMap的区别 答：有关hashCode方法和equals方法的原则：1.equals方法返回true，则两个对象的hashcode值一定是一样的。2.equals方法返回false,则尽最大努力保证它们的hashcode方法的返回值不一样。 HashSet 是如何保证元素唯一、无序的？ 它的原理与HashMap是一模一样的，实际上，HashSet本身就是基于HashMap实现的，它组合了HashMap。 可以看一下HashSet的源码，片断如下： 12345678910111213141516public class HashSet&lt;E&gt; implements Set&lt;E&gt; { // private HashMap&lt;E, Object&gt; map; //提供了一个固定 的对象 private static Object ABC = new Object(); // public HashSet() { //内部初始化map this.map = new HashMap(); } //添加元素的方法 public boolean add(E e) { this.map.put(e, ABC); } //...} TreeSet和TreeMap 的关系？ 实际上，TreeSet组合了TreeMap，所以，它们的原理是一样的。 结束语小结： 12345678910111213141516171819202122无序、不可重复 HashSet HashMap Hashtable有序、可重复 [可以按下标访问] ArrayList LinkedList Vector注: 以上三个都是List, 可以排序。排序的、不可重复 TreeSet TreeMap工具类： Collections排序接口 Comparable Comparator迭代接口 Iterable Iterator有了集合，再也不需要使用数组了。 bye~","link":"/javase/jcf-map.html"},{"title":"JVM堆分带介绍","text":"【摘要】JVM堆分带介绍 JVM内存分代模型（用于分代垃圾回收算法） 部分垃圾回收器使用的模型 新生代 + 老年代 + 永久代（1.7）/ 元数据区(1.8) Metaspace 永久代 元数据 - Class 永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存） 字符串常量 1.7 - 永久代，1.8 - 堆 MethodArea逻辑概念 - 永久代、元数据 新生代 = Eden + 2个suvivor区 YGC回收之后，大多数的对象会被回收，活着的进入s0 再次YGC，活着的对象eden + s0 -&gt; s1 再次YGC，eden + s1 -&gt; s0 年龄足够 -&gt; 老年代 （15 CMS 6） s区装不下 -&gt; 老年代 老年代 顽固分子 老年代满了FGC Full GC GC Tuning (Generation) 尽量减少FGC MinorGC = YGC MajorGC = FGC","link":"/javase/jvm-heap-striping.html"},{"title":"JVM垃圾收集器回收策略详解","text":"【摘要】JVM垃圾收集器回收策略详解 常见的垃圾回收器 Serial 年轻代 串行回收 PS 年轻代 并行回收 ParNew 年轻代 配合CMS的并行回收 SerialOld ParallelOld ConcurrentMarkSweep 老年代 并发的， 垃圾回收和应用程序同时运行，降低STW的时间(200ms) G1(10ms) ZGC (1ms) PK C++ Shenandoah Eplison 8默认的垃圾回收：PS + ParallelOld","link":"/javase/jvm-garbage-collector.html"},{"title":"JVM入门介绍","text":"【摘要】JVM入门介绍。 前言参考链接写过C/C++程序的都知道，在内存管理方面，需要对所创建的每一个对象的创建到销毁负责。但是对于Java程序员来说，在虚拟机自动内存管机制下，我们不需要为每一个new操作去写相应的delete/free代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存这一切看起来都很美好。不过，也正是因为Java程序员把内存控制的权力交给了JVM，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。在开始了解JVM之前，我们需要知道: Java程序是运行在JVM上的。 JVM是使用c++编写的。 一个Java程序是如何执行的? JVM是什么？首先，JVM是什么？JVM(Java Virtual Machine，Java虚拟机)。作为Java开发人员，我们一直在使用JVM，但是很少去关注JVM到底是怎么运行的。就像我们天天都使用手机，但却很少有人拆开手机看看里面到底是什么模样的。 JVM是一种用于计算设备的规范。 它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。包括 字节码指令集（汇编语言） 内存管理：栈、堆、方法区等。 Some Oracle Documentation | JDK 13 Documentation JVM–跨语言的平台JVM跟Java语言无关，因为是JVM上运行的是class文件。换句话说，也就是任何语言只要能编译成符合特定语法的.class文件，你的程序就可以在JVM上运行。目前已经有很多语言可以通过编译成class文件在JVM上运行。如：Java、Scala、Kotlin、Groovy等。然而针对不同的操作系统平台，JVM又有不同的版本。 常见的几种JVM实现目前已经有很多JVM的实现，下面是常见的几种： HotSpot – Oracle官方的，我们做实验通常会使用这个。可以通过java -version查看。 Jrockit – BEA,曾经号称世界上最快的JVM,被Oracle收购，合并于HotSpot。 J9 - IBM Microsoft VM TaoBaoVM – HotSpot深度定制版。 LiquidVM – 直接针对硬件。 azul zing – 最新垃圾回收的业界标杆。azul官网 JDK、JRE和JVM的关系？ JVM，温故而知新还记得当我们装好JDK，配置好环境变量之后，我们会在命令提示符输入java -version。我们以往只关心下面输出的内容只要不是“既不是内部也不是外部命令”这种错误提示，最多看一下jdk的版本号，也就默认是配置成功的。很少会去看下面两行的信息。 如上图，红框里面的HotSpot&lt;TM&gt;代表JVM的核心组件，或者可以说他说JVM的名称。jdk的每一次更新版本都会重点对某一问题进行优化。我们知道jvm每次加载class文件后，会把class文件转换为本地编码，频繁的加载class文件会消耗计算机资源，所以使用热点探测技术进行优化这个问题。就是在每一次在加载class文件的时候，会根据加载的class文件做标记，然后标记的过程中达到一定的阈值，会触发实时编译机制(Just In Time Compiler，JIT)。 其实虚拟机在启动时，为我们准备了两套不同的机制，一个是Client VM，另外一个就是红框中的Server VM来初始化自己。为了更加合理的使用内存，Client VM主要用来使用桌面级应用，而Server VM主要用来处理并发问题。 我们可以在JDK安装目录中找到虚拟机的配置文件。我的操作系统是64位的，在C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\amd64\\jvm.cfg，如果你使用的是32位系统上面amd64替换为i386。 找到之后打开文件。可以看到文件下方有server和client两个，可以调整(谁在上面使用谁)使用哪个机制初始化虚拟机。(我这里client IGNORE所以不能改。) 结束语通过上面的描述，知道了什么是JVM？下篇将走进JVM内部，带你了解她神秘面纱后面的娇艳欲滴。","link":"/javase/jvm-introduction.html"},{"title":"JDK安装与配置","text":"【摘要】阅读本文你会对JDK的基本概念有更深的了解，学会在Windows上安装和配置JDK，从而为下一步的Java打下基础。 前言既然打算写JavaSe这部分的系列文章，想要记录的详细一点。因为大一的时候接触过C++，所以大二自己刚刚接触Java这门语言的时候，真的是一头雾水。打开VC6.0直接就可以运行C++程序啊，根本不懂Java干嘛还要安装JDK这个鸟毛东西。下面就先介绍一下JDK到底是什么东西。 基本概念 JDK,Java Development Kits,Java开发工具它包含了一个商业虚拟机，以及编译器（javac.exe）、打包工具（jar.exe）、运行环境，还有第三方工具，它是一个开发套件。(JDK:JRE+Java开发工具) JVM，Java Virtual Machine,JAVA 虚拟机它使java程序得以跨平台。 JRE，Java Runtime Environment,JAVA运行环境（JRE：JVM+类库） 此外，JAVA语言有三大平台[Platform] JAVASE,JAVA Standard Edition,java标准版 JAVAEE,JAVA Enterprise Edition,java企业版 JAVAME,JAVA Micro Edition,java微平台版 安装JDK官网下载首先下载你所需要的JDK，下载地址，JDK的安装很简单，下载下来直接双击打开，无脑点确定就可以。（我这里选的是1.8的一个版本，根据个人情况选择版本） 运行安装1.下载完成之后，找到下载到的文件，双击运行。2.弹出下面指导安装页面。点击下一步，进行安装。3.选择JDK安装目录(这里我选择的是默认路径)，继续点击下一步。4.选择jre安装目录(这里我还是选择的默认路径)，继续点击下一步。5.弹出安装进度页面，等待程序安装。6.安装完成，点击关闭。完成以上操作就成功的在你的电脑上安装了JDK，接下来就要进行JDK的配置了。 配置JDK1、新增JAVA_HOME变量值。右击-&gt;我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量（本人是win10系统）。此处Java环境变量的JAVA_HOME的值为C:\\Program Files\\Java\\jdk1.8.0.231，就是我jdk的安装目录(默认安装位置)。 2、新建环境变量CLASSPATH。CLASSPATH变量值为：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar。注意此处变量值前面有.。 3、修改path环境变量。修改path环境变量，把%JAVA_HOME%\\bin追加到path环境变量的值。格式为%JAVA_HOME%\\lib。 然每一级窗口都点确定就可以。 检查配置下面，按win+R 输入cmd。输入java -version，出现以下情况说明配置成功。注意看一下版本，就是你刚刚安装的版本。 注意事项因为本人的是win10系统，安装上面方式配置结束后，发现在控制台输入javac并不生效，查阅网友经验后，放弃使用中间变量，直接在path处添加绝对路径。 结束语如果上面操作都顺利的话，你的JDK就安装成功了。等我有钱买MacBook Pro的时候，我还会在这篇文章后面增加怎么给MacOs安装JDK。那个就超级简单了。哈哈哈哈。JDK准备好了，下篇就是如何安装Java集成开发环境。安装集成开发环境Eclipse&amp;IntelliJ IDEA","link":"/javase/jdk-install-and-config.html"},{"title":"JVM内存结构","text":"【摘要】JVM内存结构 前言我们既然可以说JVM是虚构出来的计算机，那么了解他的内存结构就显得尤为重要。参考链接-前辈博客1 | 参考链接-前辈博客2 | 资料链接-官方文档 Java内存组成结构：堆(Heap)和非堆(Non-heap) 按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。 JVM内存区域模型根据《Java 虚报机规范SE 7版》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区城，如图所示。 堆空间和栈空间 堆栈 描述 栈空间 栈空间 [stack] 它是一种先进后出[FILO]的内存结构，它的特点是：大小固定，不可以动态扩展，存取效率非常高在Java中，它主要用来存储局部变量。只要是基本类型，则直接存值。只要是对象类型，则一定是存地址【引用】,地址总是4个字节。 堆空间 堆空间 [heap]也是一个数据结构，它的特点：可以动态扩展大小，存取效率相比栈稍低。在Java中，堆用来存放对象本身，所有使用 new 运算符申请的都是堆空间。也就是说，堆空间是需要程序员主动去申请的，而不是JVM自动给你的。而且程序员自己申请的堆空间理论上来说是需要自己去主动释放的。 但是，Java中，JVM提供了一个GC线程，也就是垃圾回收线程，它会帮助我们去主动释放堆空间，这样一来，程序员们就无需自己手动去释放堆空间了。如：Student s = new Student();int[] a = new int[10]; 方法区(Method Area)也称”永久代” 、“非堆”， 它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize和 -XX:MaxPermSize参数限制方法区的大小。运行时常量池：是方法区的一部分，其中的主要内容来自于JVM对Class的加载。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。 虚拟机栈(Java Virtual Machine Stacks)描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。 局部变量表存放了编译器可知的各种基本数据类型boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。 本地方法栈(Native Method Stacks)与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。 堆(Heap)也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。 由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。 新生代： 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。 老年代： 用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。 老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。 程序计数器(The PC Register)是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。 Java堆内存的10个要点 1.Java堆内存是操作系统分配给JVM的内存的一部分。 2.当我们创建对象时，它们存储在Java堆内存中。 3.为了便于垃圾回收，Java堆空间分成三个区域，分别叫作New Generation, Old Generation或叫作Tenured Generation，还有Perm Space。 4.你可以通过用JVM的命令行选项 -Xms, -Xmx, -Xmn来调整Java堆空间的大小。不要忘了在大小后面加上”M”或者”G”来表示单位。举个例子，你可以用 -Xmx256m来设置堆内存最大的大小为256MB。 5.你可以用JConsole或者 Runtime.maxMemory(), Runtime.totalMemory(), Runtime.freeMemory()来查看Java中堆内存的大小。 6.你可以使用命令“jmap”来获得heap dump，用“jhat”来分析heap dump。 7.Java堆空间不同于栈空间，栈空间是用来储存调用栈和局部变量的。 8.Java垃圾回收器是用来将死掉的对象(不再使用的对象)所占用的内存回收回来，再释放到Java堆空间中。 9.当你遇到java.lang.outOfMemoryError时，不要紧张，有时候仅仅增加堆空间就可以了，但如果经常出现的话，就要看看Java程序中是不是存在内存泄露了。 10.请使用Profiler和Heap dump分析工具来查看Java堆空间，可以查看给每个对象分配了多少内存。 结束语未完待续","link":"/javase/jvm-memory-structure.html"},{"title":"面向对象三大特征：封装、继承、多态，super关键字","text":"【摘要】OO的核心思想：面向父类、抽象、接口编程；对扩展开放，对修改关闭；高内聚、低耦合。 前言面向对象三大特征：封装、继承、多态；五大基本原则：单一职责原则(SRP)、开放封闭原则(OCP)、里氏替换原则(LSP)、依赖倒置原则(DIP)、接口隔离原则(ISP)。 封装[encapsulation]封装简单的说就是该隐藏的隐藏，该公开的公开。优点： 提高代码的安全性。 提高代码的复用性。 “高内聚”：封装细节，便于修改内部代码，提高可维护性。 “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。 类的封装 属性尽可能地私有化。但是为了外面的调用者要存取属性，我们必须对属性提供公开的存取方法。也就是get和set方法。如：1234567public String getStuName(){ return this.stuName;}public void setStuName(String stuName){ this.stuName = stuName;} 对外的业务方法要公开。 涉及到访问修饰符的使用。 方法的封装由于类的数据[属性]和功能[方法]是分开的，所以，我们可以有另一个策略来封装类的功能。 策略一：把类的属性、构造、存取方法以及业务方法全部封装。同一个类中，这种策略适合功能单一、业务简单的场景下。如：要封装一个银行账户类： 1234567891011121314151617181920public class Account { //属性 private String no; // 帐号 private double balance; //余额 private String realName; //真实姓名 ... //构造方法 ... //getter/setter方法 ... //业务方法 public void deposit(double money) { ... } public void withdraw(double money) { ... } public void transfer (Account target, double money) { ... }} 策略二：把类的属性、构造、存取方法单独封装成一个实体类，它就是纯数据的载体，而针对这个数据的操作，也就是业务方法另外封装成一个类[业务类]。 12345678910111213141516171819202122232425//实体类public class Account { //属性 private String no; // 帐号 private double balance; //余额 private String realName; //真实姓名 ... //构造方法 ... //getter/setter方法 ...}//针对Account数据的业务类public class AccountService { //提供操作Account对象的业务方法 public void deposit (Account a, double money) { ... } public void withdraw (Account a, double money) { ... } public void transfer (Account from, Account target, double money) { ... }} 很显然，策略二的扩展性更好。 继承[inheritance]继承是一种能够让子类快速[获取父类]代码复用的机制。在Java中，类只支持单继承，优点是结构简单，易于管理。在java中，继承还有如下特点： A.单继承。B.传递性。C.所有类都直接或者间接继承于java.lang.Object类。 如果自定义的类型没有显示地指定父类，则自动继承java.lang.Object类。可以使用extends关键字表达继承关系。当A类继承B类时，则可以这么表达： 123456public class B{ //...}public class A extends B{ //...} 此时，我们可以说：类A是类B的子类/派生类。类B是类A的父类/超类[super class]。 何时使用继承呢？1.使用集成时，两个类之间要满足IS A的关系。2.只有当他们之间满足IS A的关系时，才应该使用继承关系否则，不要轻易使用继承。如:Bird IS A AnimalsApple IS A Fruits… 有了父子类后，累的属性该如何划分？共性归父类、个性归子类。如： 1234567891011121314151617181920212223242526public class Animals { //属性 ...}public class Dog extends Animals { //属性[个性]}public class Cat extends Animals { //属性[个性]}//父类可以指向一个具体的子类对象Animals d = new Dog();Animals c = new Cat();//编译时类型：// 就是对象的申明时类型，它可以是父类类型或本身 如： Animals d1 = new Dog();//ok Dog d2 = new Dog();//ok Object d3 = new Dog();//ok//运行时类型// 就是对象的真正类型，也就是通过getClass()获取的类型。 注：对象的编译时类型可以变化，但是，它的运行时类型永远不会改变，从对象创建时就已确定。 有了父子类后，创建对象的步骤升级为：总是按如下三步递归地创建父类对象 1.申请堆空间[本类对象]2.给属性赋初始值[本类对象]3.调用构造方法[本类对象] 多态[polymorphism]具有相同类型的对象，调用同一个方法时，表现出不同的行为。但是，这要有如下前提： A.要有继承关系B.要有方法的重写[被调用的方法] 所谓方法的重写[override],是指子类中的方法声明与父类申明保持一致。可以体现在： A.子类方法的访问控制修饰符必须大于或等于父类的。B.子类方法的返回类型的上限是父类方法的返回类型。C.方法名必须一样D.参数列表必须一样E.子类方法抛出 如： 12345Animals a1 = new Dog();Animals a2 = new Cat();a1.spark();//调用的是Dog()的spark方法a2.spark();//调用的是Cat()的spark方法 对象的编译时类型决定了对象所能“看得见”的行为。 对象的运行时类型决定了对象的真正行为。 为什么此时对象的编译时类型要写Animals呢？因为要用“统一”的类型来处理这些对象，而使用这些对象的父类类型是一种既可以满足多态的要求又可以达到用户的解决方案。 因为要遵守如下OO的思想： 面向父类编程面向接口编程面向抽象编程 从编程的角度来理解的话，可以分为 1.对象的编译时类型尽可能的写父类2.方法的参数尽可能地写父类 如： 12345678910public void m(Dog d){ //... d.spark(); //...}public void m(Cat c){ //... d.spark(); //...} 可改成： 12345public void m(Animals a){ //... d.spark(); //...} super关键字 在构造器中，用来调用父类的构造器。若是构造方法的第一行没有显式的supper(…)或者this(…)，那么Java默认都会调用super()，含义是调用父类的无参构造方法。 表示指向父类对象的指针[引用]。如：123456789101112131415public class A { protected int index = 50; public void f(){ System.out.println(\"A:\"+index); } //...}public class B extends A { private int index = 100; // public void f(){ super.f();//调用父类的普通方法 System.out.println(\"B:\"+index); //System.out.println(\"A:\"+super.index);//调用父类的成员属性 } 结束语~","link":"/javase/oo-encapsulation-inheritance-polymorphic-super.html"},{"title":"反射和注解","text":"【摘要】反射和注解~ 前言反射JDK5.0中推出的一个技术点，它的目的就是通过字节码来窥探类的结构。通过反射，我们可以分析一个类的字节码，并且也可以通过这种方式来调用和修改方法、属性。 1234567891011API:java.lang \\- Class \\- Package java.lang.reflect 包 \\- Array 针对数类型的反射工具类 \\- Modifier 修饰符 \\- AccessibleObject \\- Constructor 构造 \\- Method 方法 \\- Field 属性 在学习反射API之前，首先，我们得重新学习 java.lang.Class。这个类，从名字上知道，它是“类”的意思，它是表示 类型的类。这个类是反射的入口[基础]。 所有的类型一旦被JVM加载成功后，都是Class的实例，并且一个类型只有唯一的Class实例。 比如：Teacher类型在JVM中的类型是：ClassAccount类型在JVM中的类型是：Class 不管你创建了多少个Teacher的对象，这些对象在JVM中都共享相同的Class实例 如： 1234Teacher t1 = new Teacher();Teacher t2 = new Teacher();//System.out.println(t1.getClass() == t2.getClass()); //true 获取某个类型在JVM中的Class实例，有如下三种方法： 1234567891011121314151617181920//1. 通过类名.class 来获取Class&lt;Teacher&gt; c = Teacher.class;//2. 通过对象来获取 Teacher t1 = new Teacher();Class&lt;Teacher&gt; c = t1.getClass();//3. 通过Class中的一个静态方法 forName如：Class&lt;Teacher&gt; c = Class.forName(\"Teacher全限定名 \");//例如：public class A { void ma() { ... } void ma(int a, int b) { ... } void mb(double a, double b) { ... }}Class&lt;A&gt; c = A.class;Method m1 = c.getDeclaredMethod(\"ma\",Integer.class, Integer.TYPE);Method m2 = c.getDeclaredMethod(\"ma\"); 下面再来看一段代码。 1234567891011121314151617//1.普通方式创建一个对象Account a = new Account(); //2.通过反射来创建对象Class&lt;Account&gt; c = Class.forName(\"com.xx.xxx.Account\");Account a = c.newInstance(); public class XXXFactory { public static XXX getInstance() { //通过反射 来创建 String cName = \"\"; //也可以从文件中读取[io流] Class&lt;XXX&gt; c = Class.forName(cName); return c.newInstance(); }}//name.txt [大量的配置文件] 可配置[configurable]//com.xx.xx.XXXImpl2 练习：写一个StringUtil类，存放在 util 包中，这里面有如下方法： 12345678public class StringUtil { //通用的toString方法，此方法打印出指定对象中的所有 //属性，格式为：类名[属性名=属性值,属性名=属性值,...] public static String toString(Object obj) { //使用反射去实现 //... }} 注解注解[Annotation]：它也是一种数据类型，与类、接口、枚举一起，是java中4大类型之一。 类 class接口 interface枚举 enum注解 @interface 注：所有的自定义注解都自动继承于 java.lang.annotation.Annotation 接口，而注解在编译完成后，也是字节码，所以，它在JVM中也是Class的实例。如：Class&lt;? extends Annotation&gt; 注解的目的是用来描述数据，更确切地讲，是用代码的方式来描述数据。 如： 1234//限定这个注解将来可以使用在哪些元素上public @interface HaHa { String name() default \"ZhangYao\";} 注：开发注解时，元素的类型只能是：基本类型、字符串、注解、枚举、它们的数组类型。注： 注解开发出来本身是不会产生功能的，它必需要被其它的元素”使用”，哪些元素可以使用注解呢？ 类、属性、方法、局部变量、包、… 当然，你开发注解时，是需要事先指定此注解将来要用在哪些元素上的。这个，你需要使用 元注解 来限定。 元注解，就是用来注解的注解。[修饰注解的] API中提供了以下几个元注解： @Target 只有一个元素，名为 value@Retention 只有一个元素，名为 value@Documented 标记注解 使用注解的语法： 根据你要用的注解的API，查看此注解有哪些元素？ 没有元素的注解叫 标记注解只有1个元素的注解，一般来说，都会把元素名取为 value有多个元素的注解，就是普通注解 根据元素的类型，使用不同的格式，如： String 直接使用 “” 括起来基本类型 直接使用 字面量枚举类型 直接使用 枚举常量值注解类型 使用 @注解名数组类型 使用 {} 括起来,多个元素之间使用, 号隔开 注：我们开发好注解，这个注解本身并不产生作用。要让注解产生作用，要编写注解的解析/处理程序，这个程序就叫 APT,Annotation Parse/Process Tools。 如何开发APT？基于反射。 12345678910API: java.lang.reflect.AnnotatedElement 接口 方法： Annotation[] getDeclaredAnnotations(); Annotation[] getAnnotations(); //包含从父类继承的 boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; c); &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; c); java.lang.annotation.Annotation 接口 Class&lt;? extends Annotaion&gt; annotationType(); 注：默认情况下，父类中所加的注解并不能被子类所继承。除非这个注解使用了@Inherited 元注解去限定。 如： 12345678@HaHapublic class A { }public class B extends A { } 可以看出，B类没有加 @Haha注解，但是，如果在 Haha注解中，使用了：@Inherited修饰的话，则B类中将也可以获取 @HaHa注解。 结束语还没有结束哦~","link":"/javase/reflect-and-annotation.html"},{"title":"UML统一建模语言","text":"【摘要】[UML, Unified Markup Language] 统一标记语言~ 前言hahaha~ UML下载一个工具Jude[jude, astah-community]。这个工具是一个UML工具，它可以画出类图、时序图、流程图等。[UML, Unified Markup Language] 统一标记语言，它是做软件设计的标准表达语言。主要是靠各种符号来表达意思。 类之间的关系首先，我们要学习一下类之间的关系： 纵向关系 继承 使用 实线+三角形 来表示实现 使用 虚线+三角形 横向关系 关联关系 Has A 使用实线+箭头表示聚合 关联关系较弱，是平等的关系，如：客户和订单 被拥有的那边由外界传入，不是由内部创建 实线+空心菱形组合 关联关系较强，是整体和局部的关系，整体拥有局部 实线+实心菱形 依赖关系 Use A 使用虚线+箭头表示 关联关系 Has A如： 12345678910111213141516171819202122public class A { //属性 private int id; //[A has a int] private String hehe; //【A has a String】 private B b; //has a 【A has a B】 private C c; //has a 【A has a C】 public A(int id, B b) { this.id = id; this.b = b; //由外界传入， 则说明 A聚合B this.c = new C(); //由内部创建，则说明 A 组合 C }}public class B { //属性 private int id; //...}public class C { //属性 //...} 依赖关系 Use A如： 123456public interface IA { }public class XXXFactory { //XXXFactory use a IA public static IA getInstance() { .... }} 结束语没有结束哦~","link":"/javase/uml.html"},{"title":"linux常用命令","text":"【摘要】最近使用linux命令有点多，奈何开发长期使用Windows，Linux命令掌握的又不多。因此我必须多学学！ 前言常用命令感觉这个老哥整理的很棒！等有空抄他的！参考博客连接 结束语","link":"/linux/linux-common-commands.html"},{"title":"JDBC详细介绍","text":"【摘要】JDBC详细介绍~ 前言hi~ JDBCJDBC概念JDBC就是为了让java语言有能力去操作数据库，通过它可以发送sql命令，并取得返回的结果。 JDBC, Java Database Connectivity, JAVA数据库互联。ODBC, Open Database Connectivity, 开放式数据库互联。这个标准是由MS公司主导的一个标准，所有的数据库厂商的产品都实现了ODBC规范，并且这个标准是采用c语言编写的。这样一来，程序员可以通过ODBC来访问/操作数据库产品。 java语言刚开始时，也是通过ODBC来访问数据库的，但是，java语言需要把java的调用转换成符合ODBC规范的c调用，这样一来，效率就会很低。 在java语言访问数据库的驱动发展历程中，经历了以下4代 A. JDBC-ODBC桥接B. 本地部份java驱动C. 基于网络的本地部份java驱动D. 本地纯java驱动 [第四代驱动]：所有的DB产品的产品都实现了JDBC规范，使用 java语言写。这个实现也叫 驱动[driver]。 所以，JDBC的API 有两部份组成 是 SUN 公司提供的 JDBC标准接口 和工具类。 java.sql 包[核心包] javax.sql 包[扩展包] JDBC的实现者，也就是各DB厂商的驱动程序。 JDBC有一个很大的优点，就是可以跨DB平台，一次编写，到处[数据库]运行。 JDBC核心包中的核心接口java.sql.Driver 接口 驱动类接口，实现JDBC驱动的数据库产品必需要实现此接口java.sql.DriverManager 驱动管理类，它是连接的桥接器，它可以获取Connection。注：在JDBC4.0规范中，做了修改，可以不需要事先注册驱动了。 12345java.sql.Connection 连接[可以想象成客户端程序与DB之间的网络通道]java.sql.Statement 语句[负责发送和执行sql命令] \\- PreparedStatement 预处理语句[支持动态绑定参数的sql命令] \\- CallableStatement [负责发送和执行 plsql 命令]java.sql.ResultSet 结果集[如果是查询命令，则由此对象负责带回查询的结果] JDBC编程步骤 注册数据库驱动12//DriverManager.registerDriver(具体的驱动类)Class.forName(\"驱动的全限定类名\"); //它仅仅是一个字符串 注：不同的数据库产品，驱动类名不一样，如： Oracle =&gt; oracle.jdbc.OracleDriver mysql =&gt; com.jdbc.mysql.Driver DB2 =&gt; i don’t know sqlserver =&gt; i don’t know … 注：在JDBC4.0规范中，此步可以省略[DriverManager会自动搜索项目的类路径,找到并加载目标驱动，可以有多个] 建立连接1234String url = \"jdbc:oracle:thin:@127.0.0.1:1521:XE\";String user = \"jsd1707\";String pwd = \"jsd1707\";Connection conn = DriverManager.getConnection(url, user, pwd); 创建Statement1Statement stmt = conn.createStatement(); //空参 发送并执行 sql命令1234String sql = \"select id,first_name,salary,start_date from s_emp\"; //准备的sql命令ResultSet rs = stmt.executeQuery(sql); //执行查询语句//boolean b = stmt.execute(sql); //执行任意SQL语句int count = stmt.executeUpdate(sql); //执行非查询语句 如果是查询命令，则处理结果集12345678while(rs.next()) { //循 环读到结果集中的数据 //取列值 int id = rs.getInt(1); //取第一列 String fn = rs.getString(2); double sal = rs.getDouble(3); Date sd = rs.getDate(4); //...} 释放资源 123rs.close();stmt.close();conn.close(); 使用PreparedStatement 来执行sql命令 它的好处： A.可以动态绑定参数，避免了SQL字符串的拼接，更加安全。B.支持预编译，事先把sql送到数据库中编译、优化，然后，给定参数后再执行，如果执行多次话，只需要给出不同的参数即可，SQL本身无需再次编译、优化。 缺点： 一个PreparedStatement只能绑定1条sql命令。 1234567891011121314//String sql = \"select id,name from s_dept where id = ? and name like ?\";PreparedStatement pstmt = conn.prepareStatement(sql); //初始化时要传入sql//在执行之前，要设定参数pstmt.setInt(1,10); //把id的值设为 10pstmt.setString(2, \"hehe\");//String sql = \"select id,name from s_dept\";Statement stmt = conn.createStatement();//rs = stmt.executeQuery(sql);//stmt.executeUpdate(\"another sql command\"); JDBC事务 [transaction]Why use？ 注：当删除主表记录时，如果这个记录有子记录存在，则删除是会失败的。 如果你想在删除主记录时，一起把子记录删除，有如下两种方式 编程式在JDBC代码中，先删除子记录，再删除主记录，如： 1234delete from tbl_emp where dept_id = ?;delete from tbl_dept where id = ?--这两个?处的值是一样的。 注：这种方式有一个很大的缺点，就是 牵一发而动全身。 就在建表时，指定外键在删除时的处理方式当我们在添加外键约束时，可以指定如下两个选项： A. ON DELETE CASCADEB. ON DELETE SET NULL如： 1234567891011create table tbl_dept( id number primary key, name varchar2(255));create table tbl_emp( id number primary key, ..., dept_id number, --添加外键 foreign key(dept_id) references tbl_dept(id) ON DELETE CASCADE); JDBC事务概念JDBC事务 [transaction]为了让JDBC跨多个数据库平台，JDBC规范中必然要制定出它自己的事务规范，因为不同的数据库对事务的粒度控制是不一样的。 比如：ORACLE中不允许有脏读，但是，在mysql中可以【需要设置】，它们的级别也不一样，这对于我们编写JDBC程序来说，就比较麻烦。 所以，我们程序人员就针对JDBC事务做出处理，而不是去编写与数据库产品相关的事务代码，在JDBC规范中，提供了事务的隔离级别的控制。 在Connection接口中，定义了5个常量来分别表示不同的JDBC事务隔离级别： 12345TRANSACTION_NONE 0TRANSACTION_READ_UNCOMMITTED 1TRANSACTION_READ_COMMITTED 2TRANSACTION_REPEATABLE_READ 4TRANSACTION_SERIALIZABLE 8 其中，它们由数据库产品进行实现。注：设置连接的事务隔离级别不一定有效果。 在Connection中，提供了方法：setTransactionIsolation(int level) 来设置级别。 另外，在JDBC中，默认情况下，事务是自动提交的[Auto Commit]。也就是执行一次sql命令，就自动提交事务一次。 如果你想手动控制事务，则需要： 1234conn.setAutoCommit(false); //conn.commit(); //手动提交conn.rollback(); //手动回滚 JDBC批处理[Batch]JDBC从2.0规范开始，就支持批处理了，它的目的是为了提高数据插入的效率。利用它，可以高效地插入海量的数据到表中。1.利用Statement执行批处理 1234567891011//Code:String sql1 = \"\";String sql2 = \"\";String sql3 = \"\";//...//我们可以把这些sql命令通过 addBatch方法添加到批处理命令列表中。stmt.addBatch(sql1);stmt.addBatch(sql2);stmt.addBatch(sql3);//...int[] results = stmt.executeBatch(); 所以，Statement的批处理适合用来加载并执行sql脚本文件中的命令。 2.利用PreparedStatement 来做批处理 1234567891011//CodeString sql = \"insert into tbl_dept(id,name) values(?,?)\";//PreparedStatement pstmt = conn.prepareStatement(sql);//绑定参数pstmt.setString(2,xxx);//把这组参数添加到 批处理中pstmt.addBatch();//...//执行批处理int[] result = pstmt.executeBatch(); 所以，PreparedStatement 适合用来批量插入同一种结构的数据. 注：select命令是不能使用批处理的。 针对PreparedStatement123456789//CodeConnection conn = ....;String sql = \"select id,name from tbl_dept\";PreparedStatement pstmt = conn.prepareStatement( ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE, sql);//通过此PreparedStatement 执行的查询结果集是可以滚动、可以更新的。//... JDBC元数据元数据的定义: 用来描述其它数据的数据。它的API有： 123456789101112DatabaseMetaData 数据库元数据 它描述了数据库相关的数据 ResultSetMetaData 结果集元数据 它描述了结果集相关的数据。 getColumnCount() 得到此结果集中的总列数 getColumnName(int index) getColumnType(int index) =&gt; int 详见API: Types ...ParameterMetaData 参数元数据 与存储过程【PLSQL】调用有关的元数据。 sql异常sql异常概述java.sql.SQLException 【已检查异常】它是JDBC规范中顶级的异常，所有的JDBC异常都是继承于此类，如： 1234567891011 SQLSyntaxErrorException 执行sql的语法有错误 SQLIntegrityConstraintViolationException SQLFeatureNotSupportedException SQLInvalidAuthorizationSpecException SQLTimeoutException BatchUpdateException ...SQLException的其它方法 getErrorCode(); getNextException(); 如 123456789101112try { ... ...} catch (SQLException e) { //获取此sql异常的错误码 int code = e.getErrorCode(); //如果想把整个异常链都显示出来 while(e != null) { e.printStackTrace(); e = e.getNextException(); }} 有关批处理的异常12BatchUpdateException int[] getUpdateCounts(); 连接池 [connection pools]概念它是一种维护多个数据库连接的对象，也就是一种数据源的实现方式。在实际的开发中，连接池是比较常用的，因为它能够大大提高连接的使用效率。正是因为普通的数据库连接使用效率太低，所以，JDBC规范中提出了连接池，它通过javax.sql.DataSource这个对象来做为获取连接的标准。 DataSource 数据源，它是一个规范[接口]，它有三种实现： 1.普通实现，也就是 DriverManager获取连接的方式2.连接池实现3.分布式事务实现 获取连接的方式我们现在获取连接的方式： 123Connection conn = DriverManager.getConnection(url,user,pwd);//...conn.close(); //用完后，就关闭【也就是与RDBMS真正的断开连接】 连接池的实现一般我们第三方的实现，如： Apache组织的 commons-dbcp 组件就一个开源的连接池实现。或者是一些轻量级的中间件产品，如：Tomcat/Jetty/Resin… 有了数据源，我们获取连接的方式： 12数据源 数据源 = ...;Connection conn = 数据源.getConnection(); 所以，问题变成了我们在代码中如何得到 数据源对象？ 主流的方式： 通过 JNDI 来获取[要有中间件、容器的支持]备选方式：下载第三方的实现者，并通过API来创建. 有关commons-dbcp 组件12345678910111213141516核心类： BasicDataSource//代码片断BasicDataSource bds = new BasicDataSource();//给这个数据源设置相关的属性bds.设置驱动类bds.设置URLbds.设置用户名bds.设置密码//与池有关的属性bds.设置初始池的大小bds.设置池的最大连接数bds.设置池的最小连接数bds.设置获取连接的最大等待时长bds.设置连接的最大空闲时间//... 分布式事务的实现它是基于连接池的，它更加复杂，一般也是由第三方提供，而且免费的产品不多，大多都是商业化的、收费的产品，如： 12345IBM WebshereORACLE weblogicJBOSS JBOSS ASoracle glassfish [免费的]... 它的两个核概念 1.中央事务管理器2.二阶段提交 [two phase commit] 结束语bye~","link":"/jdbc/jdbc.html"},{"title":"linux查看系统版本命令","text":"【摘要】想备份一下服务器上的文件和程序到另一台上，担心移植过去的文件程序会跑不起来。就去网上搜了搜一些查看自己系统版本信息的命令，来看一下自己安装的linux是哪个版本的。 前言虽然很简单，还是想记录一下。 查看Linux内核版本命令(两种)方法一： 12[root@zhangyaopc /]# cat /proc/versionLinux version 3.10.0-957.5.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Fri Feb 1 14:54:57 UTC 2019 方法二： 12[root@zhangyaopc /]# uname -aLinux zhangyaopc 3.10.0-957.5.1.el7.x86_64 #1 SMP Fri Feb 1 14:54:57 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 查看Linux系统版本命令(三种)方法一：lsb_release -a，即可列出所有版本信息。这个命令适用于所有的Linux发行版，包括RedHat、SUSE、Debian…等发行版。 123456[root@zhangyaopc /]# lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 7.6.1810 (Core) Release: 7.6.1810Codename: Core 方法二：cat /etc/redhat-release，这种方法只适合Redhat系的Linux。 12[root@zhangyaopc /]# cat /etc/redhat-releaseCentOS Linux release 7.6.1810 (Core) 方法三：cat /etc/issue，此命令也适用于所有的Linux发行版。 123[root@zhangyaopc /]# cat /etc/issue\\SKernel \\r on an \\m 结束语不积跬步无以至千里。加油！","link":"/linux/linux-view-system-version.html"},{"title":"Java多线程入门","text":"【摘要】Java多线程入门~ 前言0到1是最难的，1到100都是慢慢的积累。 相关概念进程[Process]：线程[Thread]： 线程实现继承Thread类实现Runnable接口 实现Callable接口 JUC[java.util.concurrent] 线程状态四种原因进入就绪四种原因进入阻塞 线程停止stopThread_study02.com.sxt.state.TerminateThread 线程暂停sleepThread_study02.com.sxt.state.BlockSleep01Thread_study02.com.sxt.state.BlockSleep02Thread_study02.com.sxt.state.BlockSleep03 线程礼让yieldThread_study02.com.sxt.state.YieldDemo01Thread_study02.com.sxt.state.YieldDemo02 线程插队joinThread_study02.com.sxt.state.BlockJoin01Thread_study02.com.sxt.state.BlockJoin02 Thread.State就绪和运行都叫runableThread_study02.com.sxt.state.AllState 优先级Thread_study02.com.sxt.state.PriorityTest 守护线程Thread_study02.com.sxt.state.DaemonTest 其他方法 线程非同步并发：同一个对象多个线程同时操作。Thread_study02.com.sxt.syn.UnsafeTest01Thread_study02.com.sxt.syn.UnsafeTest02Thread_study02.com.sxt.syn.UnsafeTest03 线程同步资源：酒店、锁：房卡、等待队列和锁对象锁this锁Class锁方法、块 同步方法Thread_study02.com.sxt.syn.SynTest01成员方法锁this,因为成员方法是对当前this中对象的属性(资源)操作。同步块Thread_study02.com.sxt.syn.SynBlockTest01Thread_study02.com.sxt.syn.SynBlockTest02Thread_study02.com.sxt.syn.SynBlockTest03 HappyCinema.javaHappyCinema2.java 使用同步方法Happy12306.java 并发容器SynContainer.javaCopyOnWriteArrayList.java 死锁—哲学家就餐DeadLock.java 生产者消费者模式生产者消费者 管程法Thread_study04.com.sxt.cooperation.CoTest01.java 信号灯法Thread_study04.com.sxt.cooperation.CoTest02.java 高级主题任务定时调度Thread_study04.com.sxt.others.TimerTest01 quartzThread_study04.com.sxt.others.HelloJobThread_study04.com.sxt.others.QuartzTest HappenBeforeThread_study04.com.sxt.others.HappenBefore 结束语 创建线程的两种方式继承Thread类实现Runnable接口实现Callable接口 模拟一份资源 多个代理 ssPV page viewUV unique viewVV visit view 只要忙就是因为笨，只要痛苦就是因为傻。","link":"/multi-thread/multi-thread.html"},{"title":"常见Dos命令","text":"【摘要】常见Dos命令 123456cd 目录路径 进入一个目录cd .. 进入父级目录dir 查看本目录下的文件和子目录列表cls 清屏命令上下键 查找敲过的命令tab键 自动补齐命令","link":"/other/common-dos-commands.html"},{"title":"我曾七次鄙视自己的灵魂","text":"【摘要】《我曾七次鄙视自己的灵魂》是 纪伯伦以“自己的灵魂”为名，看穿人性所共有弱点的一首诗。诗句简单有力发人深省，督促人们拥有更高的精神境界，呼吁人们涤荡自己的灵魂，唾弃丑恶，追求高尚。 我曾七次鄙视自己的灵魂 第一次，当它本可进取时，却故作谦卑； 第二次，当它在空虚时，用爱欲来填充； 第三次，在困难和容易之间，它选择了容易； 第四次，它犯了错，却借由别人也会犯错来宽慰自己； 第五次，它自由软弱，却把它认为是生命的坚韧； 第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副； 第七次，它侧身于生活的污泥中，虽不甘心，却又畏首畏尾。 Seven times have I despised my soul: ——Kahlil Gibran The first time when I saw her being meek that she might attain height. The second time when I saw her limping before the crippled. The third time when she was given to choose between the hard and the easy, and she chose the easy. The fourth time when she committed a wrong, and comforted herself that others also commit wrong. The fifth time when she forbore for weakness, and attributed her patience to strength. The sixth time when she despised the ugliness of a face, and knew not that it was one of her own masks. And the seventh time when she sang a song of praise, and deemed it a virtue.","link":"/other/seven-times-have-i-despised-my-soul.html"},{"title":"励志文《我们都不是神的孩子》","text":"【摘要】励志文《我们都不是神的孩子》’ 《我们都不是神的孩子》 ——致我们的青春 我不知道该用什么词语来形容那段成就我2007年梦想的日子，语言总会在某种程度上限制情感的表达。高三的生活同样夹杂着很多的味道，让每一个认真走过了得人无法再回首时说完其中的情感。一个个相似却不相同的日子在我现在的脑海里已经成为回忆：空气中恒久漂浮着的粉笔屑，擦了有些写了又擦不停更换的板书，班主任用来指点江山激扬文字的神棍，数学课上江西一道题 数学课上讲析一道题目N遍，我们还没弄懂时老师恨铁不成钢的郁闷表情，我和我的同学抱着彼此或大或小但都很遥远的梦想，每天近乎麻木的努力做做一个称职的没有一丁点歪思邪念的高三生。庆幸在那些一无所有的日子。我们永不放弃的梦想照亮了在路上的我们。 ​ 每个人都有歇斯底里的本源 从初中开始，我的梦，就是复旦大学。高中了，我似乎感觉伸出双手就可以碰触到我的梦想，每天无数次被灌输高考这个概念，除了背水一战，我别无选择。我在床头的小柜子上刻了几个大字：杀进复旦!到现在我还记得那时的我“杀气腾腾信誓旦旦”的样子。每天起床后我就默念一次。我老老实实，安安静静地过着同样的生活，心如止水。追星、旅游，疯狂网上购物，八卦，恋爱问题„„都被我忍痛抛弃了，长达7年的q龄也戛然而止。我真的不是一个能一边娱乐一边学习的人，厌倦总是有的，偶尔也为自己的小成功沾沾自喜。我对梦想的疯狂在初入高三时达到了极限，所有的一切都在高考来临之际幻化成自己早已认定的那个大学之梦，梦想的动力强大得让我踌躇满志跃跃欲试。 从老师公布高考复习进度表开始，我就拿出全新的本子开始记录我的高三。在第一页上，只有几个字：复旦，等着我!第二页，也只有一行字：我的高考目标——650分以上。第三页，是一段话：“我知道，一切都会有的。我会拥有大考小考的失败，但永远不会放弃努力与梦想。环境只能影响我，不能决定我的未来。决定我的未来只有我自己。踏踏实实做好手边的事，努力让梦想照进现实。”这三页，一直默默地支撑我整个的高三生活。就如我高中老师说的：飞不飞得出这漫漫大山，就看这次高考了。许多有梦想的同学和我一样在心中默念着“必须赢下这场这场战役”! 高三上学期，10月份，第一次月考来临，也是从那刻起我开始感到高考的真实。国庆放假的几天，我一天也不敢迈出家门，从祖国生日那天开始，一直到4天后放假结束，每天早上7点起床，一直做作业到凌晨1点，其中的吃饭和午休都在书桌上完成。我闷在家里狠命学习，睁开眼睛想到的第一件事就是怎么做好头天晚上没完成的数学题，累了就幻想着拿到复旦大学录取通知书的情景。我真的那样癫狂地甘愿做一个最老实的学生„„后来我才知道，每个人都有歇斯底里的本源。我想，那年10月，我曾经歇斯底里过。 做个会思考的书呆子又何妨呢? 月考过后，学校的宣传栏热闹起来，上面写着许多关于高三的榜单和通知。我只站在那里发愣，明白了自己贴在书桌上的那句话不再有故做姿态的意味。高中，不是要求你做到在生活中学习，也不是让学习渗透到生活中去，而是要在任何时候都不能忘记学习，尽量让自己在每一个时间段里都有所得，所得的一定要利于高考。“为了高考，做个会思考的书呆子又何妨呢?”我想着。每天的日子在不停地重复，简单充实，略显乏味。但是没有关系，我愿意，一切都值得! 早晨，爬到学校五楼教室时我气喘吁吁睡眼朦胧，困了我就扯我同桌问问题：“把唐朝的文化史介绍一下„„”或者面对着成堆发下来的还飘着油墨味的复习资料，有点神经质地发牢骚：“最近纸张是不是降价了，以至于学校毫不吝啬地发了这么多?”随后，在座位上翘着脚忘乎所以地抱着书捏着笔拼命背历史，分朝代和专题背，背到连书都想扔到窗外去;中午吃饭时嘴里塞着饭同时翻看着下一步的学习任务，把自己想得比国家总理还忙;操场上集体晨跑，还逼自己边跑边背古文;晚上做一大堆数学题，像许多文章里面描述的一样，旁边放着一杯水，我也没喝过几次，或许仅仅是一个象征性的东西罢了„„这是我的一天，我不知道这样的一天会不会让别人很“鄙视”和觉得太夸张了，受不了。但我真的是这么过来的，我是一个寻常的高中生，深陷在高中三年里，只知道机械般地吃着饭，上着课，做着题，平静得如同家乡的小城，永远都不会有什么大事发生。 苦，是从来不会白吃的 临近高考那段时间，各种各样品种繁多的试卷如约而至，轮番轰炸，躲都躲不了。月考已经不算什么了，每周一大考，三天一小考，这还只是学校的硬性规定，各科老师还商量着什么时候时机对头了再来和同学们用试卷“交流交流以保持战斗力”。从下学期开始我们年级的课程表全面改版，两节课连堂上那绝对是正常情况。我们每天都会交上n张密密麻麻地聚集了自己近一年复习心血的试卷，也会收获n张批了鲜红分数的试卷。分数，这个具有强烈刺激性质又很值钱的家伙，在那年的春天，它的魄力足以让包括我在内的所有高三学生震慑不已，即爱又恨。虽然我早已“身经百战软磨硬泡”地成为了考试老手，可遇到考试我还是担心考不到好成绩，“百炼没有成钢”的郁闷笼罩着每一次将来的测试：感觉自己为数学付出了许多个白天和黑夜，却没得到期望中的红苹果。文科综合也是我刺痛我神经的一科，4分一道的选择题，十几分一道的简答题，稍微一疏忽就眼睁睁地看着好好的分数突然没了，像错过一场华丽的邂逅，最终一无所获。可即使这样，我依旧每天嚷嚷着要考复旦，依旧每天拿着繁多的试卷仔细地做着，因为我的选择是没得选择，所以我一直学啊学„„ 我喜欢有周期地学习，我的学习计划性非常强。一般月考前两个星期，我就会抽出一天时间把这两个星期每天的日程都填满，一步步循序渐进地复习，每科每天的任务都会很重。月考前的那两个星期是我最累的时候，因此每一次月考后我都会犒劳自己一次，不管考得好与坏，只要我尽了最大的努力去复习。我一直都奉行着“苦，是从来不会白吃的”原则。我是超级shopping迷，饰品店是我的最爱，越是考不好，我就越喜欢把自己打扮得漂漂亮亮的，让自己拥有美丽的小心情，然后躲在小房间里用塔罗牌和自己游戏，玩到我满意为止，那是一件总是让我充满期待与惊奇的事情，这也许算是我高考无趣生活中最好的点缀。生活总得有点希望，比如你在狠命学习的时候，潜意识里要告诉自己，过了这个坎儿，会有一件很美好的事情等着你，这时效率就会高很多，再难熬的分分秒秒也会觉得值得。 成绩下来后,面对着“状元”的身份，老师和爸妈的脑子里全是“北大北大”，一时间我自己变得不知所措，我终究放弃了我最初的梦想复旦，选择了北大，北大的魄力对于每个高三生来说都是不可抗拒的。咨询会那天，我特意去了复旦大学的展位看了好久，然后转身默默离开„„ 我们都不是神的孩子，我们只是有梦的孩子 高考后我整理了一年来用过的各种复习资料。学校印发的各科试卷拥挤着占满了半个书架，自己去书店 买的套题(就是那种一套一套的类型试卷和习题集)：语文83套，英语52套，数学65套，文科综合95套，除了文科综合的简答题没有全部做完，其他试卷和套题都用红蓝黑三种颜色的笔记录了很多的笔记及注意事项，4本数学资料书，我从头到尾看了5遍，每一本都写着日期和我的心情;英语的专项练习，阅读做了两大本，完型填空3本，语法及其他单项训练3本，历史5本课本，背了7、8次，地理的地图，剪切了满满一本，被我剪成可以装在口袋里的大小„„别人总觉得我一直都是那么优秀的和一帆风顺的，其实只有我自己知道我的生活是怎样的，虽然我一点都不觉得痛苦，但辛酸还是包裹住我的身体，包裹住那个阳光灿烂的日子里想哭的我。想起了在数学遭遇瓶颈期时，把自己关在房间里整整两天都没去学校面对着墙壁发呆六神无主的崩溃样子。我一次次告诉自己这是上帝的巧妙安排，他让我在高考前吃尽了苦头，这样我就可以在高考中顺利过关了，也一次次在彷徨和迷茫中走了过来，因为我一直相信，我们的未来都不是梦，未来的成功与每个人都是等距离的，从来只有拼出来的美丽，没有等出来的辉煌。现在我不知道该怎么说我的学习方法，我无学习方法，只有做法，我的做法就是一叠加一叠的“题海战术”和一轮加一轮的总结(包括学习总结和错题总结)。 “一颗心，是绝对不会因为追求梦想而受伤的。求学之路的失落与得意、清晰与迷茫，最简单的在于你拥有一个什么样的心境。努力中会有失败，会有失去勇气的时候，但我必须努力，我正在努力，我需要坚强，需要沉默，需要意志。一切都只是过程，成功与快乐才是终点。生活可以是无趣的，但自己一定要快乐。我们都不是神的孩子，我们只是有梦的孩子。”高考后，我以此纪念我的高三。我决定在北大，在更远的未来，继续我“无趣”的生活，用微笑做面纱，像蜗牛般成长。","link":"/other/we-are-not-gods-children.html"},{"title":"Redis介绍和安装","text":"【摘要】目前，我们查看Java岗位的招聘信息中几乎都会发现redis这个关键字，所有的互联网公司在开发产品中也都会使用到redis。所以对于一头Java社畜来说掌握redis就像是鱼儿离不开水一样，因此我想要整理一下关于redis的学习笔记。废话不多讲，本篇就来介绍一下它，什么是redis？使用redis有什么好处？如何安装redis？ 前言Redis介绍参考链接 Github开源地址官网中文官网 Redis安装Windows环境下参考链接 Linux环境下参考链接首先讲一下，我选择的是CentOS 7.x和Redis 5.x。下面就开始记录redis的安装和使用过程。 1.下载和编译首先创建一个你用来存放redis的文件夹，我是在/home路径下创建的redis-install文件夹。然后去redis官网获取下载链接，使用wget进行下载。下载完成后，解压文件。进入刚刚解压的目录redis-5.0.8/中，查看README.md文件，这个文件里面藏着一堆宝藏。命令vi README.md从README.md文件我们知道可以使用make编译redis，当编译失败可能是因为你的系统上没有gcc环境。使用make distclean删除编译失败的文件。编译成功后，就进入下面的安装过程。12345678910111213[root@zhangyaopc home]# mkdir redis-install[root@zhangyaopc home]# cd redis-install[root@zhangyaopc redis-install]# yum install wget -y这边会有一堆下载提示信息[root@zhangyaopc redis-install]# wget http://download.redis.io/releases/redis-5.0.8.tar.gz这边会有一堆下载提示信息[root@zhangyaopc redis-install]# tar xf redis-5.0.8.tar.gz[root@zhangyaopc redis-install]# cd redis-5.0.8/ &amp;&amp; vi README.md[root@zhangyaopc redis-5.0.8]# make这边会有一大堆提示信息，如果失败可能是你的系统缺少gcc环境[root@zhangyaopc redis-5.0.8]# yum install gcc -y[root@zhangyaopc redis-5.0.8]# make distclean这边会有一大堆提示信息 2.安装把redis安装到指定目录12345678910[root@zhangyaopc redis-5.0.8]# make PREFIX=/usr/local/redis install #安装到指定目录中,也可以使用自己创建的目录[root@zhangyaopc redis-5.0.8]vi /etc/profile G export REDIS_HOME=/usr/local/redis export PATH=$PATH:$REDIS_HOME/bin source /etc/profile[root@zhangyaopc redis-5.0.8]cd utils[root@zhangyaopc redis-5.0.8]./install_server.sh[root@zhangyaopc redis-5.0.8]service redis_6379 status 结束语","link":"/redis/redis-introduce-and-install.html"},{"title":"七、微服务分布式电商系统--分布式基础篇总结","text":"【摘要】分布式基础篇总结~ 前言//… 分布式基础篇总结 1.分布式基础概念 微服务、注册中心、配置中心、远程调用、Feign、网关 2.基础开发 SpringBoot2.0、SpringCloud、Mybatis-Plus、Vue组件化、阿里云对象存储 3.环境 Vagrant、Linux、Docker、MySQL、Redis、逆向工程&amp;人人开源 4.开发规范 数据校验JSR303、全局异常处理、全局统一返回、全局跨域处理 枚举状态、业务状态码、VO与TO与PO划分、逻辑删除 Lombok：@Data、@Slf4j","link":"/shop-mall/distributed-foundation-summary.html"},{"title":"八、Elasticsearch","text":"【摘要】elasticsearch~ Elasticsearch简介https://www.elastic.co/cn/what-is/elasticsearch全文搜索属于最常见的需求，开源的Elasticsearch是目前全文搜索引擎的首选。它可以快速地储存、搜索和分析海量数据。维基百科。Stack Overflow、Github都采用它。Elastic的底层是开源库Lucene。但是，你没有办法直接用Lucene，必须自己写代码区调用它的接口。Elastic是Lucene封装的，提供了REST API的操作接口，开箱即用。REST API：天然的跨平台。官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html官方中文：https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html社区中文：http://elasticsearch.cn 基本概念Index(索引)动词，相当于MySQL中的insert；名词，相当于MySQL中的Database； Type(类型)在Index(索引)中，可以定义一个或多个类型。类似于MySQL中的Table；每一种类型的数据放在一起； Document(文档)保存在某个索引(Index)下，某种类型(Type)的一个数据(Document)，文档是JSON格式的，Document就像是MySQL中的某个Table里面的内容。 Docker上安装es下载镜像文件12docker pull elasticsearch:7.4.2 # 存储和检索数据docker pull kibana:7.4.2 # 可视化检索数据 free -m 可以查看linux内存使用情况。 创建实例Elasticsearch12345678910111213141516mkdir -p /mydata/elasticsearch/configmkdir -p /mydata/elasticsearch/dataecho \"http.host:0.0.0.0\"&gt;&gt;/mydata/elasticsearch/config/elasticsearch.ymldocker run --name elasticsearch \\-p 9200:9200 -p 9300:9300 \\-e \"discovery.type=single-node\" \\-e ES_JAVA_OPTS=\"-Xms64m -Xmx128m\" \\-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \\-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\-d elasticsearch:7.4.2chmod -R 777 /mydata/elasticsearch/ # 文件权限设置docker restart elasticsearch7.4.2 以后在外面安装好插件重启即可。特别注意：-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx128m&quot;测试环境下，设置ES的初始内存和最大内存，否则导致过大启动不了ES。 使用PostMan测试ElaticSearch Kibana1docker run --name kibana -e ELASTICSEARCH_URL=http://119.23.25.235:9200 -p 5601:5601 -d kibana:7.4.2 初步检索_catGET /_cat/nodes ：查看所有节点GET /_cat/health ：查看es健康状况GET /_cat/master ：查看主节点GET /_cat/indices ：查看所有索引 show databases; 索引一个文档(保存)保存一个数据，保存在哪个索引的那个类型下面，指定用哪个唯一标识。PUT customer/external/1 在customer索引下的external类型下保存1号数据为 123{ \"name\":\"Zhang Yao\"} PUT和POST都可以。POST新增，如果不指定id，会自动生成id。指定id就会修改这个数据，并新增版本号。PUT可以新增可以修改。PUT必须指定id，由于PUT需要指定id，我们一般都用来做修改操作，不指定id会报错。 查询文档1234567891011121314GET customer/external/1结果{ \"_index\": \"customer\", //在哪个索引 \"_type\": \"external\", //在哪个类型 \"_id\": \"1\", //记录id \"_version\": 3, //版本号 \"_seq_no\": 2, //并发控制字段，每次更新就会+1，用来做乐观锁 \"_primary_term\": 1, //同上，主分片重新分片，如重启，就会变化 \"found\": true, \"_source\": { //真正的内容 \"name\": \"Zhang Yao\" }} 更新携带 ?if_seq_no=0&amp;if_primary_term=1类似MySQL中的乐观锁。 更新文档123456POST customer/external/1/_update{ \"doc\":{ \"name\":\"Yao\" }} 或者 1234POST customer/external/1{ \"name\":\"Zhang Yao 2\"} 或者 1234PUT customer/external/1{ \"name\":\"Zhang Yao 2\"} 不同：POST操作会对比与源文档数据，如果相同不会有什么操作，文档version不增加；PUT操作总会将数据重写保存并增加version版本。带_updata对比元数据重新保存并增加version版本；看场景：对于大并发更新，不带update;对于大并发查询偶尔更新带update;对比更新，重写计算分配规则。 更新同时增加属性 1234POST customer/external/1/_update{ \"doc\":{\"name\":\"Yao\",\"age\":23}} PUT和POST(不带_update)也可以。 删除文档&amp;索引DELETE customer/external/_bulkDELETE customer bulk批量API123456789101112131415161718192021POST customer/external/_bulk{\"index\":{\"_id\":\"1\"}}{\"name\":\"Yao 1\"}{\"index\":{\"_id\":\"2\"}}{\"name\":\"Yao 2\"}语法格式{action:{metadata}}\\n{request body}\\n{action:{metadata}}\\n{request body}\\n复杂实例POST /_bulk{\"delete\":{\"_index\":\"website\",\"_type\":\"blog\",\"_id\":\"123\"}}{\"create\":{\"_index\":\"website\",\"_type\":\"blog\",\"_id\":\"123\"}}{\"title\":\"my first blog post\"}{\"index\":{\"_index\":\"website\",\"_type\":\"blog\"}}{\"title\":\"my second blog post\"}{\"update\":{\"_index\":\"website\",\"_type\":\"blog\",\"_id\":\"123\"}}{\"doc\":{\"title\":\"my updated blog post\"}} 样本测试数据导入测试数据POST /bank/account/_bulk测试数据 设置es开机自启docker update 17b4e7fcb342 --restart=always 进阶检索SearchAPIhttps://www.elastic.co/guide/en/elasticsearch/reference/7.x/getting-started-search.htmlES支持两种基本方式检索： 一个是通过使用REST request URI 发送搜索数据 (uri+检索参数) 另一个是通过使用 REST request body来发送他们 (uri+请求体) 检索信息GET bank/_search?q=*&amp;sort=account_number:asc 一切检索从_search开始GET bank/_search ：检索bank下所有信息，包括type和docsGET bank/_search?q=*&amp;sort=account_number:asc ：请求参数方式检索响应结果解释：took – Elasticsearch执行搜索的时间(毫秒)time_out – 告诉我们搜索是否超时_shards – 告诉我们多少个分片被搜索了，以及统计成功/失败的搜索分片hits – 搜索结果hits.total – 搜索结果hits.hits – 实际的搜索结构数组(默认为前10的文档)_source – 结果的排序key(键)(没有则按score排序)_score和max_score – 相关性得分和最高得分(全文检索用) uri+请求体进行检索 12345678910111213GET bank/_search{ \"query\": { \"match_all\": {} }, \"sort\": [ { \"balance\": { \"order\": \"desc\" } } ]} HTTP客户端工具(PostMan)，GET请求不能携带请求体，我们变为POST也是一样的。我们POST一个JSON风格的查询请求体到_search API。需要了解，一旦搜索的结果被返回，Elasticsearch就完成了这次请求，并且不会维护任何服务端的资源或者结果的cursor(游标)。 Query DSL基本语法格式Elasticsearch提供了一个可以执行查询的JSON风格的DSL(domain-specific language领域特定语言)。这个被称为Query DSL。该查询语言非常全面，并且刚开始的时候感觉有点复杂，真正学好它的方法是从一些基本的示例开始的。 一个查询语句的典型结构123456{ QUERY_NAME:{ ARGUMENT:VALUE, ARGUMENT:VALUE,... }} 如果是针对某个字段，那么他的结构如下：12345678{ QUERY_NAME:{ FIELD_NAME:{ ARGUMENT:VALUE, ARGUMENT:VALUE,... } }} 示例：123456789101112131415GET bank/_search{ \"query\": { \"match_all\": {} }, \"from\": 0, \"size\": 5, \"sort\": [ { \"balance\": { \"order\": \"desc\" } } ] } query定义如何查询match_all查询类型【代表查询所有的所以】，es中可以在query中组合非常多的查询类型完成复杂查询。除了query参数之外，我们也可以传递其他的参数以改变查询结果。如sort和size。from+size限定，完成分页功能。sort排序，多字段排序，会在前序字段相等时后续字段内部排序，否则以前序为准。 返回部分字段1234567891011121314151617181920GET bank/_search{ \"query\": { \"match_all\": {} }, \"sort\": [ { \"balance\": { \"order\": \"desc\" } } ], \"from\": 5, \"size\": 5, \"_source\": [ \"account_number\", \"balance\", \"firstname\" ]} match[匹配查询] 基本类型(非字符串)，精确匹配 12345678GET bank/_search{ \"query\": { \"match\": { \"account_number\": \"20\" } }} match返回account_number=20的。 字符串，全文检索 12345678GET bank/_search{ \"query\": { \"match\": { \"address\": \"mill\" } }} 最终查询出address中包含mill单词的所有记录。match当搜索字符串类型的时候，会进行全文检索，并且每条记录有相关性得分。 字符串，多个单词(分词+全文检索) 12345678GET bank/_search{ \"query\": { \"match\": { \"address\": \"mill road\" } }} 最终查询出address中包含mill或者road或者mill road的所有记录，并给出相关性得分。 match_phrase[短语匹配]当需要匹配的值当成一个整体单词(不分词)进行检索。 12345678GET bank/_search{ \"query\": { \"match_phrase\": { \"address\": \"mill road\" } }} 查出addres中包含mill road的所有记录，并给出相关性得分。 multi_match[多字段匹配]123456789GET bank/_search{ \"query\": { \"multi_match\": { \"query\": \"mill\", \"fields\": [\"address\",\"city\"] } }} address或者city包含mill。 bool[复合查询]bool用来做复合查询；复合语句可以合并任何其他查询语句，包括复合查询，了解这一点是很重要的。这就意味着，复合语句之间可以互相嵌套，可以表达非常复杂的逻辑。 must：必须达到must列举的所有条件。 should：应该达到should列举的条件，如果达到会增加相关性的评分，并不会改变查询的结果。如果query中只有should且只有一种匹配规则，那么should的条件就会被作为默认匹配条件而去改变查询结果。 must_not：必须补上指定的情况。123456789101112131415161718192021222324252627282930313233GET bank/_search{ \"query\": { \"bool\": { \"must\": [ { \"match\": { \"gender\": \"M\" } }, { \"match\": { \"address\": \"mill\" } } ], \"must_not\": [ { \"match\": { \"age\": \"28\" } } ], \"should\": [ { \"match\": { \"lastname\": \"Wallace\" } } ] } }} address包含mill，并且gender是M，如果lastname里面有Wallace最好不过，但是age必须不是20。 filter[结果过滤]并不是所有的查询都需要产生分数，特别是那些仅用于”filtering”(过滤)的文档。为了不计算分数Elasticsearch会自动检查场景并优化查询的执行。 1234567891011121314151617GET bank/_search{ \"query\": { \"bool\": { \"filter\": [ { \"range\": { \"age\": { \"gte\": 18, \"lte\": 30 } } } ] } }} term[结果过滤]和match一样，匹配某个属性的值。全文检索字段用match，其他非text字段匹配用term。 12345678GET bank/_search{ \"query\": { \"term\": { \"balance\": \"32838\" } }} aggregations[执行聚合]聚合提供了从数据中分组和提取数据的能力。最简单的聚合方法大于等于SQL GROUP BY和SQL聚合函数。在Elasticsearch中，您有执行搜索返回hits(命中结果)，并且同时返回聚合结果，把一个响应的所有hits(命中结果)分隔开的能力。这是非常强大且有效的，您可以执行查询和多个聚合，并且在一次使用中得到各自的(任何一个的)返回结果，使用一次简洁和简化的API来避免网络往返。 搜索address中包含mill的所有人的年龄分布以及平均年龄，但不显示这些人的详情。 123456789101112131415161718192021222324252627282930313233343536GET bank/_search{ \"query\": { \"match\": { \"address\": \"mill\" } }, \"aggs\": { \"ageAgg\": { \"terms\": { \"field\": \"age\", \"size\": 10 } }, \"ageAvg\": { \"avg\": { \"field\": \"age\" } }, \"balanceAvg\": { \"avg\": { \"field\": \"balance\" } } }, \"size\": 0}---------------size:0 不显示搜索数据aggs:执行聚合。聚合语法入下。\"aggs\": { \"aggs_name 这次聚合的名字，方便展示在结果集中\": { \"AGG_TYPE 聚合的类型(avg,term,terms)\"{} }} ex: 123456789101112131415161718192021GET bank/_search{ \"query\": { \"match_all\": {} }, \"aggs\": { \"ageAgg\": { \"terms\": { \"field\": \"age\", \"size\": 100 }, \"aggs\": { \"ageAvg\": { \"avg\": { \"field\": \"balance\" } } } } }} 复杂：按照年龄聚合，并且请求这些年龄段的这些人的平均薪资 123456789101112131415161718192021222324252627282930313233GET bank/_search{ \"query\": { \"match_all\": {} }, \"aggs\": { \"ageAgg\": { \"terms\": { \"field\": \"age\", \"size\": 100 }, \"aggs\": { \"genderAgg\": { \"terms\": { \"field\": \"gender.keyword\" }, \"aggs\": { \"balanceAgg\": { \"avg\": { \"field\": \"balance\" } } } }, \"ageBalanceAvg\": { \"avg\": { \"field\": \"balance\" } } } } }} Mapping字段类型 核心简单域类型 字符串: string 整数 : byte, short, integer, long 浮点数: float, double 布尔型: boolean 日期: date 复合类型 地理类型 特定类型 多字段映射(Mapping)Mapping是用来定义一个文档(document)，以及它所包含的属性(field)是如何存储和索引的。比如，使用Mapping来定义： 哪些字符串属性应该被看做全文本属性。(full text fields) 哪些属性包含数组、日期或者地理位置。 文档中的所有属性是否都能被索引。(_all配置) 日期的格式。 自定义映射规则来执行动态添加属性。 查看mapping信息：GET /bank/_mapping 修改mapping信息：https://www.elastic.co/guide/cn/elasticsearch/guide/current/mapping-intro.html自动猜测的映射类型 新版本改…es7及以上移除了type的概念。 关系型数据库中两个数据显示是独立的，即使他们里面有相同名称的列也不影响使用，但es中不是这样的。elasticsearch是基于Lucene开发的搜索引擎，而es中不同type下名称相同的filed最终在Lucene中的处理方式是一样的。 两个不同type下的两个user_name，在es同一个索引下其实被认为是同一个filed，你必须在两个不同type中定义相同的filed映射。否则，不同type中的相同字段名称就会在处理中出现冲突的情况，导致Lucene处理效率下降。 去掉type就是为了提高es处理数据的效率。 Elasticsearch 7.x URL中的type参数为可选。比如，索引一个文档不再要求提供文档类型。 Elasticsearch 8.x 不再支持URL中的type参数。 解决：1.将索引从多类型迁移到单类型，每种类型文档一个独立索引。2.将已存在的索引下的数据类型，全部迁移到指定位置即可。详见数据迁移。 创建映射1.创建索引并指定映射。 123456789101112GET /bank/_mappingPUT /my_index{ \"mappings\": { \"properties\": { \"age\":{\"type\": \"integer\"}, \"email\":{\"type\": \"keyword\"}, \"name\":{\"type\": \"text\"} } }} 添加新的字段映射123456789PUT /my_index/_mapping{ \"properties\": { \"employee-id\": { \"type\": \"keyword\", \"index\": false } }} 更新映射对于已存在的映射字段，我们不能更新。更新必须创建新的索引进行数据迁移。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546PUT /newbank{ \"mappings\": { \"properties\": { \"account_number\" : { \"type\" : \"long\" }, \"address\" : { \"type\" : \"text\" }, \"age\" : { \"type\" : \"long\" }, \"balance\" : { \"type\" : \"long\" }, \"city\" : { \"type\" : \"keyword\" }, \"email\" : { \"type\" : \"keyword\" }, \"employer\" : { \"type\" : \"keyword\" }, \"firstname\" : { \"type\" : \"keyword\" }, \"gender\" : { \"type\" : \"keyword\" }, \"lastname\" : { \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } }, \"state\" : { \"type\" : \"keyword\" } } }} 数据迁移先创建出newbank的正确映射。然后使用如下方式进行数据迁移。 123456789POST _reindex{ \"source\": { \"index\": \"bank\" }, \"dest\": { \"index\": \"newbank\" }} 分词一个tokenizer(分词器)接受一个字符流，将之分割为独立的tokens(词元，通常是独立的单词)，然后输出tokens流。例如，whitespace tokenizer遇到空白字符时分割文本。它会将文本”Quick brown fox!”分割为[Quick,brown,fox!]。该tokenizer(分词器)还负责记录各个term(词条)的顺序或position位置(用于phrase短语和word proximity词近邻查询)，以及term(词条)所代表的原始word(单词)的start(起始)和end(结束)的character offsets(字符偏移量)(用于高亮显示搜索的内容)。Elasticsearch提供了很多内置的分词器，可以用来构建custom analyzers(自定义分词器)。 安装ik分词器 注意：不能用默认elasticsearch-plugin install xxx.zip进行安装。https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.4.2 对应es版本安装 1234567891011进入es容器内部 plugins目录docker exec -it 容器id /bin/bashwget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zipuzip elasticsearch-analysis-ik-7.4.2.ziprm -rf*.zipmv elasticsearch/ik可以确认是否安装好了分词器cd ../binelasticsearch plugin list 即可列出系统的分词器docker restart elasticsearch # 需要重启es 测试分词器1234567891011121314151617181920212223242526272829303132333435363738394041424344POST _analyze{ \"text\": \"我是中国人\"}效果{ \"tokens\" : [ { \"token\" : \"我\", \"start_offset\" : 0, \"end_offset\" : 1, \"type\" : \"&lt;IDEOGRAPHIC&gt;\", \"position\" : 0 }, { \"token\" : \"是\", \"start_offset\" : 1, \"end_offset\" : 2, \"type\" : \"&lt;IDEOGRAPHIC&gt;\", \"position\" : 1 }, { \"token\" : \"中\", \"start_offset\" : 2, \"end_offset\" : 3, \"type\" : \"&lt;IDEOGRAPHIC&gt;\", \"position\" : 2 }, { \"token\" : \"国\", \"start_offset\" : 3, \"end_offset\" : 4, \"type\" : \"&lt;IDEOGRAPHIC&gt;\", \"position\" : 3 }, { \"token\" : \"人\", \"start_offset\" : 4, \"end_offset\" : 5, \"type\" : \"&lt;IDEOGRAPHIC&gt;\", \"position\" : 4 } ]} 使用ik_smart分词器。 12345678910111213141516171819202122232425262728293031POST _analyze{ \"analyzer\":\"ik_smart\", \"text\": \"我是中国人\"}效果{ \"tokens\" : [ { \"token\" : \"我\", \"start_offset\" : 0, \"end_offset\" : 1, \"type\" : \"CN_CHAR\", \"position\" : 0 }, { \"token\" : \"是\", \"start_offset\" : 1, \"end_offset\" : 2, \"type\" : \"CN_CHAR\", \"position\" : 1 }, { \"token\" : \"中国人\", \"start_offset\" : 2, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 2 } ]} 使用ik_max_word分词器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445POST _analyze{ \"analyzer\":\"ik_max_word\", \"text\": \"我是中国人\"}效果{ \"tokens\" : [ { \"token\" : \"我\", \"start_offset\" : 0, \"end_offset\" : 1, \"type\" : \"CN_CHAR\", \"position\" : 0 }, { \"token\" : \"是\", \"start_offset\" : 1, \"end_offset\" : 2, \"type\" : \"CN_CHAR\", \"position\" : 1 }, { \"token\" : \"中国人\", \"start_offset\" : 2, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 2 }, { \"token\" : \"中国\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"CN_WORD\", \"position\" : 3 }, { \"token\" : \"国人\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 4 } ]} 能够看出不同的分词器，分词有明显的区别，所以以后定义一个索引不能再使用默认的mapping了，要手工建立mapping，因为要选择分词器。 自定义词库修改/mydata/elasticsearch/plugins/ik/config/IKAnalyzer.cfg.xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"&gt;&lt;properties&gt; &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt; &lt;!--用户可以在这里配置自己的扩展字典 --&gt; &lt;entry key=\"ext_dict\"&gt;&lt;/entry&gt; &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt; &lt;entry key=\"ext_stopwords\"&gt;&lt;/entry&gt; &lt;!--用户可以在这里配置远程扩展字典 --&gt; &lt;entry key=\"remote_ext_dict\"&gt;http://119.23.25.235/es/fenci.txt&lt;/entry&gt; &lt;!--用户可以在这里配置远程扩展停止词字典--&gt; &lt;!-- &lt;entry key=\"remote_ext_stopwords\"&gt;words_location&lt;/entry&gt; --&gt;&lt;/properties&gt; 配置完成后重启es。测试自定义词库。更新完成后，es只会对新增的数据用新词分词。历史数据是不会重新分词的。如果想要历史数据重写分词。只需要执行：POST my_index/_update_by_query?conflicts=proceed Elasticsearch-Rest-Client(1).9300:TCP spring-data-elasticsearch:transport-api.jar springboot版本不同，transport-api.jar不同，不能适配es版本。 7.x已经不建议使用，8以后就要废弃。 (2).9200:HTTP JestClient：非官方，更新慢。 RestTemplate：模拟发HTTP请求，ES很多操作需要自己封装，麻烦。 HttpClient：同上。 Elasticsearch-Rest-Client：官方RestClient，封装了ES操作，API层次分明，上手简单。最终选择Elasticsearch-Rest-Client(elasticsearch-rest-high-level-client)https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.x/java-rest-high.html Spring Boot整合配置使用 附录-安装Nginx 随便启动一个nginx实例，只是为了复制出配置 docker run -p 80:80 –name nginx -d nginx:1.10 将容器内的配置文件拷贝到当前目录：docker container cp nginx:/etc/nginx . 别忘记了后面的. 修改文件名称：mv nginx conf 把这个conf移动到/mydata/nginx下 终止原容器：docker stop nginx 执行命令删除原容器：docker rm $ContainerId 创建新的nginx：执行以下命令12345docker run -p 80:80 --name nginx \\-v /mydata/nginx/html:/usr/share/nginx/html \\-v /mydata/nginx/logs:/var/log/nginx \\-v /mydata/nginx/conf:/etc/nginx \\-d nginx:1.10 12345678[root@iZwz9dvddod8c7o1rqic33Z nginx]# pwd/mydata/nginx[root@iZwz9dvddod8c7o1rqic33Z nginx]# lsconf html logs[root@iZwz9dvddod8c7o1rqic33Z es]# pwd/mydata/nginx/html/es[root@iZwz9dvddod8c7o1rqic33Z es]# lsfenci.txt","link":"/shop-mall/elasticsearch.html"},{"title":"一、微服务分布式电商系统--开发环境准备","text":"【摘要】互联网新技术层出不穷，作为一名开发人员不学习就会落后，怎样才能更快更好的学习这些技术呢？我想一定是在理解原理的基础上去运用它。参考国内外大型互联网公司的业务，思来想去电商系统是个不错的练习项目。因为平时也都在使用淘宝、京东、拼多多等App，站在用户角度对业务也有一定了解，加之电商系统场景的解决方案也比较容易获得资料，所以我决定通过一个电商系统来学习和连接起Java开发人员需要掌握的主流技术。我会在我的博客一步一步的记录整个系统的诞生，本文主要介绍电商系统的前期环境准备过程。在之前的文章中有记录的部分会加以链接，不会重复赘述。 前言本电商系统是笔者根据 尚学堂旗下的谷粒商城 进行扩展开发的。摈弃商城原有名称，改名为这理商城。笔者在开发本电商系统中所使用到的生产环境和开发工具关键字如下； VirtualBox、Vagrant、CentOS7、Docker、MySQL、Redis、Navicat Premium 12、Redis Desktop Manager Maven、IntelliJ IDEA、Visual Studio Code、Git 在安装环境之前，最好使用Win10的操作系统（没钱买Mac，Mac应该更方便）。我开始使用的是Win7的系统，遇到了各种各样的坑。虽然这些坑可以解决，但是最后还是因为各种各样的问题选择了阿里云服务器，省去了安装Linux虚拟机这一步，可以直接从安装Docker以及后续的操作开始。 真心不建议使用Win7，Win10的话勉强凑合，阿里云服务器真香！！先列一下我遇到的坑。 坑一：电脑上装有360、金山毒霸等‘流氓’软件。Vagrant up : Connection timeout 坑二：Win7默认的PowerShell版本比较低，需要升级。Window7升级 PowerShell 坑三：在使用Vagrant下载CentOS镜像的时候超级慢。就像你看视频的时候卡的一帧一帧的，那感觉我想大家都懂。所以建议下载到本地。Vagrant下载太慢解决方法 坑四：这样也不算坑吧，就是麻烦。Virtualbox需要安装扩展包 VirtualBox Extension Pack 坑五：这个应该是我独有的坑！！！因为使用的是公司电脑安装的虚拟机，大概率是因为公司笔记本网络做了限制导致通过Navicat连接不上MySQL，在加上Vagrant异常卡，等的很不开心了，一气之下笔记本非法关机导致需要重装系统。南美亚马逊河雨林中的一只蝴蝶扇动几下翅膀，可以在两周以后引起美国得克萨斯州的一场龙卷风。公司IT把系统装到了我的D盘导致我D盘数据全部丢失。MMP！所以花一百多快买个阿里云服务器装个CentOS，它不香吗？？？ 虽然有很多坑，但是作为一个执着的开发者，我还是乐此不疲的一步一个脚印、看到坑就踩。来看技术的朋友，当我上面在说废话，下面的文字我会记录的正式点。 环境搭建安装Linux虚拟机 下载&amp;安装VirtualBox https://www.virtualbox.org/，需要开启CPU虚拟化。 下载&amp;安装Vagrant Vagrant下载 https://www.vagrantup.com/downloads Vagrant官方镜像仓库 https://app.vagrantup.com/boxes/search 打开windows cmd窗口，运行vagrant init centos/7，即可初始化一个centos7系统。 vagrant其他常见命令 vagrant ssh：自动使用vagrant用户连接虚拟机 vagrant upload source [destination][name[id]]：上传文件 https://www.vagrantup.com/docs/cli Vagrant命令行 默认虚拟的ip地址部署固定ip，开发不方便。 修改Vagrantfileconfig.vm.network “private_network”, ip: “192.168.56.10这里的ip需要在物理机下使用ipconfig命令找到，改为这个指定的子网地址。 重新使用vagrant up启动机器即可。然后再vagrant ssh连接机器。 默认只允许ssh登录方式，为了后来操作方便，文件上传等，我们可以配置允许账号密码登录。vagrant ssh进去系统之后vi /etc/ssh/sshd_config修改PasswordAuthentication yes/no重启服务service sshd restart 这样以后可以使用提供的ssh连接工具直接连接。 注意：VirtualBox会与包括但不限于如下软件冲突，需要卸载这些软件，然后重启电脑。冲突的软件：红蜘蛛、360、净化大师（有可能）等。所以我觉得用阿里云真香！！！ 安装Dockerdocker镜像网站 https://hub.docker.com/安装文档 https://docs.docker.com/engine/install/centos/ 步骤1.卸载之前安装的docker 12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2.安装运行包 1$ sudo yum install -y yum-utils 3.下载docker镜像 123$ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 4.安装docker 1$ sudo yum install docker-ce docker-ce-cli containerd.io 5.启动docker 1$ sudo systemctl start docker 6.设置docker开机自启 1$ sudo systemctl enable docker 7.查看当前镜像列表 1$ sudo docker images 配置docker阿里云镜像加速 1.登录阿里云(https://www.aliyun.com/)https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors控制台-&gt;容器镜像服务-&gt;镜像加速器-&gt;CentOS 2.配置加速镜像 安装／升级Docker客户端推荐安装1.10.0以上版本的Docker客户端，参考文档 docker-ce 配置镜像加速器针对Docker客户端版本大于 1.10.0 的用户您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot;: [&quot;https://mq27feey.mirror.aliyuncs.com&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker 我这里配置的是CentOS系统的，根据自己的实际情况选择对应的系统。以后再下载所有hub.docker.com中的镜像就会去阿里云下载，就不会这么慢了。 Docker安装MySQL1.下载镜像文件 12$ sudo docker pull mysql$ sudo docker pull mysql:5.7 2.创建实例并启动命令解释 123456docker run -p 3306:3306 --name mysql \\-v /mydata/mysql/log:/var/log/mysql \\-v /mydata/mysql/data:/var/lib/mysql \\-v /mydata/mysql/conf:/etc/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:5.7 3.通过容器的mysql命令行工具连接切换权限docker ps 查看当前正在运行的docker镜像 4.设置root远程访问5.进入容器文件系统123docker exec -it mysql /bin/bash然后ls /发现mysql容器内部是完整的linux目录 6.其他MySQL配置 1vi /mydata/mysql/conf/my.cnf 进入mysql配置文件，添加以下内容。然后保存并退出文件。 1234567891011[client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]init_connect = 'SET collation_connection = utf8_unicode_ci'init_connect = 'SET NAMES utf8'character-set-server = utf8collation-server = utf8_unicode_ciskip-character-set-client-handshakeskip-name-resolve 重启mysql镜像 1docker restart mysql 设置mysql总是开启 1sudo docker update mysql --restart=always Docker安装Redis1.下载镜像文件1docker pull redis 2.创建实例并启动123456mkdir -p /mydata/redis/conftouch /mydata/redis/conf/redis.confdocker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\-d redis redis-server /etc/redis/redis.conf (注意)上面命令中的redis.conf会被当成目录来处理，所以上面需要先创建这个文件。redis自描述文件：XXX 3.使用redis镜像执行redis-cli命令链接1docker exec -it redis redis-cli redis中的数据默认是存放在内存中的，一旦重启redis数据就会丢失。所以启用AOF持久化方式 1vi /mydata/redis/conf/redis.conf redis.conf输入appendonly yes重启docker restart redis 使用Redis Desktop Manager客户端工具连接 Redis官网 https://redis.io/ 开发环境统一首先，Java版本选择1.8、Maven版本选择3.6.X。 Maven1.配置maven仓库地址1234567891011#### 2.配置阿里云镜像```xml&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 3.配置Jdk1.8编译项目1234567891011121314&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; Idea&amp;VSCodeIdea整合MavenConfigure-&gt;Setting-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Maven修改默认的User setting file和Local repository为刚刚我们安装的Maven。点击OK。 Idea安装常用插件Lombok和Mybatisx。 VSCode下载&amp;安装官方链接 https://code.visualstudio.com/Download/这个下载好，无脑下一步安装就好了。 VSCode安装插件在插件市场依次搜索以下插件进行安装。 Vetur – 语法高亮、智能感知、Emmet等。包含格式化功能，Alt+Shift+F(格式化全文)，Ctrl+K Ctrl+F(格式化选中代码，两个Ctrl需要同时按) ESLint – 语法纠错 Auto Close Tag – 自动闭合HTML/XML标签 Auto Rename Tag – 自动完成另一侧标签的同步修改 JavaScript(ES6) code snippents – ES6语法智能提示以及快速输入，除js外还支持.ts/.jsx/.tsx/.html/.vue等，省去了配置其支持各种包含js代码的时间。 HTML CSS Support – 让html标签上写class智能提示当前项目所支持的样式 HTML Snippets – html快速自动提示 Open in browser – 浏览器快速打开 Live Server – 以内嵌服务器方式打开 Chinese(Simplified) Langauge Pack for Visual Studio Code – 中文语言包 全部安装完成后，重启VSCode生效。 安装配置Git1.下载&amp;安装Git官网网站下载地址 https://git-scm.com/downloads/下载完成后可以选择默认选型，无脑下一步安装。 2.配置Git配置git，进入git bash。 1234# 配置用户名git config -global user.name &quot;username&quot;# 配置邮箱git config -global user.email &quot;username@email.com&quot; 3.配置ssh免密登录进入git bash，使用：ssh-keygen -t rsa -C “xxxx@xxx.com“命令，连续三次回车。进入cat ~/.ssh/id_rsa.pub登录gitee活着github，在设置里面找到SSH KEY把.pub文件里面的内容粘贴进去。使用ssh -T git@gitee.com或者ssh -T git@github.com 测试是否成功即可。 码云-&gt;设置-&gt;SSH公钥GitHub-&gt;Setting-&gt;SSH and GPG keys-&gt;SSH keys 逆向工程使用1.导入项目逆向工程2.下载人人开源后台管理系统脚手架工程* (1).导入工程，创建数据库 * (2).修改工程shiro依赖为SpringSecurity * (3).删除部分暂时不需要的业务3.下载人人开源后台系统vue端脚手架工程* (1).VSCode导入前端项目 * (2).前后端联调测试基本功能创建项目微服务从GitHub/Gitee初始化一个项目 创建各个微服务项目 商品服务、仓储服务、订单服务、优惠券服务、用户服务。在创建项目时的共同点： (1).引入web/openfeign依赖。 (2).每一个服务，包名com.aiz.zhelimall.xxx(product/order/ware/coupon/member)。 (3).模块名：zheli-coupon。 zhelimall作为总项目。下面创建一个一个的微服务模块。使用Spring的初始化向导。选择必要的。因为微服务和微服务之间需要相互调用。1.创建好的项目结构大概是这样的。在总项目的根目录添加pom文件。2.配置聚合项目。3.把总模块pom+进来，点刷新。 文件版本控制这边提交是本地提交，还需要push到github仓库。然后就可以在github仓库看到我们提交的项目了。 结束语未完待续~","link":"/shop-mall/environment-preparation.html"},{"title":"二、微服务分布式电商系统--快速开发后台管理系统","text":"【摘要】上一篇中有提到利用逆向工程生成后台管理系统，但是并没有展开去描述。因此在本篇中将详细记录如何通过人人开源快速的生成后台管理系统。可以减少基本CRUD代码的编写，而把更多的注意力转移到后续的复杂业务、高并发、高可用和分布式架构上。 前言上篇这个位置 初次提到通过逆向工程生成代码。本篇废话不多扯，直奔主题。 123456789### 逆向工程使用#### 1.导入项目逆向工程#### 2.下载人人开源后台管理系统脚手架工程 * (1).导入工程，创建数据库 * (2).修改工程shiro依赖为SpringSecurity * (3).删除部分暂时不需要的业务#### 3.下载人人开源后台系统vue端脚手架工程 * (1).VSCode导入前端项目 * (2).前后端联调测试基本功能 初始化数据库本项目分为五个微服务模块分别为商品服务、仓储服务、订单服务、优惠券服务、用户服务。因此对应创建了zhelimall_oms/zhelimall_pms/zhelimall_sms/zhelimall_ums/zhelimall_wms五个数据库，分别对应这五个服务模块。库里面具体有哪些表暂时不深究，在开发具体业务的时候再去分析。 人人开源使用官方网站 https://www.renren.io/代码托管 https://gitee.com/renrenio/ 使用git clone命令下载人人开源项目。 人人开源后台管理系统脚手架在下载的renren-fast中删除.git文件夹。然后把整个renren-fast拷贝到zheli-mall目录下。在idea中把renren-fast作为子模块聚合到项目中。之后运行db/mysql.sql文件创建后台管理系统的数据库zhelimall_admin。修改配置文件application-dev.yml启动RenrenApplication访问 localhost:8080这样后台系统目就启动成功了。 人人开源后台系统vue端脚手架还是先删除.git文件夹，之后用VSCode打开。 前端开发，少不了node.js，node.js是一个基于Chrome V8引擎的JavaScript运行环境。http://nodejs.cn/api/ 我们关注与node.js的npm功能就可以。NPM是随同NodeJS一起安装的包管理工具，JavaScript-NPM可以理解为Java-Maven。(1).官网下载安装node.js，并使用node -v检测版本。(2).配置npm使用淘宝镜像。npm config set registry http://registry.npm.taobao.org/ 在VSCode中打开终端，使用npm install安装依赖。 这边在执行npm install命令可能会遇到如下错误。从而导致安装部分包出现错误。解决办法如下(以Windows平台为例)，管理员权限执行以下命令，安装完即可。npm install --global --production windows-build-tools运行cnpm install node-sass@4.12.0解决连接 注意：在错误之后需要清理之前安装失败的依赖和缓存```npm cache clean –forcerm package-lock.jsonrm -rf node_modulesnpm install 12345678910111213依赖安装完成后，使用npm run dev运行项目。![](/gallery/images/shop-mall/fast-generate-crud/success-1.png)![](/gallery/images/shop-mall/fast-generate-crud/success-2.png)&gt;默认账号密码admin/admin## 导入项目逆向工程### 逆向工程的搭建&amp;使用代码生成器 https://gitee.com/renrenio/renren-generator还是和上面一样使用git clone命令下载项目，删除项目中的.git文件夹，然后拷贝到zheli-mall总项目中。​```shellgit clone https://gitee.com/renrenio/renren-generator.git 之后同样聚合renren-generator项目。修改配置文件application.yml，这里填写的数据库名称为需要生产的对应微服务的逆向工程。配置代码生成包路径等信息。配置表前缀生成的JavaBean就不会带有前缀信息。运行renren-generator项目。进入localhost逆向生成代码。下载并解压生成的压缩包。把解压的renren/main拷贝到zhelimall_order对应的位置。之后打开拷贝的文件夹，会发现有很多错误，要么没有导入依赖要么找不到对应的类文件。所以我们在zhelimall下创建一个微服务，把后来需要用到的组件都写到公共服务中。右击总模块-&gt;New-&gt;Module-&gt;选择Maven，点击Next-&gt;ArtifactId填写zheli-common。选择Finish。然后给子服务添加zheli-common依赖。根据微服务模块代码报错情况在renren-fast中拷贝代码到zheli-commom中。因为拷贝过来的代码是依赖其他外部包的，如mybaitis-plus、httpcomponents等，我们需要在zheli-common下的pom中导入这些依赖。配置完成后把zheli-common打包。注释掉shiro的RequiresPermissions。逆向工程的调整，暂时删除RequiresPermissions后续改为SpringSecurity。到这里使用逆向工程生成后台代码基本就完成了。后面使用代码生成器生成其他模块代码的步骤我就不重复叙述了。 配置&amp;测试微服务基本CRUD功能还是继续导入依赖。在zheli-order模块中添加application.yml配置文件。测试添加功能，测试的过程中可能还会遇到部分依赖没有导入的文件，自行解决。控制台出现”保存成功…”后去数据库查看是否保存成功。查看发现，数据库中确实插入了一条记录。这里成功测试了增加的功能，同样可以测试删除更新等功能。这里我就不再重复。因为后续会有大量的查询操作，这里测试一个查询接口。 生成所有微服务CRUD代码和上面生成订单模块代码一样的操作，可以生成所有微服务基本CRUD代码。配置好所有微服务模块之后，我们以zheli-product为例，启动ZheliProductApplication，访问http://localhost:8000/product/pmsbrand/list，测试查询接口是否正常。可以看到浏览器上查询接口返回正常。 结束语未完待续~","link":"/shop-mall/fast-generate-crud.html"},{"title":"四、微服务分布式电商系统--前端开发基础知识&amp;快速入门","text":"【摘要】前端开发基础知识&amp;快速入门~ 前言VSCode的使用之前介绍过，这边不再赘述。 ES6简介ECMAScript 6.0(以下简称ES6，ECMAScript是一种由Ecma国际(前身为欧洲计算机制造商协会,英文名称European Computer Manufacturers Association)通过ECMA-262标准化的脚本程序设计语言)是JavaScript语言的下一代标准，已经在2015年6月正式发布了，并且从ECMAScript 6.0开始采用年号来做版本。即ECMAScript2015，就是ECMAScript6。它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。每年一个新版本。 ES6新特性let声明变量新建es6文件夹，使用VSCode打开。新建文件1.let.html，按住Shift+!快速生成代码。 1234567891011121314151617181920212223242526&lt;script&gt; // var 声明变量往往会越域 // let 声明的变量有严格局部作用域 { var a = 1; let b = 2; } console.log(a); // 1 //console.log(b); // Uncaught ReferenceError: b is not defined // var 可以声明多次 // let 只能声明一次 var m = 1 var m = 2 let n = 3 //let n = 4 console.log(m); // 2 //console.log(n); // Uncaught SyntaxError: Identifier 'n' has already been declared // var 会变量提升 // let 不存在变量提升 console.log(x); // undefined var x = 10; //console.log(y); //Uncaught ReferenceError: Cannot access 'y' before initialization //let y = 10;&lt;/script&gt; const声明变量(只读变量)123456&lt;script&gt; // 1. 声明之后不允许改变 // 2. 一旦声明必须初始化，否则会报错 const a = 1; a = 3; // Uncaught TypeError: Assignment to constant variable.&lt;/script&gt; 解构表达式数组解构12345678&lt;script&gt; // 数组解构 let arr = [1,2,3]; //以前我们想获取其中的值，只能通过角标。ES6可以这样： const [x,y,z] = arr;// x,y,z将与arr中的每个位置对应来取值 //然后打印 console.log(x,y,z);&lt;/script&gt; 对象解构1234567891011121314151617181920212223242526272829303132&lt;script&gt; // 数组解构 let arr = [1,2,3]; //以前我们想获取其中的值，只能通过角标。ES6可以这样： const [x,y,z] = arr;// x,y,z将与arr中的每个位置对应来取值 //然后打印 console.log(x,y,z); const person = { name: \"jack\", age: 21, language: ['java', 'js', 'css'] } // 以等价于下面 前的做法 //const name = person.name; //const age = person.age; //const language = person.language; //console.log(name); //console.log(age); //console.log(language); //解构表达式获取值，将person里面的每一个属性和左边对应赋值 //对象解构 const{name,age,language} = person; console.log(name,age,language); //扩展：如果想要将name的值赋给其他变量，可以如下，abc是新的变量。 //const{name:abc,age,language} = person; //console.log(abc,age,language);&lt;/script&gt; 字符串扩展几个新的APIES6为字符串扩展了几个新的API: startsWith()：返回布尔值，表示是否找到了参数字符串。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 includes()：返回布尔值，表示参数字符串是否在原字符串的尾部。 1234567&lt;script&gt; let str = \"hello.vue\"; console.log(str.startsWith(\"hello\"));//ture console.log(str.endsWith(\".vue\"));//ture console.log(str.includes(\"e\"));//true console.log(str.includes(\"hello\"));//ture&lt;/script&gt; 字符串模板模板字符串相当于加强版的字符串，用反引号除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。 123456let ss = ` &lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt; ` console.log(ss) 字符串扩展1234567891011121314151617181920//1.字符串模板let ss = ` &lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt;`console.log(ss)//2.字符串插入变量和表达式。变量名写在${}中，${}中可以JavaScript表达式。let name = \"张三\";let age = 18;let info = `我是${name},今年${age+1}了`;console.log(info)//3.字符串中调用函数function fun(){ return \"这是一个函数\";}let sss = `H啊哈哈哈~${fun()}`;console.log(sss);//H啊哈哈哈~这是一个函数 函数优化函数参数默认值12345678910111213141516171819&lt;script&gt; //在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法。 function add(a, b) { //判断b是否为空，为空就给默认值1 b = b || 1; return a + b; } //传一个参数 console.log(add(10)); //现在可以这么写，直接给参数写上默认值，没传就会自动使用默认值 function add2(a, b = 1) { return a + b; } //传一个参数 console.log(add2(10)); &lt;/script&gt; 不定参数不定参数用来表示不确定参数个数，形如，…变量名，由…加上一个具名参数标识符组成。具名参数只能放在参数列表的最后，并且有且只有一个不定参数。 12345678//2.不定参数&lt;script&gt; function fun(...values) { console.log(values.length) } fun(1) //1 fun(1, 2, 3, 4) //4&lt;/script&gt; 箭头函数123456789101112131415161718192021222324252627&lt;script&gt; //以前声明一个方法 // var print = function(obj){ // console.log(obj); // } //一个参数 var print = obj =&gt; console.log(obj); print(\"hello\"); //多个参数 var sum = function (a, b) { return a + b; } var sum2 = (a, b) =&gt; a + b; console.log(sum2(11, 12)); //多个参数多行代码 var sum3 = function (a, b) { c = a + b; return a + c; } var sum4 = (a,b)=&gt;{ c = a + b; return a + c; }; console.log(sum4(11, 12));&lt;/script&gt; 实战：箭头函数结合解构表达式123456789101112131415//实战：箭头函数结合解构表达式const person = { name: \"jack\", age: 21, language: ['java', 'js', 'css']}function hello(person) { console.log(\"hello,\" + person.name)}//现在的方式var hello2 = (param) =&gt; console.log(\"hello,\" + param.name);hello2(person);//箭头函数+解构var hello3 = ({name}) =&gt; console.log(\"hello,\" + name);hello3(person); 对象优化新增的APIES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组。 values(obj)：获取对象的所有value形成的数组。 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assign(dest,…src)：将多个src对象的值 拷贝到dest中。(第一层为深拷贝，第二层为浅拷贝)12345678910111213141516//1.新增的APIconst person = { name: \"jack\", age: 21, language: ['java', 'js', 'css']}console.log(Object.keys(person));//[\"name\",\"age\",\"language\"]console.log(Object.values(person));//[\"jack\",21,Arrays(3)]console.log(Object.entries(person));//[Arr,ay(2),Arrays(2),Arrays(2)]const target = { a: 1 };const source1 = { b: 2 };const source2 = { c: 3 };//Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。Object.assign(target, source1, source2);console.log(target)//{a: 1, b: 2, c: 3} 声明对象简写123456789101112131415//对象的函数属性简写let person3 = { name: \"jack\", //以前： eat: function (food) { console.log(this.name + \"在吃\" + food); }, //箭头函数版，这里拿不到this eat2: food =&gt; console.log(person3.name + \"在吃\" + food), //简写版 eat3(food) { console.log(this.name + \"在吃\" + food) }}person3.eat(\"apple\");//jack在吃apple 对象拓展运算符拓展运算符(…)用于取出参数对象所有可遍历属性然后拷贝到当前对象。 12345678910//4.对象拓展运算符//(1).拷贝对象(深拷贝)let person4 = { name: \"Amy\", age: 15 }let someone = { ...person4 }console.log(someone)//{name: \"Amy\", age: 15}//(2).合并对象let age1 = { age: 15 }let name1 = { name: \"Amy\" }let person5 = { ...age1, ...name1 }//如果两个对象的字段名重复，后面对象字段值会覆盖前面对象的字段值console.log(person5)//{age: 15, name: \"Amy\"} map和reducemap123456789//map()：接受了一个函数，将原数组中所有元素用这个函数处理后放入新数组返回。let arr = ['1','20','5','3'];arr = arr.map((item)=&gt;{ return item*2});arr = arr.map(item=&gt;item*2);console.log(arr);//[2, 40, 10, 6] reduce语法：arr.reduce(callback,[initalValue])reduce为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值(或者上一次回调函数的返回值)，当前元素值，当前索引，调用reduce的数组。callback(执行数组中每个值的函数，包含四个参数) 1.previous(上一次调用回调返回的值，或者是提供初始值(initialValue)) 2.currentValue(数组中当前被处理的元素) 3.index(当前元素在数组中的索引) 4.array(调用reduce的数组)initalValue(作为第一次调用callback的第一个参数。)1234567 //let arr = [2, 40, 10, 6];let result = arr.reduce((a, b) =&gt; { console.log(\"上一次处理后：\" + a); console.log(\"当前正在处理：\" + b); return a + b;},100);console.log(result); Promise Promise语法 处理异步结果 Promise改造以前嵌套方式 优化处理 模块化 1.什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包。必须先导包。而JS中没有包的概念，换来的是模块。模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口。import命令用于导入其他模块提供的功能。 2.export比如我定义一个js文件：hello.js，里面有一个对象。 12345const util = { sum(a, b) { return a + b; }} 我们可以使用export将这个对象导出。 1234567const util = { sum(a, b) { return a + b; }}export {util} export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。当要导出多个值时，还可以简写。比如我有一个文件：user.js。 123var name = \"jack\"var age = 21export { name, age } 省略名称上面的导出代码中，都明确指定了导出的变量名，这样其他人在导入使用时就必须准确写出变量名。否在就会出错。因此js提供了default关键字，可以对导出的变量名进行省略。例如： 1234567891011121314151617181920// const util = {// sum(a, b) {// return a + b;// }// }// export {util}//`export`不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。export const util = { sum(a, b) { return a + b; }}export default { sum2(a, b) { return a + b; }} 3.import 12345678import util from \"./hello.js\"//import abc from \"./hello.js\"import {name,add} from \"./user.js\"util.sum(1,2);//abc.sum2(2,3);console.name(name);add(1,3); 4.测试以上代码 Node.js前端开发，少不了node.js，node.js是一个基于Chrome V8引擎的JavaScript运行环境。http://nodejs.cn/api/ 我们关注与node.js的npm功能就可以。NPM是随同NodeJS一起安装的包管理工具，JavaScript-NPM可以理解为Java-Maven。(1).官网下载安装node.js，并使用node -v检测版本。(2).配置npm使用淘宝镜像。npm config set registry http://registry.npm.taobao.org/ VueMVVM思想 M：即Model，模型，包括数据和一些基本操作。 V：即View，视图，页面渲染结果。 VM：即View-Model，模型与视图间的双向操作。(无需开发人员干涉) 在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到view中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不再关心Model和View之间是如何相互影响的： 只要我们Model发生了改变，View上自然就会表现出来。 当用户修改了View，Model中的数据也会跟着改变。开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。 Vue简介Vue.js（读音 /vjuː/, 类似于 view）是一套构建用户界面的渐进式框架。与其他大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不易于上手，还便于与第三方或既有项目整合。另一方面，当与现代化的工具链以及各种支持库结合使用，Vue也完全能够为复杂的单页应用提供驱动。 官网：https://cn.vuejs.org/参考：https://cn.vuejs.org/v2/guide/ Git地址：https://github.com/vuejs/尤雨溪，Vue.js创造者，Vue Technology创始人，致力于Vue的研究开发。 入门案例新建并使用VSCode打开文件夹vue2。初始化项目，然后就会生成一个package.json文件，代表它是一个npm来管理的。 1npm init -y 安装vue依赖。 1npm install vue 新建一个index.html测试使用vue.js。在浏览器打开。在浏览器控制台修改name的值按回车，页面上的值也会跟着改变。在VSCode中安装插件Vue 2 Snippets 安装vue-devtools插件 vue-devtools是一款基于chrome游览器的插件，用于调试vue应用，这可以极大地提高我们的调试效率。 登录github，获取到vue-devtools源码并下载下来。https://github.com/vuejs/vue-devtools。 打开下载文件，在根目录下执行cmd命令来下载项目的依赖 ： npm install 下载依赖结束之后，编译项目，执行cmd命令：npm run build 在chrome浏览器中，打开&gt;更多工具&gt;扩展程序。开启开发者模式。并将项目文件中的chrome文件整体导入。 在浏览器中打开vue-devtools 概念指定插值表达式 1.花括号格式：{ { } }说明： 该表达式支持JS语法，可以调用js内置函数。(必须有返回值) 表达式必须有返回结果。例如1+1，没有结果的表达式不允许使用，如：let a = 1 + 1; 可以直接获取Vue实例中定义的数据或函数。 2.插值闪烁使用{ { } }方式在网速较慢时会出现问题。在数据未加载完成时，页面会显示出原始的{ { } }，加载完毕后才显示正常数据，我们称之未插值闪烁。我们将网速调慢一些，然后刷新页面，试试看刚才的案例。 v-bindv-modelv-on 基本用法 事件修饰符在事件处理程序中调用event.preventDefault()或event.stopPropagation()是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理DOM事件细节。为了解决这个问题，Vue.js为v-on提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop：阻止事件冒泡到父元素 .prevent：阻止默认事件发生 .capture：使用事件捕获模式 .self：只有元素自身触发事件才执行(冒泡或捕获的都不执行) .once：只执行一次 按键修饰符在监听按键事件时，我们经常需要检查常见的键值。Vue允许为v-on在监听按键事件时添加按键修饰符： 12&lt;!-- 只有在'keyCode'是13时调用'vm.submit' --&gt;&lt;input v-on:keyup.13=&quot;submit()&quot;&gt; 记住所有的keyCode比较困难，所以Vue为最常用的按键提供了别名： 1234&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=&quot;submit()&quot;&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=&quot;submit()&quot;&gt; 全部的按键别名：.enter.tab.delete(捕获”删除”和”退格”键).esc.space.up.down.left.right 组合按键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或者键盘事件的监听器。.ctrl.alt.shift 1234&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=&quot;clear&quot;&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt; v-forv-of和v-showv-else和v-else-if计算属性和侦听器组件化在大型应用开发的时候，页面可以划分很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。但是如果每个页面都独立开发，这无疑增加了我们的开发成本。所以我们把页面的不同部分拆开城独立的组件，然后再不同页面就可以共享这些组件，避免重复开发。在vue中，所有的vue实例都是组件。 全局组件 组件其实也是一个Vue实例，因此它在定义时也会接受：data、methods、声明周期函数等。 不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性。 全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了。 data必须是一个函数，不再是一个对象。12345678910111213141516171819202122232425&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button v-on:click=\"count++\"&gt;我被点击了{{count}}次&lt;/button&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; &lt;script src=\"../node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; //1.全局声明注册一个组件 Vue.component(\"counter\", { template: `&lt;button v-on:click=\"count++\"&gt;我被点击了{{count}}次&lt;/button&gt;`, data() { return { count: 1 } } }); new Vue({ el: \"#app\", data: { count: 1 } }); &lt;/script&gt;&lt;/body&gt; 组件的复用局部组件定义好的组件，可以任意复用多次：123456789//2.局部声明一个组件const buttonCounter = { template: `&lt;button v-on:click=\"count++\"&gt;我被点击了{{count}}次~~~~&lt;/button&gt;`, data() { return { count: 1 } }}; 生命周期和钩子函数生命周期每个Vue实例被创建时都要经过一系列的初始化过程：创建实例、装载模板、渲染模板等等。Vue为生命的每个状态都设置了钩子函数(监听函数)。每当Vue实例对于不同的生命周期时，对应的函数就会被触发调用。生命周期：你不需要立马弄明白所有的东西。生命周期图示 钩子函数vue模块化开发npm install webpack -g全局安装webpack npm install -g@vue/cli-init全局安装vue脚手架 初始化vue项目vue init webpack appname：vue脚手架使用webpack模块化初始化一个appname项目 启动vue项目项目的package.json中有scripts,代表我们能运行的命令。npm start=npm run dev：启动项目 使用Vue脚手架自定义组件 整合ElementUI快速开发https://element.eleme.cn/#/zh-CN/component/installation BabelBabel是一个JavaScript编译器，我们可以使用es的最新语法编程，而不用担心浏览器兼容问题。他会自动转化为浏览器兼容的代码。 Webpack自动化项目构建工具。gulp也是同类产品。 结束语","link":"/shop-mall/front-end-knowledge.html"},{"title":"五、微服务分布式电商系统--商品服务API接口","text":"【摘要】商品服务API接口~ 前言商品服务-API-三级分类-查询-递归树形结构数据获取所有的分类数据从数据库读取，对应数据库pms_category。首先在数据库准备数据，然后再我们zheli-product中找到和分类有关的代码。Controller 123456789101112131415161718@RestController@RequestMapping(\"product/category\")public class CategoryController { @Autowired private CategoryService categoryService; /** * 查出所有分类以及子分类，以树形结构组装起来 */ @RequestMapping(\"/list/tree\") public R list(@RequestParam Map&lt;String, Object&gt; params){ List&lt;CategoryEntity&gt; entities = categoryService.listWithTree(); return R.ok().put(\"data\",entities); } //...} Service 1234567/** * 商品三级分类 */public interface CategoryService extends IService&lt;CategoryEntity&gt; { List&lt;CategoryEntity&gt; listWithTree();} ServiceImpl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Service(\"categoryService\")public class CategoryServiceImpl extends ServiceImpl&lt;CategoryDao, CategoryEntity&gt; implements CategoryService {// @Autowired// CategoryDao categoryDao; @Override public PageUtils queryPage(Map&lt;String, Object&gt; params) { IPage&lt;CategoryEntity&gt; page = this.page( new Query&lt;CategoryEntity&gt;().getPage(params), new QueryWrapper&lt;CategoryEntity&gt;() ); return new PageUtils(page); } @Override public List&lt;CategoryEntity&gt; listWithTree() { //1.查出所有分类 List&lt;CategoryEntity&gt; entities = baseMapper.selectList(null); //2.组装成父子的树形结构 //2.1找到所有的一级分类 List&lt;CategoryEntity&gt; level1Menus = entities.stream().filter(categoryEntity -&gt; categoryEntity.getParentCid() == 0 ).map((menu) -&gt; { menu.setChildren(getChildrens(menu, entities)); return menu; }).sorted((menu1, menu2) -&gt; { return (menu1.getSort()==null?0:menu1.getSort()) - (menu2.getSort()==null?0:menu2.getSort()); }).collect(Collectors.toList()); return level1Menus; } //递归查找所有菜单的子菜单 private List&lt;CategoryEntity&gt; getChildrens(CategoryEntity root, List&lt;CategoryEntity&gt; all) { List&lt;CategoryEntity&gt; children = all.stream().filter(categoryEntity -&gt; { return categoryEntity.getParentCid() == root.getCatId(); }).map(categoryEntity -&gt; { //1.找到子菜单 categoryEntity.setChildren(getChildrens(categoryEntity, all)); return categoryEntity; }).sorted((menu1, menu2) -&gt; { //2.菜单的排序 return (menu1.getSort()==null?0:menu1.getSort()) - (menu2.getSort()==null?0:menu2.getSort()); }).collect(Collectors.toList()); return children; }} 测试运行。 商品服务-API-三级分类-配置网关路由和路径重写启动人人快速开发平台。在菜单管理新建商品系统目录，并在商品系统目录下新建分类维护菜单。在前端项目中新建category.vue文件。使用ElementUI的树形控件：https://element.eleme.cn/#/zh-CN/component/tree之后在category.vue编写前端代码。 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;el-tree :data=\"data\" :props=\"defaultProps\" @node-click=\"handleNodeClick\"&gt;&lt;/el-tree&gt;&lt;/template&gt;&lt;script&gt;export default { components: {}, data() { return { data: [], defaultProps: { children: \"children\", label: \"label\" } }; }, methods: { handleNodeClick(data) { console.log(data); }, getMenus() { this.$http({ url: this.$http.adornUrl(\"/product/category/list/tree\"), method: \"get\" }).then(data=&gt;{ console.log(\"成功获取到菜单数据...\",data) }); } }, created() { this.getMenus(); }};&lt;/script&gt;&lt;style lang='scss' scoped&gt;&lt;/style&gt; 页面访问发现没有数据，打开浏览器控制台发现404。发现这里是对http://localhost:8080/renren-fast/product/category/list/tree进行请求获取数据。实际上，需要从http://localhost:8000/product/category/list/tree获取数据。其实如果只是改变http://localhost:8080/renren-fast/这部分基准路径，那么后面分布式情况下需要给8001``8002``...发送请求就还会出现问题。所以找到前端基准路径设置成给网关发请求。上面的设置成功之后，发现验证码请求不到。原因是因为验证码功能是renren-fast后台提供的，现在所有请求都会去网关服务找。要让网关可以发现这个验证码服务，就需要把renren-fast后台服务注册到nacos注册中心中。1.引入zheli-common。2.在application.yml中配置服务名字。 3.配置注册中心地址。4.开启服务的注册发现@EnableDiscoveryClient。5.重启renren-fast。之后配置网关路由和路径重写。重新登录遇到跨域问题。 商品服务-API-三级分类-网关统一配置跨域这里选择第二种配置请求允许跨域。配置完成后，重启网关服务和renren-fast服务。然后在页面重写登录。 商品服务-API-三级分类-查询-树形展示三级分类数据进入分类维护页面的获取数据请求仍然是404。所以需要在网关服务中添加商品服务的网关路由和路径重写。配置之后重启访问发现可以成功获取数据了。修改前端代码。 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;el-tree :data=\"menus\" :props=\"defaultProps\" @node-click=\"handleNodeClick\"&gt;&lt;/el-tree&gt;&lt;/template&gt;&lt;script&gt;export default { components: {}, data() { return { menus: [], defaultProps: { children: \"children\", label: \"name\" } }; }, methods: { handleNodeClick(data) { console.log(data); }, getMenus() { this.$http({ url: this.$http.adornUrl(\"/product/category/list/tree\"), method: \"get\" }).then(({data})=&gt;{ console.log(\"成功获取到菜单数据...\",data.data) this.menus = data.data; }); } }, created() { this.getMenus(); }};&lt;/script&gt;&lt;style lang='scss' scoped&gt;&lt;/style&gt; 效果展示： 商品服务-API-三级分类-删除-页面效果使用 scoped slot。没有子菜单可以删除，一级、二级菜单可以添加。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;el-tree :data=\"menus\" :props=\"defaultProps\" @node-click=\"handleNodeClick\" :expand-on-click-node=\"false\" show-checkbox node-key=\"catId\"&gt; &lt;span class=\"custom-tree-node\" slot-scope=\"{ node, data }\"&gt; &lt;span&gt;{{ node.label }}&lt;/span&gt; &lt;span&gt; &lt;el-button v-if=\"node.level&lt;=2\" type=\"text\" size=\"mini\" @click=\"() =&gt; append(data)\"&gt;Append&lt;/el-button&gt; &lt;el-button v-if=\"node.childNodes.length==0\" type=\"text\" size=\"mini\" @click=\"() =&gt; remove(node, data)\"&gt;Delete&lt;/el-button&gt; &lt;/span&gt; &lt;/span&gt; &lt;/el-tree&gt;&lt;/template&gt;&lt;script&gt;export default { components: {}, data() { return { menus: [], defaultProps: { children: \"children\", label: \"name\" } }; }, methods: { handleNodeClick(data) { console.log(data); }, getMenus() { this.$http({ url: this.$http.adornUrl(\"/product/category/list/tree\"), method: \"get\" }).then(({ data }) =&gt; { console.log(\"成功获取到菜单数据...\", data.data); this.menus = data.data; }); }, append(data) { console.log(\"append\", data); }, remove(node, data) { console.log(\"remove\", node, data); } }, created() { this.getMenus(); },};&lt;/script&gt;&lt;style lang='scss' scoped&gt;&lt;/style&gt; 商品服务-API-三级分类-删除-逻辑删除下载安装Postman https://www.postman.com/downloads/测试删除接口。 使用mybatis逻辑删除。 商品服务-API-三级分类-删除-逻辑删除商品服务-API-三级分类-删除-删除效果细化商品服务-API-三级分类-新增-新增效果完成商品服务-API-三级分类-修改-基本修改效果完成商品服务-API-三级分类-修改-拖拽效果商品服务-API-三级分类-修改-拖拽数据收集商品服务-API-三级分类-修改-拖拽功能完成商品服务-API-三级分类-修改-批量拖拽效果商品服务-API-三级分类-删除-批量删除&amp;小结商品服务-API-品牌管理-使用逆向工程的前后端代码商品服务-API-品牌管理-效果优化与快速显示开关商品服务-API-品牌管理-云存储开通与使用SpringCloud-Alibaba-OSS 简介对象存储服务(Object Storage Service,OSS)是一种海量、安全、低成本、高可靠的云存储服务，适合存放任意类型的文件。容量和处理能力弹性扩展，多钟存储类型供选择，全面优化存储成本。 这个是对象存储的页面。推荐一个项目创建一个Bucket。上传一张图片就可以外网访问。普通上传方式服务端签名后直传 商品服务-API-品牌管理-OSS整合测试使用代码给阿里云OSS中的zheli-mall上传图片。阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。创建子AccessKey并设置权限。 首先我们创建一个工程，这个工程专门用来集成第三方应用的工程，我起名叫zhelimall-third-party。1.在pom文件中加入依赖。 12345&lt;!--阿里云存储--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alicloud-oss&lt;/artifactId&gt;&lt;/dependency&gt; 2.配置key,endpoint相关信息 12345678910111213spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 alicloud: access-key: LTAI4GAGUKKkE4agXXXXXXxX secret-key: ggruUCv4r9juD8QkmBXXXXXxxXXXX oss: endpoint: oss-cn-shanghai.aliyuncs.com bucket: zheli-mall application: name: zheli-third-party 3.使用OSSClient 进行相关操作 商品服务-API-品牌管理-OSS获取服务端签名 编写代码：OssController.java配置网关：http://localhost:30000/oss/policyhttp://localhost:88/api/thirdparty/oss/policy 商品服务-API-品牌管理-OSS前后联调测试上传Element-UI中的 商品服务-API-品牌管理-表单校验&amp;自定义校验器前端校验方法 商品服务-API-品牌管理-JSR303数据校验后端校验方法BrandEntity.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** 三.JSR303 * (一).给Bean添加校验注解 @Email @NotNull在javax.validation.constraints包下 * @NotBlank * private String name; * (二).开启校验功能@Valid * public R save(@Valid @RequestBody BrandEntity brand) * 效果：校验错误以后会有默认的响应； * (三).给校验的Bean后紧跟一个BindingResult,就可以获取到校验的结果 */@Data@TableName(\"pms_brand\")public class BrandEntity implements Serializable { private static final long serialVersionUID = 1L; /** * 品牌id */ @NotNull(message = \"修改必须指定品牌id\") @Null(message = \"新增不能指定id\") @TableId private Long brandId; /** * 品牌名 */ @NotBlank(message = \"品牌名必须提交\") private String name; /** * 品牌logo地址 */ @NotBlank @URL(message = \"logo必须是一个合法的url地址\") private String logo; /** * 介绍 */ private String descript; /** * 显示状态[0-不显示；1-显示] */ @NotNull //@ListValue(vals={0,1}) private Integer showStatus; /** * 检索首字母 */ @NotEmpty @Pattern(regexp = \"/^[a-zA-z]$/\",message = \"检索首字母必须是一个字母\") private String firstLetter; /** * 排序 */ @NotNull @Min(value = 0,message = \"排序必须大于等于0\") private Integer sort;} BrandController.java 123456789101112131415161718@RequestMapping(\"/save\")public R save(@Valid @RequestBody BrandEntity brand, BindingResult result) { if (result.hasErrors()) { Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //1.获取校验的错误结果 result.getFieldErrors().forEach((item) -&gt; { // FileError获取到错误提示 String defaultMessage = item.getDefaultMessage(); // 获取错误的属性的名字 String field = item.getField(); map.put(\"field\", defaultMessage); }); return R.error(400, \"提交的数据不合法\").put(\"data\", map); } else { brandService.save(brand); return R.ok(); }} 使用PostMan测试。 商品服务-API-品牌管理-统一异常处理 @ResponseBody + @ControllerAdvice系统错误码错误码和错误信息定义类1.错误码定义规则为5位数2.前两位表示业务场景,最后三位表示错误码。例如：10001。10：通用。 001：系统未知异常。3.维护错误码后需要维护错误描述，将他们定义为枚举形式。错误码列表： 10：通用 001：参数格式校验 11：商品 12：订单 13：购物车 14：物流 错误码BizCodeEnum.java 1234567891011121314151617181920public enum BizCodeEnum { UNKNOW_EXCEPTION(10000,\"系统未知异常\"), VAILD_EXCEPTION(10001,\"参数格式校验失败\"); private int code; private String msg; BizCodeEnum(int code, String msg) { this.code = code; this.msg = msg; } public int getCode() { return code; } public String getMsg() { return msg; }} 集中处理所有异常ZhelimallExceptionControllerAdvice.java 123456789101112131415161718192021@Slf4j@RestControllerAdvice(basePackages = \"com.aiz.zhelimall.product.controller\")//相当于@ResponseBody + @ControllerAdvicepublic class ZhelimallExceptionControllerAdvice { @ResponseBody @ExceptionHandler(value = MethodArgumentNotValidException.class) public R handleVaildException(MethodArgumentNotValidException e){ log.error(\"数据校验出现问题:{},异常类型:{}\",e.getMessage(),e.getClass()); BindingResult bindingResult = e.getBindingResult(); Map&lt;String,String&gt; errorMap = new HashMap&lt;&gt;(); bindingResult.getFieldErrors().forEach((fieldError -&gt; { errorMap.put(fieldError.getField(),fieldError.getDefaultMessage()); })); return R.error(BizCodeEnum.VAILD_EXCEPTION.getCode(),BizCodeEnum.VAILD_EXCEPTION.getMsg()).put(\"data\",errorMap); } @ExceptionHandler(value = Throwable.class) public R handleException(){ return R.error(); }} 商品服务-API-品牌管理-JSR303分组校验 分组校验(多场景的复杂校验)1.@NotBlank(message = “品牌名必须提交”,groups = {AddGroup.class,UpdateGroup.class})给校验注解标注什么情况进行校验2.@Validated(AddGroup.class)3.默认没有指定分组的校验注解@Notblank,在分组校验情况@Validated(AddGroup.class)下不生效,只会在@Validated生效BrandEntity.java 123456/** * 检索首字母 */@NotEmpty(groups={AddGroup.class})@Pattern(regexp=\"^[a-zA-Z]$\",message = \"检索首字母必须是一个字母\",groups={AddGroup.class,UpdateGroup.class})private String firstLetter; 123456789/** * 修改 */@RequestMapping(\"/update\")public R update(@Validated(UpdateGroup.class)@RequestBody BrandEntity brand) { brandService.updateById(brand); return R.ok();} 商品服务-API-品牌管理-JSR303自定义校验注解导入javax依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt;&lt;/dependency&gt; 自定义校验(一).编写一个自定义的校验注解 123456789101112131415@Documented@Constraint( validatedBy = {ListValueConstraintValidator.class}//可以指定多个不同的校验器，适配不同类型的校验)@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})@Retention(RetentionPolicy.RUNTIME)public @interface ListValue { String message() default \"{com.aiz.common.valid.ListValue.message}\"; Class&lt;?&gt;[] groups() default {}; Class&lt;? extends Payload&gt;[] payload() default {}; int[] vals() default {};} 配置文件ValidationMessages.properties 1com.aiz.common.valid.ListValue.message = 必须提交指定的值 (二).编写一个自定义的校验器 ConstraintValidator 12345678910111213141516171819202122232425public class ListValueConstraintValidator implements ConstraintValidator&lt;ListValue,Integer&gt; { private Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); //初始化方法 @Override public void initialize(ListValue constraintAnnotation) { int[] vals = constraintAnnotation.vals(); for (int val : vals){ set.add(val); } } //判断是否校验成功 /** * * @param value 需要校验的值 * @param Context * @return */ @Override public boolean isValid(Integer value, ConstraintValidatorContext Context) { return set.contains(value); }} (三).关联自定义的校验器和自定义的校验注解 123@Constraint( validatedBy = {ListValueConstraintValidator.class}//可以指定多个不同的校验器，适配不同类型的校验) 使用BrandEntity.java 123456/** * 显示状态[0-不显示；1-显示] */@NotNull(groups = {AddGroup.class, UpdateStatusGroup.class})@ListValue(vals={0,1},groups = {AddGroup.class, UpdateStatusGroup.class})private Integer showStatus; BrandController.java 123456789/** * 修改状态 */@RequestMapping(\"/update/status\")public R updateStatus(@Validated(UpdateStatusGroup.class)@RequestBody BrandEntity brand) { brandService.updateById(brand); return R.ok();} 检查前端接口调用。 商品服务-概念-SPU&amp;SKU&amp;规格参数&amp;销售属性SPU和SKUSPU：Standard Product Unit(标准化产品单元)是商品信息聚合的最小单元，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。SKU：Stock Keeping Unit(库存量单元)即库存进出计量的基本单元，可以是以件、盒、托盘等为单位。SKU这对大型连锁超市DC(配送中心)物流管理的一个必要的方法。现在已经被引申为产品统一编号的简称，每种产品均对应有唯一的SKU号。ex：iphone12是SPU、MI10的SPU iphone12 64G 黑曜石 是SKU MI10+64G+黑色 是SKU 基本属性【规格参数】与销售属性每个分类下的商品共享规格参数，与销售属性。只是有些商品不一定要用这个分类下全部属性。 属性是以三级分类组织起来的 规格参数中有些是可以提供检索的 规格参数也是基本属性，他们具有自己的价值 属性的分组也是以三级分类组织起来的 属性名确定的，但是值是每一个商品不同来决定的 商品服务-API-属性分组-前端组件抽取&amp;父子组件交互 父子组件传递数据子组件给父组件传递数据，事件机制。子组件给父组件发送一个事件，携带上数据。this.$emit(“事件名称”, 需要携带的数据…); 抽取子组件../common/category.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;el-tree :data=\"menus\" :props=\"defaultProps\" node-key=\"catId\" ref=\"menuTree\" @node-click=\"nodeclick\"&gt;&lt;/el-tree&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { menus: [], expandedKey: [], defaultProps: { children: \"children\", label: \"name\" } }; }, methods: { //共三个参数，依次为：传递给 data 属性的数组中该节点所对应的对象、节点对应的 Node、节点组件本身。 nodeclick(data, node, component) { console.log(\"子组件category的节点被点击\", data, node, component); //向父组件发送事件； this.$emit(\"tree-node-click\", data, node, component); } }};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 父组件/product/attrgroup.vue 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;category @tree-node-click=\"treenodeclick\"&gt;&lt;/category&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Category from \"../common/category\";export default { methods: { //感知树节点被点击 treenodeclick(data, node, component) { console.log(\"attrgroup感知到category的节点被点击\",data, node, component); console.log(\"刚才被点击的菜单id：\",data.catId); if (node.level == 3) { this.catId = data.catId; this.getDataList(); //重新查询 } }, }&lt;/script&gt;}&lt;style scoped&gt;&lt;/style&gt; 商品服务-API-属性分组-获取分类属性分组接口文档：https://easydoc.xyz/s/78237135/ZUqEdvA4/hKJTcbfd AttrGroupController.java 1234567@RequestMapping(\"/list/{catelogId}\")public R list(@RequestParam Map&lt;String, Object&gt; params, @PathVariable(\"catelogId\") Long catelogId){ PageUtils page = attrGroupService.queryPage(params,catelogId); return R.ok().put(\"page\", page);} AttrGroupServiceImpl.java 123456789101112131415161718192021222324@Overridepublic PageUtils queryPage(Map&lt;String, Object&gt; params, Long catelogId) { if (catelogId == 0) { IPage&lt;AttrGroupEntity&gt; page = this.page( new Query&lt;AttrGroupEntity&gt;().getPage(params), new QueryWrapper&lt;AttrGroupEntity&gt;() ); return new PageUtils(page); } else { String key = (String) params.get(\"key\"); //select * from pms_attr_group where catelog_id = ? and (attr_group_id = key or attr_group_name like '%key%') QueryWrapper&lt;AttrGroupEntity&gt; wrapper = new QueryWrapper&lt;AttrGroupEntity&gt;().eq(\"catelog_id\", catelogId); if (!StringUtils.isEmpty(key)) { wrapper.and((obj) -&gt; { obj.eq(\"attr_group_id\", key).or().like(\"attr_group_name\", key); }); } IPage&lt;AttrGroupEntity&gt; page = this.page( new Query&lt;AttrGroupEntity&gt;().getPage(params), wrapper ); return new PageUtils(page); }} 商品服务-API-属性分组-分组新增&amp;级联选择器商品服务-API-属性分组-分组修改&amp;级联选择器回显Element-UI中Cascader级联选择器的使用 商品服务-API-品牌管理-品牌分类关联与级联更新MyBatis Plus分页插件使用 https://mp.baomidou.com/guide/page.htmlcom.aiz.zhelimall.product.config.MyBatisConfig.java 一个品牌会有多个分类，一个分类也会包含多个品牌。分类&amp;品牌是多对多的关系。 查询接口：product/categorybrandrelation/catelog/list?brandId=4添加接口：product/categorybrandrelation/save在电商系统中对于大表尽量避免关联查询，所以这边存放brand_name和catelog_name冗余字段。因为有冗余字段设计，所以在业务代码中修改品牌名称还需要同时修改关联表中的字段。 使用QueryWrapper方式：BrandController.java 1234567@RequestMapping(\"/update\")public R update(@Validated(UpdateGroup.class)@RequestBody BrandEntity brand) { //brandService.updateById(brand); //这里不能只更新品牌表 因为其他表包含品牌表里面的字段(字段冗余设计造成的) brandService.updateDetail(brand); return R.ok();} BrandServiceImpl.java 1234567891011@Transactional@Overridepublic void updateDetail(BrandEntity brand) { //保证冗余字段的数据一致 this.updateById(brand); if(!StringUtils.isEmpty(brand.getName())){ //同步更新其他关联表中的数据 categoryBrandRelationService.updateBrand(brand.getBrandId(),brand.getName()); // TODO 更新其他关联 }} CategoryBrandRelationServiceImpl.java 123456public void updateBrand(Long brandId, String name) { CategoryBrandRelationEntity relationEntity = new CategoryBrandRelationEntity(); relationEntity.setBrandId(brandId); relationEntity.setBrandName(name); this.update(relationEntity,new UpdateWrapper&lt;CategoryBrandRelationEntity&gt;().eq(\"brand_id\",brandId));} 使用自定义SQL语句方式：CategoryController.java 12345@RequestMapping(\"/update\")public R update(@RequestBody CategoryEntity category){ categoryService.updateCascade(category); return R.ok();} CategoryServiceImpl.java 这里包含事务控制。 12345678910/** * 级联更新所有关联的数据 * @param category */@Transactional@Overridepublic void updateCascade(CategoryEntity category) { this.updateById(category); categoryBrandRelationService.updateCategory(category.getCatId(),category.getName());} CategoryBrandRelationDao.java 1void updateCategory(@Param(\"catId\") Long catId, @Param(\"name\") String name); CategoryBrandRelationDao.xml 123&lt;update id=\"updateCategory\"&gt; UPDATE `pms_category_brand_relation` SET catelog_name=#{name} WHERE catelog_id=#{catId}&lt;/update&gt; 商品服务-API-平台属性-规格参数新增与VOObject划分 PO(Persistant Object)持久对象PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。 DO(Domain Object)领域对象就是从现实世界中抽象出来的有形或无形的业务实体。 TO(Transfer Object)数据传输对象不同应用程序之间传输的对象。 DTO(Data Transfer Object)数据传输对象这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗颗粒度的数据实体，以减少分布式调用的次数,从而提高分布式调用的性能和降低网络负载，但在这里，泛指用于展示层与服务层之间的数据传输对象。 VO(Value Object)值对象通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象，可以和表对应，也可以不。这根据业务的需要。用new关键字创建，由GC回收的。View Object：视图对象。接收页面传递来的数据，封装对象。将业务处理完的对象封装成页面要用的数据。 BO(Business Object)业务对象从业务模型的角度看，见UML元件领域模型中的领域对象。封装业务逻辑的Java对象，通过调用DAO方法，结合PO/VO进行业务操作。business object：业务对象 主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其他的对象。比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。建立一个对应简历的BO对象处理简历，每个BO包含这些PO。这样处理业务逻辑时，我们就可以针对BO去处理。 POJO(plain ordinary java object)简单无规则Java对象传统意义的java对象。就是说在一些Object/Relation Mapping工具中，能够做到维护数据库表记录的persisent object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java Bean，只有属性字段以及setter和getter方法。POJO是DO/DTO/BO/VO的统称。 DAO(Data Accsee Object)数据访问对象是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负责持久层的操作。为业务层通过接口。此对象用于访问数据库。通过和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法，结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源终究，配合VO，提供数据库的CRUD操作。 规格参数新增因为在接受页面传来的属性数据的时候，会把属性的分组信息也带过来。所以新建AttrVo.java用于存放属性信息和属性分组attrGroupId信息。AttrVo.java 123456789101112131415161718192021222324252627282930313233343536373839404142public class AttrVo { /** * 属性id */ private Long attrId; /** * 属性名 */ private String attrName; /** * 是否需要检索[0-不需要，1-需要] */ private Integer searchType; /** * 属性图标 */ private String icon; /** * 可选值列表[用逗号分隔] */ private String valueSelect; /** * 属性类型[0-销售属性，1-基本属性，2-既是销售属性又是基本属性] */ private Integer attrType; /** * 启用状态[0 - 禁用，1 - 启用] */ private Long enable; /** * 所属分类 */ private Long catelogId; /** * 快速展示【是否展示在介绍上；0-否 1-是】，在sku中仍然可以调整 */ private Integer showDesc; /** * 属性分组id */ private Long attrGroupId;} 页面提交信息时，会涉及到属性信息和属性分组信息两张数据库表。AttrController.java 12345@RequestMapping(\"/save\")public R save(@RequestBody AttrVo attr){ attrService.saveAttr(attr); return R.ok();} AttrServiceImpl.java在给attrEntity设置属性值的时候，可以(1).一个一个set。(2).使用spring的BeanUtils.copyProperties()，需要注意的是这个浅拷贝，也就是说如果存在子对象且子对象还需要改变就一定不能使用这个方法。 123456789101112131415@Transactional@Overridepublic void saveAttr(AttrVo attr) { AttrEntity attrEntity = new AttrEntity();// attrEntity.setAttrName(attr.getAttrName());// ... BeanUtils.copyProperties(attr,attrEntity); //1.保存基本数据 this.save(attrEntity); //2.保存关联关系 AttrAttrgroupRelationEntity relationEntity = new AttrAttrgroupRelationEntity(); relationEntity.setAttrGroupId(attr.getAttrGroupId()); relationEntity.setAttrId(attrEntity.getAttrId()); relationDao.insert(relationEntity);} 效果。属性表属性分组关系表 商品服务-API-平台属性-规格参数列表这个页面展示的是属性相关信息，数据来源于【属性表pms_attr】。但是【属性表pms_attr】中并没有【所属分类】和【所属分组】的信息。(1).【属性表pms_attr】中有【分类ID:catelog_id】，就是拿到分类ID再去分类表找到分类名称。(2).需要从【属性&amp;属性分组表pms_attr_attrgroup_relation】中获取【分组ID】【分组名称attr_group_name】。 12345select attr.*,category.`name` as category_name,attr_group.attr_group_name as group_namefrom pms_attr attrinner join pms_category category on attr.catelog_id=category.cat_idleft join pms_attr_attrgroup_relation relation on relation.attr_id=attr.attr_idleft join pms_attr_group attr_group on relation.attr_group_id = attr_group.attr_group_id; 新建响应数据AttrRespVo.java 1234567891011public class AttrRespVo extends AttrVo{ /** * 所属分类名字 */ private String catelogName; /** * 所属分组名字 */ private String groupName;} AttrController.java 123456@GetMapping(\"/base/list/{catelogId}\")public R baseAttrList(@RequestParam Map&lt;String, Object&gt; params, @PathVariable(\"catelogId\") Long catelogId){ PageUtils page = attrService.queryBaseAttrPage(params,catelogId); return R.ok().put(\"page\", page);} AttrServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637@Overridepublic PageUtils queryBaseAttrPage(Map&lt;String, Object&gt; params, Long catelogId) { QueryWrapper&lt;AttrEntity&gt; queryWrapper = new QueryWrapper&lt;&gt;(); if(catelogId!=0){ queryWrapper.eq(\"catelog_id\",catelogId); } String key = (String) params.get(\"key\"); if(!StringUtils.isEmpty(key)){ //attr_id attr_name queryWrapper.and((wrapper)-&gt;{ wrapper.eq(\"attr_id\",key).or().like(\"attr_name\",key); }); } IPage&lt;AttrEntity&gt; page = this.page( new Query&lt;AttrEntity&gt;().getPage(params), queryWrapper ); PageUtils pageUtils = new PageUtils(page); List&lt;AttrEntity&gt; records = page.getRecords(); List&lt;AttrRespVo&gt; attrRespVos = records.stream().map(attrEntity -&gt; { AttrRespVo attrRespVo = new AttrRespVo(); BeanUtils.copyProperties(attrEntity, attrRespVo); //设置分类和分组的名字 AttrAttrgroupRelationEntity attrId = relationDao.selectOne(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(\"attr_id\", attrEntity.getAttrId())); if (attrId != null) { AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(attrId.getAttrGroupId()); attrRespVo.setGroupName(attrGroupEntity.getAttrGroupName()); } CategoryEntity categoryEntity = categoryDao.selectById(attrEntity.getCatelogId()); if (categoryEntity != null) { attrRespVo.setCatelogName(categoryEntity.getName()); } return attrRespVo; }).collect(Collectors.toList()); pageUtils.setList(attrRespVos); return pageUtils;} 商品服务-API-平台属性-规格修改在回显数据的时候三级分类路径缺少。所以在AttrRespVo中添加属性catelogPath。 1234public class AttrRespVo extends AttrVo{ // ... private Long[] catelogPath;} AttrController.java 12345@RequestMapping(\"/info/{attrId}\")public R info(@PathVariable(\"attrId\") Long attrId){ AttrVo attrVo = attrService.getAttrInfo(attrId); return R.ok().put(\"attr\", attrVo);} AttrServiceImpl.java 12345678910111213141516171819202122232425262728@Overridepublic AttrVo getAttrInfo(Long attrId) { AttrRespVo attrRespVo = new AttrRespVo(); AttrEntity attrEntity = this.getById(attrId); BeanUtils.copyProperties(attrEntity,attrRespVo); if(attrEntity.getAttrType() == ProductConstant.AttrEnum.ATTR_TYPE_BASE.getCode()){ //1.设置分组信息 AttrAttrgroupRelationEntity attrgroupRelation = relationDao.selectOne(new QueryWrapper&lt;AttrAttrgroupRelationEntity&gt;().eq(\"attr_id\", attrEntity.getAttrId())); if(attrgroupRelation!=null){ attrRespVo.setAttrGroupId(attrgroupRelation.getAttrGroupId()); AttrGroupEntity attrGroupEntity = attrGroupDao.selectById(attrgroupRelation.getAttrGroupId()); if(attrGroupEntity!=null){ attrRespVo.setGroupName(attrGroupEntity.getAttrGroupName()); } } } //2.设置分类信息 Long catelogId = attrEntity.getCatelogId(); Long[] catelogPath = categoryService.findCatelogPath(catelogId); attrRespVo.setCatelogPath(catelogPath); CategoryEntity categoryEntity = categoryDao.selectById(catelogId); if(categoryEntity!=null){ attrRespVo.setCatelogName(categoryEntity.getName()); } return attrRespVo;} 商品服务-API-平台属性-销售属性维护AttrController.java 1234567@GetMapping(\"/{attrType}/list/{catelogId}\")public R baseAttrList(@RequestParam Map&lt;String, Object&gt; params, @PathVariable(\"catelogId\") Long catelogId, @PathVariable(\"attrType\") String type){ PageUtils page = attrService.queryBaseAttrPage(params,catelogId,type); return R.ok().put(\"page\", page);} 商品服务-API-平台属性-查询分组关联属性&amp;删除关联商品服务-API-平台属性-查询分组未关联的属性商品服务-API-新增商品-调试会员等级相关接口 商品服务-API-新增商品-调试会员等级相关接口 商品服务-API-新增商品-获取分类关联的品牌商品服务-API-新增商品-获取分类下所有分组以及属性商品服务-API-新增商品-商品新增vo抽取对于前端返回的json,可以使用bejson.com转化为JavaBean。下载代码拷贝到项目对应位置。 商品服务-API-新增商品-商品新增业务流程分析SpuInfoServiceImpl.java 123456789101112131415161718@Transactional@Overridepublic void saveSpuInfo(SpuSaveVo vo) { //1.保存spu基本信息 pms_spu_info //2.保存spu的描述图片 pms_spu_info_desc //3.保存spu的图片集 pms_sku_images //4.保存spu的规格参数 pms_product_attr_value //5.保存spu的积分信息 `zhelimall_sms`.sms_spu_bounds //6.保存当前spu对应的sku信息 //6.1 sku基本信息 pms_sku_info //6.2 sku的图片信息 pms_sku_images //6.3 sku的销售属性信息 pms_sku_sale_attr_value //6.4 sku的优惠信息、满减等信息 `zhelimall_sms`.sms_sku_ladder/sms_sku_full_reduction/sms_member_price} 商品服务-API-新增商品-保存SPU基本信息商品服务-API-新增商品-保存SKU基本信息商品服务-API-新增商品-调用远程服务保存优惠等信息在远程调用的时候，A服务想要给B服务发送数据，Spring Cloud会把数据封装成json发送过去。所以引申出新的领域模型TO。还因为这个TO对象A服务和B服务都要使用，所以建议把这个TO对象放在common模块中。 注：Mybatis-Plus会自动插入一个ID到实体类，导致设置的id失效。所以需要在@TableId指定type的类型。可参考链接 1SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; SpuInfoDescEntity.java 12345678910111213141516@Data@TableName(\"pms_spu_info_desc\")public class SpuInfoDescEntity implements Serializable { private static final long serialVersionUID = 1L; /** * 商品id */ @TableId(type = IdType.INPUT) private Long spuId; /** * 商品介绍 */ private String decript;} 介绍一下Mybatis-Plus几种生成ID类型枚举类的区别： 123456789101112131415161718192021222324252627282930313233343536@Getterpublic enum IdType { /** * 数据库ID自增 */ AUTO(0), /** * 该类型为未设置主键类型(将跟随全局) */ NONE(1), /** * 用户输入ID * &lt;p&gt;该类型可以通过自己注册自动填充插件进行填充&lt;/p&gt; */ INPUT(2), /* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */ /** * 全局唯一ID (idWorker) */ ID_WORKER(3), /** * 全局唯一ID (UUID) */ UUID(4), /** * 字符串全局唯一ID (idWorker 的字符串表示) */ ID_WORKER_STR(5); private final int key; IdType(int key) { this.key = key; }} 商品服务-API-新增商品-商品保存其他问题处理商品服务-API-商品管理-SPU检索 Spring配置时间格式 123spring: jackson: date-format: yyyy-MM-dd HH:mm:ss 商品服务-API-商品管理-SKU检索结束语","link":"/shop-mall/service-api.html"},{"title":"九、商城业务 | 商品上架","text":"【摘要】商城业务 shop-business~ 商城业务-商品上架-sku在es中存储模型分析上架的商品才可以在网站展示。上架的商品需要可以被检索。 商品Mapping分析：商品上架在es中是否存sku还是spu？(1).检索的时候输入名字，是需要按照sku的title进行全文检索的。(2).检索使用商品规格，规格是spu的公共属性，每个spu是一样的。(3).按照分类id进去的都是直接列出spu的，还可以切换。(4).我们如果将spu的全量信息保存到es中(包括spu属性)就太多字段了。(5).我们如果将spu以及其他包含的sku信息保存到es中，也可以方便检索。但是sku属于spu的级联对象，在es中需要nested模型，这种性能差点。(6).但是储存和检索我们必须性能折中。(7).如果我们分拆存储，spu和attr一个索引，sku单独一个索引可能涉及的问题。检索商品的名字，如”手机”，对应的spu有很多，我们要分析出这些spu的所有关联属性，再做一次查询，就必须将所有spu_id都发出去。假设有1万个数据，数据传输一次就10000*4=4MB; 并发情况下假设1000检索请求，那就是4GB的传输数据，传输阻塞时长会很长，业务更无法继续。所以，我们如下设计，这样才时文档区别于关系型数据库的地方，宽表设计，不能去考虑数据库范式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071PUT product{ \"mappings\": { \"properties\": { \"skuId\":{ \"type\": \"long\" }, \"spuId\":{ \"type\": \"keyword\" }, \"skuTitle\":{ \"type\": \"text\", \"analyzer\":\"ik_smart\" }, \"skuPrice\":{ \"type\": \"keyword\" }, \"skuImg\":{ \"type\": \"keyword\", \"index\": false, \"doc_values\": false }, \"saleCount\":{ \"type\": \"long\" }, \"hasStock\":{ \"type\": \"boolean\" }, \"hotScore\":{ \"type\": \"long\" }, \"brandId\":{ \"type\": \"long\" }, \"catalogId\":{ \"type\": \"long\" }, \"brandName\":{ \"type\": \"keyword\", \"index\": false, \"doc_values\": false }, \"brandImg\":{ \"type\": \"keyword\", \"index\": false, \"doc_values\": false }, \"catalogName\":{ \"type\": \"keyword\", \"index\": false, \"doc_values\": false }, \"attrs\":{ \"type\": \"nested\", \"properties\": { \"attrId\":{ \"type\": \"long\" }, \"attrName\":{ \"type\": \"keyword\", \"index\": false, \"doc_values\": false }, \"attrValue\":{ \"type\": \"keyword\" } } } } }} 商城业务-商品上架-nested数据类型场景https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html 商城业务-商品上架-构造基本数据创建数据传输对象SkuEsModel。这边的数据结构是根据所需要存在es中的数据结构定义的。这部分业务逻辑主要在 123456789101112131415161718192021222324252627282930package com.aiz.common.to.es;import lombok.Data;import java.math.BigDecimal;import java.util.List;@Datapublic class SkuEsModel { private Long skuId; private Long spuId; private String skuTitle; private BigDecimal skuPrice; private String skuImg; private Long saleCount; private Boolean hasStock; private Long hotScore; private Long brandId; private Long catalogId; private String brandName; private String brandImg; private String catalogName; private List&lt;Attr&gt; attrs; @Data public static class Attr{ private Long attrId; private String attrName; private String attrValue; }} 商城业务-商品上架-构造sku检索属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@Service(\"spuInfoService\")public class SpuInfoServiceImpl extends ServiceImpl&lt;SpuInfoDao, SpuInfoEntity&gt; implements SpuInfoService { @Override public void up(Long spuId) { //1.查出当前spuId对应的所有sku信息，品牌的名字。 List&lt;SkuInfoEntity&gt; skus = skuInfoService.getSkusBySpuId(spuId); List&lt;Long&gt; skuIdList = skus.stream().map(SkuInfoEntity::getSkuId).collect(Collectors.toList()); // TODO 4.查询当前sku的所有可以被用来检索的规格属性 List&lt;ProductAttrValueEntity&gt; baseAttrs = attrValueService.baseAttrlistforspu(spuId); List&lt;Long&gt; attrIds = baseAttrs.stream().map(attr -&gt; { return attr.getAttrId(); }).collect(Collectors.toList()); List&lt;Long&gt; searchAttrIds = attrService.selectSearchAttrIds(attrIds); Set&lt;Long&gt; idSet = new HashSet&lt;&gt;(searchAttrIds); List&lt;SkuEsModel.Attr&gt; attrs = new ArrayList&lt;&gt;(); List&lt;SkuEsModel.Attr&gt; attrList = baseAttrs.stream().filter(item -&gt; { return idSet.contains(item.getAttrId()); }).map(item -&gt; { SkuEsModel.Attr attrs1 = new SkuEsModel.Attr(); BeanUtils.copyProperties(item, attrs1); return attrs1; }).collect(Collectors.toList()); // TODO 1.发送远程调用，库存系统查询是否有库存 Map&lt;Long, Boolean&gt; stockMap = null; try{ R&lt;List&lt;SkuHasStockVo&gt;&gt; r = wareFeignService.getSkusHasStock(skuIdList); // TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt; typeReference = new TypeReference&lt;List&lt;SkuHasStockVo&gt;&gt;() {}; stockMap = r.getData(typeReference).stream().collect(Collectors.toMap(SkuHasStockVo::getSkuId, item -&gt; item.getHasStock())); }catch (Exception e){ log.error(\"库存服务查询异常:原因{}\",e); } //2.封装每个sku的信息 Map&lt;Long, Boolean&gt; finalStockMap = stockMap; List&lt;SkuEsModel&gt; upProducts = skus.stream().map(sku-&gt;{ //组装需要的数据 SkuEsModel esModel = new SkuEsModel(); BeanUtils.copyProperties(sku,esModel); //skuPrice,skuImg,hasStock,hotScore,brandName,brandImg,catalogName,attrs[attrId,attrName,attrValue] esModel.setSkuPrice(sku.getPrice()); esModel.setSkuImg(sku.getSkuDefaultImg()); //hasStock,hotScore // TODO 1.发送远程调用，库存系统查询是否有库存 //设置库存信息 if(finalStockMap == null){ esModel.setHasStock(true); }else{ esModel.setHasStock(finalStockMap.get(sku.getSkuId())); } // TODO 2.热度评分。0。 esModel.setHotScore(0L); // TODO 3.查询品牌和分类的名字信息 BrandEntity brand = brandService.getById(esModel.getBrandId()); esModel.setBrandName(brand.getName()); esModel.setBrandImg(brand.getLogo()); CategoryEntity category = categoryService.getById(esModel.getCatalogId()); esModel.setCatalogName(category.getName()); // TODO 4.查询当前sku的所有可以被用来检索的规格属性 //设置检索属性 esModel.setAttrs(attrList); return esModel; }).collect(Collectors.toList()); //TODO 5.将数据发送给es进行保存:zheli-search R r = searchFeignService.productStatusUp(upProducts); if(r.getCode() == 0){ //远程调用成功 //TODO 6.修改当前spu的状态 baseMapper.updateSpuStatus(spuId, ProductConstant.StatusEnum.SPU_UP.getCode()); }else{ //远程调用失败 //TODO 7.重复调用？接口幂等性：重试机制？xx /** * Feign调用流程 * SynchronousMethodHandler * 1.构造请求数据，将对象转为json； * RequestTemplate template = buildTemplateFromArgs.create(argv); * 2.发送请求进行执行(执行成功会解码响应数据)； * executeAndDecode(template) * 3.执行请求会有重试机制； * while(true){ * try{ * executeAndDecode(template); * }catch(){ * try{retryer.continueOrPropagate(e);}catch(){throw ex;} * continue; * } * } */ }} 商城业务-商品上架-远程查询库存&amp;泛型结果封装商城业务-商品上架-远程上架接口商城业务-商品上架-上架接口调试&amp;feign源码商城业务-商品上架-抽取响应结果&amp;上架测试完成分布式应用经常会因为服务不稳定，导致服务不可用。在服务启动第一次的时候，使用商品上架功能后台接口容易超时，多试几次就好了。 关于商品上架这一块业务比较复杂，我在后续会整理一张流程图。 商城业务-首页-整合thymeleaf渲染首页服务端的页面渲染式开发。pom.xml(zheli-product) 12345&lt;!-- 模板引擎：thymeleaf--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; application.yml(zheli-product) 123spring: thymeleaf: cache: false 目录结构：静态资源放static、html页面放templates。 123resources/ static/ templates/ 创建用来存放页面跳转的包com.aiz.zhelimall.product.web。把controller包改名为app。app包下面存放RESTful接口。web存放所有的controller。 使用模板引擎总结(一).thymeleaf-starter：关闭缓存(二).静态资源都放在static文件下就可以按照路径直接访问(三).页面都放在templates下，直接访问 SpringBoot 访问项目的时候，默认会找index可以参考WebMvcAutoConfiguration.welcomePageHandlerMapping()这个方法看。就可以理解为什么访问localhost:8000会转到resources/templates/index.html 商城业务-首页-整合dev-tools渲染一级分类数据IndexController.java 123456789101112131415161718@Controllerpublic class IndexController { @Autowired CategoryService categoryService; /* 首页面跳转 */ @GetMapping({\"/\",\"/index.html\"}) public String indexPage(Model model){ // TODO 1.查出所有1级分类 List&lt;CategoryEntity&gt; categoryEntityList = categoryService.getLeve1Categorys(); model.addAttribute(\"categorys\", categoryEntityList); /* * 默认前缀spring:thymeleaf:prefix = classpath:/templates/ * 默认后缀spring:thymeleaf:prefix = .html * 视图解析器进行拼串：classpath:/templates/ + 返回值 + .html */ return \"index\"; }} 由于我们使用的是thymeleaf模板引擎进行解析，这个类似于JSP，它也有自己的语法，比如${}取值变量等。想了解更多肯定得去官网了解一下。官网 首先给html文件加上thymeleaf的名称空间。 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 自定义属性和原生属性显示方式。 12345&lt;ul&gt; &lt;li th:each=\"category : ${categorys}\"&gt; &lt;a href=\"#\" class=\"header_main_left_a\" th:attr=\"ctg-data=${category.catId}\"&gt;&lt;b th:text=\"${category.name}\"&gt;家用电器&lt;/b&gt;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 为了页面修改不重启服务器实时更新。引入dev-tools。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 资源编译Build Project (Ctrl+F9)只对当前资源编译 (Ctrl+Shift+F9) 商城业务-首页-渲染二级三级分类数据商城业务-nginx-搭建域名访问环境一（反向代理配置）商城业务-nginx-搭建域名访问环境二（负载均衡到网关）","link":"/shop-mall/shop-business.html"},{"title":"六、微服务分布式电商系统--仓储服务API接口","text":"【摘要】仓储服务API接口~ 前言仓储服务-API-仓库管理-整合ware服务&amp;获取仓库列表仓储服务-API-仓库管理-查询库存&amp;创建采购需求仓储服务-API-仓库管理-合并采购需求仓储服务-API-仓库管理-领取采购单仓储服务-API-仓库管理-完成采购商品服务-API-商品管理-SPU规格维护","link":"/shop-mall/ware-service-api.html"},{"title":"三、微服务分布式电商系统--SpringCloud分布式组件Nacos注册中心、配置中心、OpenFeign远程调用、GateWay网关","text":"【摘要】在分布式开发中，首先我们必须要知道注册中心、配置中心和网关这三个概念。每一个微服务上线都需要将他自己注册到注册中心，这样做的好处就是如果一个服务想要调用另外一个服务，这个服务就可以去注册中心寻找哪几个服务上线了，就可以找到对应的服务调用了。各个服务的配置众多，如果商品服务在10台机器上都有，想要改配置很麻烦，有一个配置中心集中管理。前端发过来的请求经过统一的鉴权、过滤、路由等由网关抵达后台的服务，做一些预先的工作。 前言https://spring.io/projects/spring-cloud-netflix SpringCloud AlibabaSpringCloud Alibaba简介简介Spring Cloud Alibaba致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用的必须组件，方便开发者通过Spring Cloud编程模型轻松快速使用这些组件来开发分布式应用服务。依托Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将SpringCloud应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。https://github.com/alibaba/spring-cloud-alibaba 为什么使用它？ Spring Cloud的几大痛点： SpringCloud部分组件停止维护和更新，给开发带来不便。 SpringCloud部分环境搭建复杂，没有完善的可视化界面，我们需要大量的二次开发。 SpringCloud配置复杂，难以上手，部分配置差别难以区分和合理使用。 Spring Cloud Alibaba的优势： 阿里使用过的组件经历了考验，性能强悍，设计合理，现在开源状态。 成套的产品搭配完善的可视化界面给开发运维带来极大的便利。 搭建简单，学习曲线低。 结合Spring Cloud Alibaba我们最终的技术搭配方案： SpringCloud Alibaba - Nacos：注册中心(服务发现/注册) SpringCloud Alibaba - Nacos：配置中心(动态配置管理) SpringCloud - Ribbon：负载均衡 SpringCloud - Feign：声明式HTTP客户端(调用远程服务) SpringCloud Alibaba - Sentinel：服务容错(限流、降级、熔断) SpringCloud - Gateway：API网关(webflux 编程模式) SpringCloud - Sleuth：调用链监控 SpringCloud Albaba -Seata：原Fescar,即分布式事务解决方案 版本选择由于 Spring Boot 1 和 Spring Boot 2 在 Actuator 模块的接口和注解有很大的变更，且 spring-cloud-commons 从 1.x.x 版本升级到 2.0.0 版本也有较大的变更，因此我们采取跟 SpringBoot 版本号一致的版本: 1.5.x版本适用于Spring Boot 1.5.x 2.0.x版本适用于Spring Boot 2.0.x 2.1.x版本适用于Spring Boot 2.1.x … 项目中的依赖1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; SpringCloud Alibaba-Nacos 注册中心参考文档：Nacos Discovery ExampleNacos 快速开始Nacos是阿里巴巴开源的一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。他是使用Java编写的，需要依赖Java环境。 下载nacos-serverhttps://github.com/alibaba/nacos/releases 启动nacos-server 双击bin中的startup.cmd文件 访问ip:8848/nacos/ 使用默认的账号密码nacos/nacos进行登录 将服务注册到nacos中 1.首先，修改 pom.xml 文件，引入 Nacos Discovery Starter。 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 2.在应用的 /src/main/resources/application.properties 配置文件中配置 Nacos Server 地址。 1spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 这里配置在yml中也可以。 使用 @EnableDiscoveryClient 注解开启服务注册与发现功能。 12345678910111213141516@SpringBootApplication@EnableDiscoveryClientpublic class ProviderApplication { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @RestController class EchoController { @GetMapping(value = \"/echo/{string}\") public String echo(@PathVariable String string) { return string; } }} 启动应用，观察nacos服务列表启动应用，观察nacos服务列表是否已经注册上服务。 注意：每一个应用都应该有名字，这样才能注册上去。修改application.properties文件 12spring.application.name=service-provoiderserver.port=8000 同样的，可以把其他服务都注册到nacos中。 注册更多的服务上去，测试使用feign远程调用 Nacos使用三步 1.导包 nacos-discovery 2.写配置，指定nacos地址，指定应用的名字。 3.开启服务注册发现功能 @EnableDiscoveryClient。 Feign使用三步 1.导包openfeign 2.开启 @EnableFeignClients功能 3.编写接口，进行远程调用。12@RequestMapping(\"/coupon/coupon/member/list\")public R membercoupons(); SpringCloud Alibaba-Nacos 配置中心如何接入 1.首先，修改 pom.xml 文件，引入 Nacos Config Starter。1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 2.在应用的 /src/main/resources/bootstrap.properties 配置文件中配置 Nacos Config 元数据。12spring.application.name=nacos-config-examplespring.cloud.nacos.config.server-addr=127.0.0.1:8848 3.完成上述两步后，应用会从 Nacos Config 中获取相应的配置，并添加在 Spring Environment 的 PropertySources 中。这里我们使用 @Value 注解来将对应的配置注入到 SampleController 的 userName 和 age 字段，并添加 @RefreshScope 打开动态刷新功能。123456789@RefreshScopeclass SampleController { @Value(\"${user.name}\") String userName; @Value(\"${user.age}\") int age;} 在nacos中配置登录nacos控制台 → 配置服务 → 配置列表 → + 添加配置：发布之后再次访问。 总结 SpringCloud Alibaba-SentinelSpringCloud Alibaba-SeataSpringCloud Alibaba-OSSSpringCloudFeign声明式远程调用简介Fegin是一个声明式的HTTP客户端，它的目的就是让远程调用更加简单。Fegin提供了HTTP请求模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数、格式、地址等信息。Fegin整合了Ribbon(负载均衡)和Hystrix(服务熔断)，可以让我们不再需要显式地使用这两个组件。SpringCloudFeign在NetflixFeign的基础上扩展了对SpringMVC注解的支持，在其实现下，我们只需要创建一个接口并用注解的方式来配置它，即可完成对服务提供方的接口绑定。简化了SpringCloudRibbon自行封装服务调用客户端的开发量。 使用 1.引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 2.开启feign功能 1@EnableFeignClients(basePackages = \"com.aiz.zhelimall.member.feign\") 3.声明远程接口 12345@FeignClient(\"zheli-coupon\")public interface CouponFeignService { @RequestMapping(\"/coupon/coupon/member/list\") public R memberCoupons();} GateWay简介网关作为流量的入口，常用功能包括路由转发、权限校验、限流控制等。而spring cloud gateway作为SpringCloud官方推出的第二代网关框架，取代了Zuul网关。网关提供API全托管服务，丰富的API管理功能，辅助企业管理大规模的API，以降低管理成本和安全风险，包括协议适配、协议转发。安全策略、防刷、流量、监控日志等功能。Sprin Cloud GateWay旨在提供一种简单而有效的方式来对API进行路由，并为他们提供切面，例如：安全性，监控/指标和弹性等。官方文档地址：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.3.RELEASE/reference/html/ 核心概念使用 IDEA中创建项目 在IDEA中File-&gt;Module-&gt;Spring Initializr点进Next-&gt;… 导入依赖、开启服务注册发现功能、启动配置Nocas 断言(Predicate) 过滤器(Filter) 新建bootstrap.properties文件。在nacos中新建命名空间gateway。在启动的时候排除数据源。新建application.yml配置网关访问下面的地址，运行测试。 12http://localhost:88/hello?url=qqhttp://localhost:88/hello?url=baidu Sleuth+Zipkin服务链路追踪结束语","link":"/shop-mall/springcloud-distributed-components.html"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/%E6%9D%82%E8%AE%B0/hello-world.html"},{"title":"2019年度总结","text":"【摘要】现在是2019年12月31日21时6分45秒，距2020还有2时53分15秒。 前言有没有思考自己的生命还剩下几天？或许这句话作为开头太过残忍，但是事实就是这样，时间真的是太快了！不止一次的在网上各种论坛各种平台上看到有人这样说：仿佛2008年还是昨天，我们还是中学生。我想，可能是因为那年产生了太多的大事件，好的坏的都留在了我们这代人的记忆中。的确，2008年的金融危机、神七飞天、三聚氰胺、南方雪灾、汶川地震、北京奥运等等这些事情可能由他人一提及就会想到。为什么呢？简单的说可能是因为老师上课会讲、时政考试会考、电视台会放，又或许结合这些事件的时间可以回忆到自己的一段岁月。现在2019就要从眼前流过，想抓住，我知道不可能。既然抓不着，通过自己的方式记录一下，也会觉得安心吧！往前看一年，真的是碌碌无为。非要给个答案就是脱离学生身份后更加感受时间流逝的速度，所做的一切都和平庸紧紧缠绕在一起。 壹月刚刚考完研，不愿意去海安实习，自己呆在宿舍研究小程序。月末，大四寒假回家过年。 贰月在家过完年，徐州-&gt;南通。聚贤公寓住了几天，去了海安参加实训。考研成绩出来，意料之中的丢人。在海安参加实训，开始毕业设计，经常一个人在机房看纯洁的微笑的springboot系列文章和vue教程。 叁月蒸美味吃的够够的。家里人要求考公务员但是我裸考，因为时间都给六级了。 肆月回校，去了南京面试，收到第一份Offer。多方面考虑拒绝掉了。5号去了南通宜家。参加各种校园宣讲会。22号因为送午餐和报销路费，去了林洋面试。当场签了三方。 伍月五一假结束，5号正式到林洋报道，开始了第一份工作，实习工资4k。毕业设计的原因，周末经常往返南通-&gt;海安。 陆月班级拍毕业照。毕业答辩。放弃了公司组织去雁荡山旅游的机会，在15号参加了大学最后一场考试-六级。16号39块钱卖了大学大部分书籍。很艰难的做着公司交代的任务–C#前置机中日志的截取显示。月底，蹭考公上岸的同事离职聚餐。 柒月出差一周上海。7号，和同事在启东看海~22号正式启东-&gt;上海。提着两个行李箱背着书包和所有年轻人一样，来上海逐梦！租房在张江开始沪漂生活。no lb 捌月可能是因为项目组不景气吧，甲方变乙方。虽然这样，但是同事们对待我还是很热情蛮照顾的！三文鱼给买了个生日蛋糕。六级成绩出来，没通过。发了条抖音几十万的浏览量。 玖月对上海充满好奇，陌生和向往。和三文鱼去了个盗版的海洋馆。 拾月国庆回家，坐火车回家感觉没再有学生时代的感觉。19号人民广场相亲角。哈哈哈~ 拾壹月公司比较忙碌，自己比较懒，没做什么事情吧，还是我想不起来啊~ 拾贰月上海科技馆。意识到又要用完一年的危机，下班后开始在公司学习到深夜。 结束语不能因为平庸就忘记我的2019吧！这一年结束了1+6+3+3+4=17年的学生身份，转变为一名大城市的职场小员工。能够通过自己的双手养活自己了。真的，我还没有找到对的节奏，还会像之前那样打游戏追剧看电影来消磨时间。不要做”晚上想想千条路，白天起来走老路”这样的人就好吧。一直做事情，一直进步，2020年不焦虑。","link":"/%E6%9D%82%E8%AE%B0/2019-look-back.html"},{"title":"我为什么要写博客","text":"【摘要】文章首先肯定是写给自己看的，算是本笔记簿。其次，如果我的文章可以帮助到更多的人，那么也算是我为中华民族伟大复兴的路上贡献了一份微薄之力。哈哈哈哈哈哈~ 大概是因为蛋疼，哈哈哈。 2019-09-29更这么聊吧，技术圈优秀的人太多了。不，我做的压根不是技术，我就是一个搬砖的。哈哈哈。告别了校园生活，再也不要为了考试去学什么知识了。很惶恐，自己会不会虚度掉大好的时光？只知道青春渐行渐远，唯一可以留住这段岁月的大概就是好好沉淀自己吧。可能和大家一样，我也是遇到什么问题谷歌百度搜一下，之后就抛之脑后。很难再去保持系统的学习，所以，我想通过这种方式来记录一下，同时也是一种最好的监督形式。我有整理笔记的毛病，以前上学那会老是想把笔记记得漂亮一点。后来我才明白先听懂下课看同学笔记那样效率多高啊，自己体会~哈哈哈。“纸上得来终觉浅，绝知此事要躬行“，所以这次不一样，我要自己总结，自己输出。我的建议，程序员都应该有自己的博客，这不仅是自己的笔记，还是一张对外的简历，更是一份对技术的态度。 下次无聊再更~ 2020-01-04英雄出自小角色，谁人不曾打酱油。–猪猪侠第一集","link":"/%E6%9D%82%E8%AE%B0/why-blog.html"},{"title":"动态规划算法入门","text":"【摘要】 前言说来惭愧，大学期间对算法并不是很重视，对算法的研究也就是大二获得过省级三等奖的蓝桥杯。但是没有对算法进行系统的刷题练习，所以有些类型的算法也没有接触到。可是一般稍微大一点的互联网科技公司都会要求掌握基本的算法。这其中一定包括动态规划算法，这种算法和其他算法还有一定的区别：题目类型多、没有固定模板、难度偏高。对于没有接触过的人很难有什么思路。所以我打算单独写一篇文章来记录DP算法。 动态规划什么是动态规划？给定一个矩形网格，一个机器人从左上角出发，每次可以向下或向右走一步。 题A：求有多少种方式走到右下角。 题B：输出所有走到右下角的路径。 动态规划题目特点 计数 有多少种方式走到右下角 有多少种方式选出k个数使得和是Sum 求最大值最小值 从左上角走到右下角路径的最大数字和 最长上升子序列长度 求存在性 取石子游戏，先手是否必胜 能不能选出k个数使得和是Sum 牛刀小试换硬币问题题目描述12345给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 -1.你可以假设每种硬币均有无数个总金额不会超过10000硬币的种类数不会超过500, 每种硬币的面额不会超过100 123456789101112样例1输入：[1, 2, 5]11输出： 3解释： 11 = 5 + 5 + 1样例2输入： [2]3输出： -1 动态规划组成部分动态规划组成部分一：确定状态 状态在动态规划中的作用属于定海神针 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么？——类似于解数学题中,X,Y,Z代表什么？ 确定状态需要两个意识： 最后一步 子问题 最后一步 动态规划组成部分二：动态规划组成部分三：动态规划组成部分四：小结 求最值型动态规划 动态规划组成部分 确定状态 最后一步（最优策略中使用的最后一枚硬币ak） 化为子问题（最少的硬币拼出更小的面值27-ak） 转移方程 f[X] = min{f[X-2]+1,f[X-5]+1,f[X-7]+1} 初始条件和边界情况 f[0] = 0,如果不能拼出Y，f[X]=正无穷 计算顺序 f[0],f[1],f[2]…… 消除冗余，加速计算 不同的路径123456有一个机器人的位于一个 m × n 个网格左上角。机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。问有多少条不同的路径？n和m均不超过100且答案保证在32位整数可表示范围内。 123456789101112131415161718样例Example 1:Input: n = 1, m = 3Output: 1 Explanation: Only one path to target position.Example 2:Input: n = 3, m = 3Output: 6 Explanation: D : Down R : Right 1) DDRR 2) DRDR 3) DRRD 4) RRDD 5) RDRD 6) RDDR 跳跃游戏12345给出一个非负整数数组，你最初定位在数组的第一个位置。 数组中的每个元素代表你在那个位置可以跳跃的最大长度。 判断你是否能到达数组的最后一个位置。数组A的长度不超过5000，每个元素的大小不超过5000 1234567样例 1输入 : [2,3,1,1,4]输出 : true样例 2输入 : [3,2,1,0,4]输出 : false 乘积最大子序列问题1234找出一个序列中乘积最大的连续子序列（至少包含一个数）。数组长度不超过20000乘积最大的子序列的积，小于2147483647 1234567样例 1:输入:[2,3,-2,4]输出:6样例 2:输入:[-1,2,4,1]输出:8 结束语bye~","link":"/data-structure/dynamic-programming.html"},{"title":"十二、商城业务 | 商品检索","text":"【摘要】商城业务 | 商品检索 前言173、商城业务-检索服务-搭建页面环境在zheli-search.pom添加依赖。 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 把搜索页/html拷贝到search服务的resources/templates下。其他静态资源放置在nginx/html/static/search中。 修改host文件，添加search.zhelimall.com 127.0.0.1。 修改nginx/conf/conf.d/zhelimaill.conf中的server_name。 12345server{ # ... server_name zhelimall.com *.zhelimall.com; # ...} 配置网关服务 123456789- id: zhelimall_host_route uri: lb://zheli-product predicates: - Host=zhelimall.com- id: zhelimall_search_route uri: lb://zheli-search predicates: - Host=search.zhelimall.com 重启网关服务、搜索服务和nginx。访问search.zhelimall.com就可以看到对应的页面了。 配置完成后Nginx的转发效果如下所示。 174、商城业务-检索服务-调整页面跳转前面搭建好了检索的页面，接下来就来梳理一下整个商城的检索逻辑。 引入devtools热启动，关闭thymeleaf缓存功能。 application.properties 1spring.thymeleaf.cache=false 通过现有的分析，我们在首页有两处会进入搜索页面。第一处是通过点击分类，第二处是搜索框。 点击搜索跳转到的是http://search.zhelimall.com/list.html?catalog3Id=225。 1234567891011121314package com.aiz.zhelimall.search.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class SearchController { @GetMapping(\"/list.html\") public String listPage(){ return \"index\"; }} 175、商城业务-检索服务-检索查询参数模型分析抽取检索业务分析商品检索三个入口： 选择分类进入商品检索 输入检索关键字展示检索页 选择筛选条件进入 检索条件&amp;排序条件 全文检索：skuTitle -&gt; keyword 排序：saleCount（销量）、hotScore（热度分）、skuPrice（价格） 过滤：hasStock、skuPrice区间、brandId、catalog3Id、attrs 聚合：attrs 完整查询参数 keyword=小米 &amp;sort=saleCount_desc/asc&amp;hasStock=0/1&amp;skuPrice=400_1900&amp;brandId=1&amp;catalog3Id=1&amp;attrs=1_3G:4G:5G&amp;attrs=2_骁龙845&amp;attrs=4_高清屏 检索语句构建结果提取封装检索条件分析。 SearchParam.java 123456789101112131415161718192021222324252627282930313233343536373839/** * @Description 封装页面所有可能传递过来的查询条件 */@Datapublic class SearchParam { /** * 检索关键字 */ private String keyword;//页面传递过来的全文匹配关键字 //三级分类ID private Long catalog3Id; /** * sort=saleCount_asc/desc * sort=hotScore_asc/desc * sort=skuPrice_asc/desc */ private String sort;//排序条件(saleCount（销量）、hotScore（热度分）、skuPrice（价格）) /** * 好多的过滤条件 * hasStock(是否有货)、skuPrice区间、brandId、catalog3Id、attrs * hasStock=0/1 * skuPrice=1_500/_500/500 * brandId=1 * attrs=2_5寸:6寸 */ //是否有库存(0表示无库存，1表示有库存) private Integer hasStock; //价格区间查询 private String skuPrice; //按照品牌进行查询，可以多选 private List&lt;Long&gt; brandId; //按照属性进行筛选 private List&lt;String&gt; attrs; //页码 private Integer pageNum = 1;} SearchController.java 123456789101112131415161718@Controllerpublic class SearchController { @Autowired MallSearchService mallSearchService; /** * 自动将页面提交过来的所有请求查询参数封装成指定的对象 * @param searchParam * @return */ @GetMapping(\"/list.html\") public String listPage(SearchParam searchParam){ Object result = mallSearchService.search(searchParam); return \"index\"; }} 176、商城业务-检索服务-检索返回结果模型分析抽取前面已经把页面提交过来的所有请求查询参数封装成指定的对象，这部分需要分析检索返回结果的模型。观察页面可以知道这边返回的应该是所有的商品信息。由于我们是在es中检索的，所以我们查到的也是es中商品的模型数据。 SearchResult.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @ClassName SearchResult * @Description 返回给页面的所有信息 */@Datapublic class SearchResult { /** * 查询到的所有商品信息 */ private List&lt;SkuEsModel&gt; products; /** * 以下是分页信息 */ private Integer pageNum;//当前页码 private Long total;//总记录数 private Integer totalPages;//总页码 /** * 当前查询到的结果，所有涉及到的品牌 */ private List&lt;BrandVo&gt; brands; /** * 当前查询到的结果，所有涉及到的分类 */ private List&lt;CatalogVo&gt; catalogs; /** * 当前查询到的结果，所有涉及到的所有属性 */ private List&lt;AttrVo&gt; attrs; //以上是返回给页面的所有信息 @Data public static class BrandVo{ private Long brandId; private String brandName; private String brandImg; } @Data public static class CatalogVo{ private Long catalogId; private String catalogName; } @Data public static class AttrVo{ private Long attrId; private String attrName; private List&lt;String&gt; attrValue; }} 177、商城业务-检索服务-检索DSL测试-查询部分178、商城业务-检索服务-检索DSL测试-聚合部分 179、商城业务-检索服务-SearchRequest构建-检索 180、商城业务-检索服务-SearchRequest构建-排序、分页、高亮&amp;测试 181、商城业务-检索服务-SearchRequest构建-聚合 182、商城业务-检索服务-SearchResponse分析&amp;封装 183、商城业务-检索服务-验证结果封装正确性 184、商城业务-检索服务-页面基本数据渲染 185、商城业务-检索服务-页面筛选条件渲染 186、商城业务-检索服务-页面分页数据渲染 187、商城业务-检索服务-页面排序功能 188、商城业务-检索服务-页面排序字段回显 189、商城业务-检索服务-页面价格区间搜索 190、商城业务-检索服务-面包屑导航 191、商城业务-检索服务-条件删除与URL编码问题 192、商城业务-检索服务-条件筛选联动","link":"/shop-mall/shop-business-search.html"},{"title":"机器学习入门","text":"【摘要】浏览网页无意中点进CSDN上的机器学习_入门经典这门课程，虽说到现在为止我给自己定的方向和机器学习没关系，但是好奇心的强烈推动，驱使着我想要揭开听起来就高大上的机器学习的神秘面纱。 第一章：前言为什么学习编程？“Everybody in this country should learn how to program a computer…because it teaches you how to think.”–Steve Jobs Bill Create Microsoft 13岁开始接触电脑；Jack Create twitter；扎克伯格 Facebook 六年级接触电脑；CHRIS NBA ALL-STAR CODE IN COLLEGE；… 2014年英国将编程列为必修课；2019年日本把编程列入小学必修课；2018年3月计算机二级加入了”Python语言程序设计“； 编程入门网站：https://code.org/ 第二章：机器学习概述机器学习是什么？机器学习就是电脑通过学习数据来近似模仿人脑，自动做出决策。 在面对一件问题时，我们人世根据经验来决策(Learn from experience)，而计算机是根据指令进行的(Follow instructions)，但是机器可以Learn from data。 第三章：Python机器学习资源Python机器学习书籍推荐Python经典书籍推荐，左边入门，右边机器学习原理。 Python第三方包下载地址针对windows非官方的第三方扩展包下载网站：https://www.lfd.uci.edu/~gohlke/pythonlibs/ Python机器学习常用的包学习顺序：Numpy –&gt; Pandas –&gt; Matplotlib&amp;Seaborn –&gt; Scipy&amp;Statsmodels –&gt; Sklearn –&gt; TensorFlow&amp;Keras&amp;openCV Numpy：关于Python自然科学计算的包，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。https://numpy.org/ Pandas：是一个强大的分析结构化数据的工具集；它的使用基础是Numpy(提供高性能的矩阵运算);用于数据挖掘和数据分析，同时也提供数据清洗功能。https://pandas.pydata.org/ Matplotlib：Matplotlib 是 Python 的绘图库。https://matplotlib.org/ Seaborn：和Matplotlib对比Seaborn是Matplotlib的强大的一个扩展。http://seaborn.pydata.org/ Scipy：是一个开源的数学、科学和工程计算包。https://www.scipy.org/ Statsmodels：是Python的统计建模和计量经济学工具包,包括一些描述统计、统计模型估计和推断。https://www.statsmodels.org/stable/index.html Sklearn：Scikit-learn(sklearn)是机器学习中常用的第三方模块，对常用的机器学习方法进行了封装，包括回归(Regression)、降维(Dimensionality Reduction)、分类(Classfication)、聚类(Clustering)等方法。https://scikit-learn.org/stable/ TensorFlow：是一个采用数据流图(data flow graphs),用于数值计算的开源软件库。https://tensorflow.google.cn/ Keras：是一个由Python编写的开源人工神经网络库，可以作为Tensorflow、Microsoft-CNTK和Theano的高阶应用程序接口，进行深度学习模型的设计、调试、评估、应用和可视化。https://keras.io/zh/ openCV：是一个基于BSD许可（开源）发行的跨平台计算机视觉和机器学习软件库。https://opencv.org/ 机器学习知名数据库介绍加州大学欧文分校提出的用于机器学习的数据库：http://archive.ics.uci.edu/ml/index.php 第四章：监督机器学习算法线性回归-房价预测线性回归和误差 (Linear Regression And Error) 误差最小的方程式位置-梯度下降（最小二乘法） 多项式回归 逻辑回归-预测考试成绩是否能被大学录取Logistic Regression 逻辑回归用于解决二分类问题。 逻辑回归在信用评分卡有几十年应用。 梯度递减。 决策树-APP智能推荐系统Recommending Apps 朴素贝叶斯-垃圾邮件过滤系统应用Detecting Span e-mails SVM支持向量原理（Support Vector Machine） 什么是margin和hyperplane(超平面)？ Kernel Trick（核函数） 神经网络算法自动玩超级马里奥第五章：无监督学习算法kmean-如何选择披萨店地址K-Means Clustering 层次聚类算法hierarchical clustering 第六章：Python机器学习实战Anaconda下载和安装https://www.anaconda.com/ Python第三方包安装123conda install basemap# 或者pip intsall numpy Python机器学习实战-泰坦尼克号生存分析 Python信用评分卡-风控信贷守护神 Python风控建模实战lendingclub-2018年新算法秒杀xgboost 金融现金贷用户数据分析和画像Python机器学习乳腺癌细胞挖掘第七章：蒙特卡洛算法 python蒙特卡洛算法与赌博模型 结束语这个视频实战部分主要是推荐课程的，加上我目前本职工作并不是做Python机器学习的，所以也就没有再往下看。从视频中可以听出来机器学习这一块比较重视数学和算法功底。确实比我这CRUD程序员吊！","link":"/machine-learning/machine-learning.html"},{"title":"十一、缓存和分布式锁","text":"【摘要】缓存和分布式锁 前言151、缓存-缓存使用-本地缓存与分布式缓存缓存使用为了系统性能的提升，我们一般都会将部分数据放入缓存中，加速访问。而db承担数据落盘工作。 哪些数据适合放入缓存？ 即时性、数据一致性要求不高的。 访问量大且更新频率不高的数据(读多，写少)。 举例：电商类应用，商品分类，商品列表等适合缓存并加一个失效时间(根据数据更新频率来定)，后台如果发布一个商品，买家需要5分钟才能看到新的商品一般还是可以接受的。 123456data = cache.load(id);//从缓存中加载数据if(data==null){ data = db.load(id);//从数据库加载数据 cache.put(id,data);//保存到cache中}return data; 注意：在开发中，凡是放入缓存中的数据我们应该指定过期时间，使其可以在系统即使没有主动更新数据也能自动触发数据加载进缓存的流程。避免业务奔溃导致我们的数据永久不一致问题。 这种本地缓存每个实例都有自己的缓存，可能会出现数据不一致的情况。同时本地缓存还会占用堆内存，影响垃圾回收、影响系统性能。 所以我们需要使用分布式缓存，不应该把缓存放在每一个微服务的进程中。常用的缓存中间件是Redis。使用缓存中间件还可以无限扩容。 152、缓存-缓存使用-整合redis测试引入Reids。(pom.xml) 12345&lt;!-- 引入Redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置Redis。(application.yml) 12345spring: redis: host: 127.0.0.1 port: 6379 password: redis ZheliProductApplicationTests.java 12345678910111213@Autowiredprivate StringRedisTemplate stringRedisTemplate;@Testpublic void testStringRedisTemplate(){ //hello world ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); //保存 ops.set(\"hello\",\"world_\"+ UUID.randomUUID().toString()); //查询 String hello = ops.get(\"hello\"); System.out.println(\"之前保存的数据是：\"+hello);} 控制台打印 1之前保存的数据是：world_0a678d76-d227-4c10-807e-00d6320b01ce 153、缓存-缓存使用-改造三级分类业务123456789101112131415161718192021@Autowiredprivate StringRedisTemplate redisTemplate;@Overridepublic Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJson(){ //给缓存中放json字符串，拿出的json字符串，还需要逆转为能用的对象类型；【序列化与反序列化】 //1.加入缓存逻辑，缓存中存的是json字符串 //JSON跨语言、跨平台兼容 String catalogJson = redisTemplate.opsForValue().get(\"catalogJson\"); if(StringUtils.isEmpty(catalogJson)){ //2.缓存中没有，查询数据库 Map&lt;String, List&lt;Catalog2Vo&gt;&gt; catelogJsonFromDb = getCatalogJsonFromDb(); //3.查到的数据再放入缓存，将对象转为json放在缓存中 String s = JSON.toJSONString(catelogJsonFromDb); redisTemplate.opsForValue().set(\"catalogJson\",s); } //转为我们指定的对象 Map&lt;String, List&lt;Catalog2Vo&gt;&gt; result = JSON.parseObject(catalogJson,new TypeReference&lt;Map&lt;String, List&lt;Catalog2Vo&gt;&gt;&gt;(){}); return result;} 154、缓存-缓存使用-压力测试出的内存泄露及解决 1.springboot2.0以后默认使用lettuce作为操作redis的客户端。它使用netty进行网络通信。 2.lettuce的bug导致netty堆外内存溢出-Xmx300m：netty如果没有指定堆外内存，默认使用-Xmx300m 解决方案：可以通过-Dio.netty.maxDirectMemory只去调大堆外内存。(1).升级lettuce客户端。 (2).切换使用jedis。 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; redisTemplate:lettuce、jedis操作redis的底层客户端。Spring再次封装redisTemplate。 缓存-缓存使用-缓存击穿、穿透、雪崩缓存穿透： 指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是 数据库也无此记录，我们没有将这次查询的null写入缓存，这将导致这个不 存在的数据每次请求都要到存储层去查询，失去了缓存的意义 风险： 利用不存在的数据进行攻击，数据库瞬时压力增大，最终导致崩溃 解决： null结果缓存，并加入短暂过期时间 缓存雪崩： 缓存雪崩是指在我们设置缓存时key采用了相同的过期时间， 导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时 压力过重雪崩。解决： 原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这 样每一个缓存的过期时间的重复率就会降低，就很难引发集体 失效的事件。 缓存穿透： 对于一些设置了过期时间的key，如果这些key可能会在某些 时间点被超高并发地访问，是一种非常“热点”的数据。如果这个key在大量请求同时进来前正好失效，那么所有对 这个key的数据查询都落到db，我们称为缓存击穿。解决： 加锁大量并发只让一个去查，其他人等待，查到以后释放锁，其他 人获取到锁，先查缓存，就会有数据，不用去db 数据穿透：查询一个不存在的数据。缓存null。 数据雪崩：大面积数据同时失效。设置随机过期时间。 数据击穿：大量请求时正好失效。加锁。 缓存-缓存使用-加锁解决缓存击穿问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Overridepublic Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJson(){ /** * 1.空结果缓存：解决缓存穿透。 * 2.设置过期时间(加随机值)：解决缓存雪崩。 * 3.加锁：解决缓存击穿。 */ String catalogJson = redisTemplate.opsForValue().get(\"catalogJson\"); if(StringUtils.isEmpty(catalogJson)){ System.out.println(\"缓存不命中，将要查询数据库......\"); Map&lt;String, List&lt;Catalog2Vo&gt;&gt; catelogJsonFromDb = getCatalogJsonFromDb(); return catelogJsonFromDb; } System.out.println(\"缓存命中，直接返回......\"); Map&lt;String, List&lt;Catalog2Vo&gt;&gt; result = JSON.parseObject(catalogJson,new TypeReference&lt;Map&lt;String, List&lt;Catalog2Vo&gt;&gt;&gt;(){}); return result;}public Map&lt;String, List&lt;Catalog2Vo&gt;&gt; getCatalogJsonFromDb() { //只要是同一把锁，就能锁住需要这个锁的所有线程。 //1.synchronized (this)：SpringBoot所有的组件在容器中都是单例的。 //TODO 本地锁：synchronized,JUC(Lock),在分布式情况下，想要锁住所有，必须使用分布式锁。 synchronized (this){ //得到锁以后，我们应该再去缓存中确认一次，如果没有才需要继续查询。 String catalogJson = redisTemplate.opsForValue().get(\"catalogJson\"); if(!StringUtils.isEmpty(catalogJson)){ //缓存不为空，之间返回 Map&lt;String, List&lt;Catalog2Vo&gt;&gt; result = JSON.parseObject(catalogJson,new TypeReference&lt;Map&lt;String, List&lt;Catalog2Vo&gt;&gt;&gt;(){}); return result; } System.out.println(\"查询了数据库......\"); /** * 1.将数据库的多次查询变成一次 */ List&lt;CategoryEntity&gt; selectList = baseMapper.selectList(null); //1.查出所有一级分类 List&lt;CategoryEntity&gt; leve1Categorys = getParent_cid(selectList,0L);//getLeve1Categorys(); //2.封装数据 Map&lt;String, List&lt;Catalog2Vo&gt;&gt; parent_cid = leve1Categorys.stream().collect(Collectors.toMap(k -&gt; k.getCatId().toString(), v -&gt; { //1.每一个的一级分类。查到这个一级分类的二级分类 List&lt;CategoryEntity&gt; categoryEntities = getParent_cid(selectList,v.getCatId()); //2.封装上面的结果 List&lt;Catalog2Vo&gt; catalog2Vos = null; if (categoryEntities != null) { catalog2Vos = categoryEntities.stream().map(l2 -&gt; { Catalog2Vo catalog2Vo = new Catalog2Vo(v.getCatId().toString(), null, l2.getCatId().toString(), l2.getName()); //1.找当前二级分类的三级分类封装成vo List&lt;CategoryEntity&gt; level3Catelog = getParent_cid(selectList,l2.getCatId()); if(level3Catelog!=null){ List&lt;Catalog2Vo.Catalog3Vo&gt; collect = level3Catelog.stream().map(l3 -&gt; { Catalog2Vo.Catalog3Vo catalog3Vo = new Catalog2Vo.Catalog3Vo(l2.getCatId().toString(), l3.getCatId().toString(), l3.getName()); return catalog3Vo; }).collect(Collectors.toList()); catalog2Vo.setCatalog3List(collect); } return catalog2Vo; }).collect(Collectors.toList()); } return catalog2Vos; })); //3.查到的数据再放入缓存，将对象转为json放在缓存中 String s = JSON.toJSONString(parent_cid); redisTemplate.opsForValue().set(\"catalogJson\",s,1, TimeUnit.DAYS); return parent_cid; }} 157、缓存-缓存使用-本地锁在分布式下的问题 首先需要在idea中启动多个springboot实例。右击Services中的ZheliProductApplication，然后选择Copy Configuration。然后设置参数，Name修改为可以分辨出的就可以，Product arguments修改为--server.port=8004。 缓存-分布式锁-分布式锁原理与使用 我们这边的分布式锁使用redis的setnx实现；http://www.redis.cn/commands/set.html 缓存-分布式锁-Redisson简介&amp;整合https://redis.io/topics/distlock https://github.com/redisson/redisson/wiki/Table-of-Content https://mvnrepository.com/artifact/org.redisson/redisson 整合redisson作为分布式锁等功能框架(一).引入依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.12.0&lt;/version&gt;&lt;/dependency&gt; (二).配置redisson https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95 123456789101112131415161718@Configurationpublic class MyRedissonConfig { /** * 所有对Redisson的使用都是通过RedissonClient对象 * @return * @throws IOException */ @Bean(destroyMethod=\"shutdown\") RedissonClient redisson() throws IOException { //1.创建配置 Config config = new Config(); config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\"); //2.根据Config创建出RedissonClient示例 RedissonClient redissonClient = Redisson.create(config); return redissonClient; }} 测试 1234567891011@Slf4j@SpringBootTestclass ZheliProductApplicationTests { @Autowired private RedissonClient redissonClient; @Test public void testRedisson(){ System.out.println(redissonClient);//org.redisson.Redisson@cfacf0 }} 160、缓存-分布式锁-Redisson-lock锁测试161、缓存-分布式锁-Redisson-lock看门狗原理-redisson如何解决死锁可重入锁（Reentrant Lock）123456789101112131415161718192021222324252627282930@ResponseBody@GetMapping(\"/hello\")public String hello(){ //1.获取一把锁，只要锁的名字一样，就是同一把锁。 RLock lock = redisson.getLock(\"my-lock\"); //2.加锁 //lock.lock();//阻塞式等待，默认加的锁时间都是30s。 //(1).锁的自动续期，如果业务超长，运行期间自动给锁续上新的30s。不用担心业务时间长，锁自动过期被删除。【看门狗】 //(2).加锁的业务只有运行完成，就不会给当前锁续期，即使不手动解锁，锁默认在30s以后自动续期。 lock.lock(10, TimeUnit.SECONDS);//10s自动解锁,自动解锁时间一定要大于业务的执行时间。 //问题：lock.lock(10, TimeUnit.SECONDS);在锁时间到了之后不会自动续期。 //(1).如果传递了锁的超时时间，就发送给redis执行脚本，进行占锁，默认超时时间就是我们传递的时间 //(2).如果我们未指定锁的超时时间，就使用30*1000。【lockWatchdogTimeout看门狗默认时间】 // 只要占锁成功，就会启动一个定时任务【重新给锁设置过期时间，新的过期时间就是看门狗的默认时间】,每隔10s都会自动再次续期满30s // internalLockleaseTime【看门狗时间】/3，10s // 最佳实战 //(1).lock.lock(30, TimeUnit.SECONDS);//省掉了整个续期操作，手动解锁 try{ System.out.println(\"加锁成功，执行业务......\"+Thread.currentThread().getId()); Thread.sleep(30*1000); } catch (InterruptedException e) { } finally { //3.解锁。假设解锁代码没有运行，redisson会不会出现死锁？不会！ System.out.println(\"释放锁......\"+Thread.currentThread().getId()); lock.unlock(); } return \"Hello\";} 打开浏览器两个窗口同时访问http://localhost:8000/hello。会发现同时只有一个线线程会获取锁对象。控制台信息打印如下。 1234加锁成功，执行业务......424释放锁......424加锁成功，执行业务......426释放锁......426 运行过程中，Redis中的状态。当运行完毕后或者超时my-lock数据会过期。 162、缓存-分布式锁-Redisson-读写锁测试163、缓存-分布式锁-Redisson-读写锁补充读写锁（ReadWriteLock）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@ResponseBody@GetMapping(\"/write\")public String writeValue(){ RReadWriteLock lock = redisson.getReadWriteLock(\"rw-lock\"); RLock rLock = lock.writeLock(); String s = \"\"; try{ //改数据加写锁，读数据加读锁。 rLock.lock(); System.out.println(\"写锁加锁成功...\"+Thread.currentThread().getId()); s = UUID.randomUUID().toString(); Thread.sleep(30*1000); redisTemplate.opsForValue().set(\"writeValue\",s); } catch (InterruptedException e) { e.printStackTrace(); }finally { rLock.unlock(); System.out.println(\"写锁释放...\"+Thread.currentThread().getId()); } return s;}//保证一定能读到最新数据，修改期间，写锁是一个排他锁（互斥锁，独享），读锁使一个共享锁。//写锁没释放读就必须等待//读+读 相当于无锁，并发读只会在redis中记录好所有当前的读锁，他们都会同时加锁成功//写+读 等待写锁释放//写+写 阻塞方式//读+写 有读锁，写也需要等待//只要有写的存在，都必须等待。@ResponseBody@GetMapping(\"/read\")public String readValue(){ RReadWriteLock lock = redisson.getReadWriteLock(\"rw-lock\"); System.out.println(\"读锁加锁成功...\"+Thread.currentThread().getId()); String s = \"\"; //加读锁 RLock rLock = lock.readLock(); rLock.lock(); try{ s = redisTemplate.opsForValue().get(\"writeValue\"); } catch (Exception e) { e.printStackTrace(); }finally { rLock.unlock(); System.out.println(\"读锁释放...\"+Thread.currentThread().getId()); } return s;} 164、缓存-分布式锁-Redisson-信号量测试信号量（Semaphore）1234567891011121314151617181920212223242526/** * 车位停车 * 3车位 * 信号量也可以用作分布式限流 */@ResponseBody@GetMapping(\"/park\")public String park() throws InterruptedException { RSemaphore park = redisson.getSemaphore(\"park\"); //park.acquire();//获取一个信号，获取一个值，占一个车位 boolean b = park.tryAcquire(); if(b){ //执行业务 }else{ return \"error\"; } return \"ok=&gt;\"+b;}@ResponseBody@GetMapping(\"/go\")public String go() throws InterruptedException { RSemaphore park = redisson.getSemaphore(\"park\"); park.release();//释放一个车位 return \"ok\";} 165、缓存-分布式锁-Redisson-闭锁测试闭锁（CountDownLatch）12345678910111213141516171819202122/** * 放假,锁门 * 1班没人了，2班没人了... * 5个班级全部走完，我们可以锁大门 */@ResponseBody@GetMapping(\"/lockDoor\")public String lockDoor() throws InterruptedException { RCountDownLatch door = redisson.getCountDownLatch(\"door\"); door.await();//等待闭锁都完成 return \"放假了...\";}@ResponseBody@GetMapping(\"/gogogo/{id}\")public String gogogog(@PathVariable(\"id\") Long id){ RCountDownLatch door = redisson.getCountDownLatch(\"door\"); door.countDown();//计数减-- return id+\"班的人都走了...\";} 166、缓存-分布式锁-缓存一致性解决 无论是双写模式还是失效模式，都会导致缓存的不一致问题。即多个实例同时更新会出事。怎么办？ 如果是用户纬度数据（订单数据、用户数据），这种并发几率非常小，不用考虑这个问题，缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。 如果是菜单，商品介绍等基础数据，也可以去使用canal订阅binlog的方式。 缓存数据+过期时间也足够解决大部分业务对于缓存的要求。 通过加锁保证并发读写，写写的时候按顺序排好队。读读无所谓。所以适合使用读写锁。（业务不关心脏数据，允许临时脏数据可忽略）； 总结： 我们能放入缓存的数据本就不应该是实时性、一致性要求超高的。所以缓存数据的时候加上过期时间，保 证每天拿到当前最新数据即可。 我们不应该过度设计，增加系统的复杂性。 遇到实时性、一致性要求高的数据，就应该查数据库，即使慢点。 167、缓存-SpringCache-简介 168、缓存-SpringCache-整合&amp;体验@Cacheable整合SpringCache简化缓存开发 12345678910111213141516(一).引入依赖 spring-boot-starter-cache、spring-boot-starter-data-redis (二).写配置 (1).自动配置了哪些？ CacheAutoConfiguration会导入RedisCacheConfiguration 自动配置好了缓存管理器RedisCacheManager (2).配置使用redis作为缓存 在application.properties中配置。 (3).测试使用缓存 @Cacheable: Triggers cache population.触发将数据保存到缓存的操作 @CacheEvict: Triggers cache eviction.触发将数据从缓存删除的操作 @CachePut: Updates the cache without interfering with the method execution.不影响方法执行更新缓存 @Caching: Regroups multiple cache operations to be applied on a method.组合以上多个操作 @CacheConfig: Shares some common cache-related settings at class-level.在类级别共享缓存的相同配置 (1).开启缓存功能@EnableCaching (2).只需要使用注解就能完成缓存操作 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-cache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 12345678//CategoryServiceImpl.java//每一个需要缓存的数据我们都来指定要放到哪个名字的缓存。【缓存的分区（按照业务类型分）】@Cacheable({\"category\"}) //代表当前方法的结果需要缓存，如果缓存中有，方法不有调用；如果缓存中没有，那就会调用方法，将方法的结果放入缓存@Overridepublic List&lt;CategoryEntity&gt; getLeve1Categorys() { List&lt;CategoryEntity&gt; categoryEntities = baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(\"parent_cid\", 0)); return categoryEntities;} 运行加了@Cacheable注解的方法，可以在redis中查看缓存数据。 169、缓存-SpringCache-@Cacheable细节设置12#单位是毫秒spring.cache.redis.time-to-live=3600000 1234567891011121314151617181920212223/** * 1.每一个需要缓存的数据我们都来指定要放到哪个名字的缓存。【缓存的分区（按照业务类型分）】 * 2.@Cacheable({\"category\"}) //代表当前方法的结果需要缓存，如果缓存中有，方法不有调用；如果缓存中没有，那就会调用方法，将方法的结果放入缓存 * 3.默认行为 * (1).如果缓存命中，方法不用调用。 * (2).key默认自动生成：缓存名字::SimpleKey[](自主生成的key值) * (3).缓存的value的值。默认使用jdk序列化机制，将序列化后的数据存到redis。 * (4).默认ttl时间：-1。 * 自定义 * (1).指定生成的缓存使用的key：key属性指定，接受一个SpEL。 * (2).指定缓存的数据的存活时间：配置文件中修改ttl * (3).将数据保存为json格式： * @return */@Cacheable(value = {\"category\"},key = \"#root.method.name\")@Overridepublic List&lt;CategoryEntity&gt; getLeve1Categorys() { System.out.println(\"getLeve1Categorys......\"); long l = System.currentTimeMillis(); List&lt;CategoryEntity&gt; categoryEntities = baseMapper.selectList(new QueryWrapper&lt;CategoryEntity&gt;().eq(\"parent_cid\", 0)); System.out.println(\"消耗时间\"+(System.currentTimeMillis()-l)); return categoryEntities;} SpEL语法：https://docs.spring.io/spring-framework/docs/5.3.0-SNAPSHOT/reference/html/integration.html#cache-spel-context 170、缓存-SpringCache-自定义缓存配置123456789101112@Configuration@EnableCachingpublic class MyCacheConfig { @Bean RedisCacheConfiguration redisCacheConfiguration(){ RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig(); //config = config.entryTtl(); config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer())); config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer())); return config; }} application.properties里面配置了过期时间，为了使我们的配置生效。 重新启动后，查看redis中的缓存数据。 配置其他内容。 123456789spring.cache.type=redis#spring.cache.cache-names=qq,#单位是毫秒spring.cache.redis.time-to-live=3600000#如果指定了前缀就用我们指定的前缀，如果没有就默认使用缓存的名字作为前缀。spring.cache.redis.key-prefix=CACHE_spring.cache.redis.use-key-prefix=false#是否缓存空值，防止缓存穿透spring.cache.redis.cache-null-values=true 171、缓存-SpringCache-@CacheEvict缓存失效模式：修改的时候使缓存消失，下次重新查询的时候，再加入缓存。 修改过后就可以在 RedisDeskTopManager客户端查看，可以看到缓存删除了。 之后修改我们原本获取三级分类的方法。 重启服务，刷新首页。 第一次访问之后缓存就存到redis中了，再次刷新首页就不会去访问数据库了。 但是现在修改菜单数据之后删除键为getLeve1Categorys的缓存数据，我们想要修改菜单之后两个缓存数据都删除掉。有以下两种方式： 1.同时进行多种缓存：@Caching2.指定删除某个分区下的所有数据：@CacheEvict(value = “category”,allEntries = true) 12345678910111213141516171819/** * 级联更新所有关联的数据 * @CacheEvict：失效模式 * 1.同时进行多种缓存：@Caching * 2.指定删除某个分区下的所有数据：@CacheEvict(value = \"category\",allEntries = true) * 存储同一类型的数据，都可以指定成同一分区。分区名默认就是缓存的前缀。 * @param category */@Caching(evict = { @CacheEvict(value = \"category\" ,key = \"'getLeve1Categorys'\"), @CacheEvict(value = \"category\" ,key = \"'getCatalogJson'\"),})//@CacheEvict(value = \"category\",allEntries = true)@Transactional@Overridepublic void updateCascade(CategoryEntity category) { this.updateById(category); categoryBrandRelationService.updateCategory(category.getCatId(),category.getName());} 推荐配置 12//@CachePut//双写模式@CacheEvict(value = &quot;category&quot;,allEntries = true)//失效模式 172、缓存-SpringCache-原理与不足Spring-Cache的不足 读模式： 缓存击穿：查询一个null数据。解决：缓存空数据：cache-null-values。 缓存穿透：大量并发进来同时查找一个正好过期的数据。解决：加锁：？默认是无加锁的。sync = true（加锁解决击穿） 缓存雪崩：大量的key同时过期。解决：加随机时间。加上过期时间。 写模式：(缓存和数据库不一致) 1).读写加锁。 2).引入Canal，感知MySQL的更新去更新数据库。 3).读少写多，直接去数据库查询就行。 原理 CacheManager(RedisCacheManager) -&gt; Cache(RedisCache) -&gt; Cache负责缓存的读写 总结： 常规数据（读多写少。即时性，一致性要求不高的数据）：完全可以使用spring-cache：写模式（只要缓存的数据又过期时间就足够了） 特殊数据：特殊设计。","link":"/shop-mall/cache-and-distributed-lock.html"},{"title":"十、性能压测","text":"【摘要】压力测试考察当前软硬件环境下所能承受的最大负荷并帮助找出系统瓶颈所在。压测都是为了系统在线上的处理能力和稳定性维持在一个标准范围内，做到心中有数 前言性能压测-压力测试-基本介绍性能监控压力测试压力测试考察当前软硬件环境下所能承受的最大负荷并帮助找出系统瓶颈所在。压测都是为了系统在线上的处理能力和稳定性维持在一个标准范围内，做到心中有数。 使用压力测试，我们有希望找到很多种用其他测试方式更难发现的错误。有两种错误类型是：内存泄露，并发与同步。 有效的压力测试系统将应用以下这些关键条件：重复、并发、量级、随机变化。 性能指标 响应时间(Response Time:RT) 响应时间指用户从客户端发起一个请求开始，到客户端接收到从服务器端返回的响应结束，整个过程所消耗的时间。 HPS(Hits Per Second)：每秒点击次数，单位是次/秒。 TPS(Transaction Per Second)：系统每秒处理交易数，单位是笔/秒。 QPS(Query Per Second)：系统每秒处理查询次数，单位是笔/秒。 无论TPS、QPS、HPS，此指标是衡量系统处理能力非常重要的指标，越大越好。根据经验，一般情况下： 金融行业：1000TPS~50000TPS，不包括互联网化的活动。 保险行业：100TPS~100000TPS，不包括互联网化的活动。 制造行业：10TPS~5000TPS。 互联网电子商务：10000TPS~1000000TPS。 互联网中型网站：1000TPS~50000TPS。 互联网小型网站：500TPS~10000TPS。 最大响应时间(Max Response Time) 指用户发出请求或者指令到系统做出反应(响应)的最大时间。 最少响应时间(Mininum Response Time) 指用户发出请求或者指令到系统做出反应(响应)的最少时间。 90%响应时间(90% Response Time) 是指所有用户的响应时间进行排序，第90%的响应时间。 从外部看，性能测试主要关注如下三个指标： 吞吐量：每秒种系统能够处理的请求数、任务数。 响应时间：服务处理一个请求或一个任务的耗时。 错误率：一批请求中结果出错的请求所占比例。 性能压测-压力测试-Apache JMeter安装使用JMeterJMeter安装https://jmeter.apache.org/ JMeter压测示例1.添加线程组。2.添加HTTP请求。3.添加监听器。4.启动压测&amp;查看分析报告。 创建测试计划 右击测试计划-&gt;添加-&gt;线程(用户)-&gt;线程组 设置线程数为200，Ranm-Up时间为1秒，循环次数为100。 右击线程组-&gt;添加-&gt;取样器-&gt;HTTP请求 右击线程组-&gt;添加-&gt;监听器-&gt;察看结果树、汇总报告、聚合报告、汇总图 影响性能考虑点包括： 数据库、应用程序、中间件(tomcat、Nginx)、网络和操作系统等方面。 首先要考虑自己的应用属于CPU密集型何时IO密集型。 JMeter Address Already in use错误解决windows本身提供的端口访问机制的问题。 Windows提供给TCP/IP链接的端口为1024-5000，并且要四分钟来循环回收他们。就导致我们在短时间内跑大量的请求时将端口占满了。 在cmd中，用regedit命令打开注册表。 在HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters下： 右击parameters，添加一个新的DWORD，名字为MaxUserPort。 然后双击MaxUserPort，输入数值数据为65534，基数选择十进制（如果是分布式运行的话，控制机器和负载机器都需要这样操作哦） 修改配置完毕之后记得重启机器才生效。 https://docs.microsoft.com/zh-cn/troubleshoot/windows-client/networking/connect-tcp-greater-than-5000-error-wsaenobufs-10055 TCPTimeWaitDelay：30 性能压测-压力测试-JMeter在windows下地址占用bug解决 性能压测-性能监控-堆内存与垃圾回收 性能压测-性能监控-jvisualvm使用jconsole与jvisualvmjdk的两个小工具jconsole、jvisualvm(升级版的jconsole)；通过命令行启动，可监控本地和远程应用。远程应用需要配置。 因为我的电脑上已经安装了java的环境，所以在控制台直接输入下面的命令。 1zhangyao@MacBookPro ~ % jconsole 就会跳出如下界面。 推荐使用jvisualvm。 1zhangyao@MacBookPro ~ % jvisualvm 工具-&gt;插件 性能压测-优化-中间件对性能的影响输入zhelimall.com 客户端-&gt;nginx-&gt;gateway-&gt;集群的商品服务-&gt;gateway-&gt;nginx-&gt;客户端。 这个过程请求经历了两个中间件分别是nginx和gateway。 压测内容 接口地址示例 压测线程数 吞吐量/sec 90%响应时间/ms 99%响应时间/ms Nginx 192.168.60.105 50 433 105 640 Gateway 127.0.0.1:88 50 14143 5 9 简单服务 localhost:8000/hello 50 14546 2 4 首页一级菜单渲染 localhost:8000/ 50 614(db,thymelef) 89 139 首页一级菜单渲染(开thymelef缓存) localhost:8000/ 50 814 62 94 首页一级菜单渲染(开thymelef缓存、优化数据库、关日志) localhost:8000/ 50 1161.1 46 72 三级分类数据获取 127.0.0.1:8000/index/catalog.json 50 7.4(db)/12.4(加索引) … … 三级分类数据获取(优化业务) 127.0.0.1:8000/index/catalog.json 50 191 290 370 三级分类数据获取(使用redis作为缓存) 127.0.0.1:8000/index/catalog.json 50 508 105 132 首页全量数据获取 127.0.0.1:8000/ 50 22.6(静态资源) 2814 23920 Nginx+Gateway 50 Gateway+简单服务 localhost:88/hello 50 7014 11 25 全链路 zhelimall.com/hello 50 700 59 152 中间件越多，性能损失越大，大多都是损失在网络交互上了； 优化业务 DB(MySQL优化) 模板的渲染速度(缓存) 静态资源 给数据库添加索引 性能压测-优化-简单优化吞吐量测试性能压测-优化-nginx动静分离前面我们是把所有的静态资源static/index/css、static/index/img、static/index/js。都放在微服务的tomcat下，这样关静态请求就占用了tomcat的很多资源，导致吞吐量急剧的降低。为了解决这个问题就可以使用nginx进行动静分离。 把项目下的static文件夹搬到nginx/html下。 替换链接、script、图片的路径。 修改nginx的配置，之后重启nginx。 1234567891011121314151617181920server { listen 80; server_name zhelimall.com; #static路径下的转到/usr/share/nginx/html location /static/ { root /usr/share/nginx/html; } location / { root /usr/share/nginx/html; proxy_set_header Host $host; proxy_pass http://zhelimall; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; }} 性能压测-优化-模拟线上应用内存崩溃宕机情况调整商品服务运行内存-Xmx50m，然后使用200个压测线程数。 使用jvisualvm监控Java后台运行情况。 程序后台抛出很多异常。 在浏览器访问zhelimall.com发现服务已经不可用。 重新调整-Xmx1024m -Xms1024m -Xmn512m启动内存。 性能压测-优化-优化三级分类数据获取三级分类数据获取速度慢主要原因是在业务端进行了太多次与数据库的交互。把启动内存调整为-Xmx100m。优化思路主要是：把多次查询数据库变成一次。先把三级分类一次性全部查出存放在list中，然后在对list进行操作。","link":"/shop-mall/performance-pressure-test.html"}],"tags":[{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"CataLog","slug":"CataLog","link":"/tags/CataLog/"},{"name":"Business","slug":"Business","link":"/tags/Business/"},{"name":"MarkDown","slug":"MarkDown","link":"/tags/MarkDown/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"JavaSE","slug":"JavaSE","link":"/tags/JavaSE/"},{"name":"DLMS","slug":"DLMS","link":"/tags/DLMS/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Dos","slug":"Dos","link":"/tags/Dos/"},{"name":"other","slug":"other","link":"/tags/other/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"ShopMall","slug":"ShopMall","link":"/tags/ShopMall/"},{"name":"Hello World","slug":"Hello-World","link":"/tags/Hello-World/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Python","slug":"Python","link":"/tags/Python/"}],"categories":[{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"CataLog","slug":"CataLog","link":"/categories/CataLog/"},{"name":"Business","slug":"Business","link":"/categories/Business/"},{"name":"MarkDown","slug":"MarkDown","link":"/categories/MarkDown/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"JavaSE","slug":"JavaSE","link":"/categories/JavaSE/"},{"name":"DLMS","slug":"DLMS","link":"/categories/DLMS/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"JDBC","slug":"JDBC","link":"/categories/JDBC/"},{"name":"多线程","slug":"多线程","link":"/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"redis","slug":"redis","link":"/categories/redis/"},{"name":"ShopMall","slug":"ShopMall","link":"/categories/ShopMall/"},{"name":"Hello World","slug":"Hello-World","link":"/categories/Hello-World/"},{"name":"杂记","slug":"杂记","link":"/categories/%E6%9D%82%E8%AE%B0/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Python","slug":"Python","link":"/categories/Python/"}]}